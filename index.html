
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        /* --- –∑–∞–ø—Ä–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–∏—è –≤—Å–µ–≥–æ —ç–∫—Ä–∞–Ω–∞ --- */
        html, body {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        body {
            background: transparent !important;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        #webgl-canvas {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            pointer-events: none;
        }
        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -20px); /* –ø–æ–¥–Ω—è—Ç–∏–µ –Ω–∞ 50px –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ç–µ–∫—É—â–µ–≥–æ */
            width: 100%;
            padding: 20px;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }
        .soul-container {
            position: relative;
            margin-bottom: 55px;
        }
 
        .aura {
            position: absolute;
            inset: -20px;
            border-radius: 50%;
            background: none;
            animation: auraGlow 3s infinite ease-in-out;
            opacity: 0.5;
        }

        #status {
            font-size: 16.6px;
            font-weight: 300;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.9;
            margin-bottom: 2px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
            animation: statusFade 11.8s infinite ease-in-out;
            color: rgba(255, 255, 255, 0.8);
        }
        
        @keyframes statusFade { 0%,100%{opacity:0.34} 50%{opacity:1} }
        #transcript {
            font-size: 13.5px;
            max-width: 90%;
            text-align: center;
            opacity: 0.9;
            line-height: 1.6;
            padding: 15px;
            max-height: 180px;
            margin-top: 10px;
            overflow-y: auto;
            color: rgba(255, 255, 255, 0.6);
            background: transparent;
            backdrop-filter: none;
            box-shadow: none;
            border: none;

            cursor: pointer; 

            word-break: keep-all !important;     
            overflow-wrap: break-word !important; 
            hyphens: manual !important;           
            white-space: pre-wrap !important;     
        }


        #current-response {
            word-break: keep-all !important;
            overflow-wrap: break-word !important;
            hyphens: manual !important;
            white-space: pre-wrap !important;
            display: inline;
            user-select: text !important;
            cursor: text;
        }

        #transcript pre, #transcript code {
            font-family: 'Fira Mono', 'Consolas', 'Menlo', 'Monaco', monospace;
            background: rgba(30, 30, 40, 0.92);
            color: #e5e5ff;
            border-radius: 7px;
            padding: 0.6em 1em;
            margin: 0.5em 0;
            font-size: 14px;
            overflow-x: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            text-align: left;
            word-break: keep-all !important;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            hyphens: none;
        }
        #transcript pre {
            white-space: pre-wrap;
        }
        #transcript code {
            background: none;
            padding: 0;
        }
        
        #transcript::-webkit-scrollbar { width: 3px; }
        #transcript::-webkit-scrollbar-track { background: transparent; }
        #transcript::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        .tap-hint {
            position: absolute;
            bottom: 20px;
            font-size: 12px;
            opacity: 0.4;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.6);
        }
        /* –≠—Ñ—Ñ–µ–∫—Ç –∫—É—Ä—Å–æ—Ä–∞ –¥–ª—è –ø–µ—á–∞—Ç–∏ */
        .typing-cursor::after {
            content: '‚ñã';
            display: inline-block;
            vertical-align: bottom;
            animation: blink 1.314s step-end infinite;
            color: rgba(255, 255, 255, 0.8);
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
   
        .glass-char {
            display: inline-block;
            opacity: 0;
            filter: blur(6px);
            transform: translateY(6px) scale(0.96);
            animation: glassIn 420ms ease-out forwards;
    
            /* –ü—Ä–∞–≤–∏–ª–∞ –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ */
            word-break: keep-all !important;
            overflow-wrap: normal !important;
            white-space: normal !important;
            hyphens: none !important;
        }

        @keyframes glassIn {
            0% {
                opacity: 0;
                filter: blur(6px);
                transform: translateY(6px) scale(0.96);
            }
            100% {
                opacity: 1;
                filter: blur(0);
                transform: translateY(0) scale(1);
            }
        }
      
        .word {
            white-space: nowrap !important;
            display: inline-block !important;
        }
        .word-appear {
            opacity: 0;
            transform: translateY(8px);
            animation: appearWord 0.42s ease forwards;
        }

        @keyframes appearWord {
            to { opacity: 1; transform: translateY(0); }
        }

  
        #orb-interactive, #orb {
            user-select: none;       /* —Å—Ç–∞–Ω–¥–∞—Ä—Ç */
            -webkit-user-select: none; /* Safari/Chrome */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* IE10+ */
        }

        #status, #current-response {
            user-select: none; /* —Å—Ç–∞—Ç—É—Å –Ω–µ –≤—ã–¥–µ–ª—è–µ–º */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

    </style>
    <style>
    /* --- Chat animated char/word effect (voice mode) --- */
    .chat-message.ai .text {
      white-space: pre-wrap;
    }

    .chat-char {
      display: inline-block;
      opacity: 0;
      filter: blur(6px);
      transform: translateY(6px) scale(0.96);
      animation: chatCharIn 0.42s cubic-bezier(0.33,1,0.68,1) forwards;
    }

    @keyframes chatCharIn {
      0% {
        opacity: 0;
        filter: blur(6px);
        transform: translateY(6px) scale(0.96);
      }
      100% {
        opacity: 1;
        filter: blur(0);
        transform: translateY(0) scale(1);
      }
    }

    .chat-cursor::after {
      content: '‚ñã';
      margin-left: 2px;
      animation: blink 1.3s step-end infinite;
      opacity: 0.8;
    }

    /* === AI typing square cursor === */
    .ai-cursor {
        display: inline-block;
        width: 0.6em;
        height: 1.1em;
        margin-left: 2px;
        background: rgba(255,255,255,0.85);
        box-shadow: 0 0 8px rgba(255,255,255,0.6);
        animation: ai-cursor-blink 0.9s steps(1) infinite;
        vertical-align: bottom;
    }

    @keyframes ai-cursor-blink {
        0% { opacity: 1; }
        50% { opacity: 0; }
        100% { opacity: 1; }
    }
    </style>
    <style>
        #orb-interactive {
            position: absolute;
            left: 50%;
            top: 20%;
            width: 200px;
            height: 200px;
            transform: translate(-50%, -50%);
            z-index: 10;
            cursor: pointer;

            /* –∑–∞–ø—Ä–µ—Ç –≤—ã–¥–µ–ª–µ–Ω–∏—è –∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none; /* –¥–ª—è iOS */
            -webkit-tap-highlight-color: transparent; /* —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –ø—Ä–∏ —Ç–∞–ø–µ */
        }
    
    
    </style>    
    <style>
    .soul-orb {
        animation: none;
        transition: box-shadow 0.3s ease, transform 0.3s ease;
    }
    </style>
    <style>
    /* === Chat swipe layout === */
    .main-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      transition: transform .3s cubic-bezier(.4,0,.2,1);
      will-change: transform;
      overflow: hidden;
    }

    .main-content {
        min-width: 100%;
        width: 100%;
        height: 100%;
        position: relative;
        flex-shrink: 0;
        transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        will-change: transform;
    }

    .main-wrapper.chat-open .main-content {
        transform: translateX(-80%);
    }

    /* --- Chat panel fix --- */
    .chat-panel {
        position: absolute;
        right: 0;
        top: 0;
        width: 80%;
        height: 100%;
        transform: translateX(100%);
        background: transparent !important;
        backdrop-filter: none !important;
        display: flex;
        flex-direction: column;
        transition: transform .4s cubic-bezier(.4,0,.2,1);
        z-index: 1;
        pointer-events: auto;
        overflow: hidden;
    }

    .main-wrapper.chat-open .chat-panel {
        transform: translateX(0);
    }
    
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 93px 24px 24px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
        position: relative;
        z-index: 2;
    }
    /* --- Chat shader canvas --- */
    #chatShaderCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: -1; 
        background: transparent;
        display: block;
    }

    .chat-message.user,
    .chat-message.ai {
        background: rgba(255,255,255,0);
        backdrop-filter: blur(3px);
        border-radius: 16px;
        padding: 8px 12px;
        max-width: 85%;
        font-size: 12px;
    }

    #transcript pre, #transcript code {
        background: transparent;
        box-shadow: none;
        border: none;
    }

    .chat-input {
        display: flex;
        gap: 9px;
        padding: 16px 20px 22px;
        background: rgba(0,0,0,0);
        border: none;
    }

    .chat-input textarea {
        flex: 1;
        padding: 10px 16px;
        min-height: 25px;
        max-height: 140px;
        resize: none;
        overflow-y: auto;
        background: rgba(0,0,0,0);
        border: none;
        border-radius: 20px;
        color: #fff;
        outline: none;
        line-height: 1.35;
    }
    .chat-input button {
        background: rgba(0,0,0,0);
        border: none;
        color: #fff;
        outline: none;
        border-radius: 20px;
        padding: 0 14px; 
    }
    /* --- Chat message containers text wrapping --- */
    .chat-message .text {
        white-space: pre-wrap;
        word-break: normal;
        overflow-wrap: break-word;
        hyphens: auto;
    }
    </style>
    <!--  Prism.js for code-->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <!-- Glass overlay gradient blur REFACTORED: separate top/bottom edges blur -->
    <style>
    .glass-edge {
        position: fixed;
        left: 0;
        width: 100%;
        height: 27px;
        pointer-events: none;
        backdrop-filter: blur(1px);
        -webkit-backdrop-filter: blur(1px);
        z-index: 1000;
    }

    .glass-top {
        top: 0px;
        background: rgba(255,255,255,0.05);
        backdrop-filter: blur(11px);
        -webkit-backdrop-filter: blur(11px);
        position: fixed;
        left: 0;
        width: 100%;
        height: 120px; /* –ø–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –≤ –±–ª—é—Ä */

        /* –ø–ª–∞–≤–Ω–∞—è –º–∞—Å–∫–∞ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö */
        -webkit-mask-image: linear-gradient(to top, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 100%);
        -webkit-mask-repeat: no-repeat;
        -webkit-mask-size: 100% 100%;
        mask-image: linear-gradient(to top, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 100%);
        mask-repeat: no-repeat;
        mask-size: 100% 100%;
    }

    .glass-bottom {
        bottom: 0px;
        background: rgba(255,255,255,0.05);
        backdrop-filter: blur(7px);
        -webkit-backdrop-filter: blur(7px);
        position: fixed;
        left: 0;
        width: 100%;
        height: 23px; /* –ø–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –≤ –±–ª—é—Ä */

        /* –ø–ª–∞–≤–Ω–∞—è –º–∞—Å–∫–∞ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö */
        -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 100%);
        -webkit-mask-repeat: no-repeat;
        -webkit-mask-size: 100% 100%;
        mask-image: linear-gradient(to bottom, rgba(0,0,0,0) 0%, rgba(0,0,0,1) 100%);
        mask-repeat: no-repeat;
        mask-size: 100% 100%;
    }
    <!-- –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç CSS –≤ —Å–µ–∫—Ü–∏—é <style> -->
<style>
    /* === Settings Panel === */
    .settings-panel {
        position: absolute;
        left: 0;
        top: 0;
        width: 80%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        transform: translateX(-100%);
        transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 100;
        padding: 80px 24px 24px;
        overflow-y: auto;
        box-shadow: 5px 0 30px rgba(0, 0, 0, 0.5);
        border-right: 1px solid rgba(255, 255, 255, 0.1);
    }

    .main-wrapper.settings-open .settings-panel {
        transform: translateX(0);
    }

    .main-wrapper.settings-open .main-content {
        transform: translateX(80%);
    }

    .settings-header {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 30px;
        color: #fff;
        text-align: center;
        letter-spacing: 1px;
    }

    .settings-group {
        margin-bottom: 25px;
        padding-bottom: 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .settings-title {
        font-size: 14px;
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .settings-option {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .settings-option:last-child {
        border-bottom: none;
    }

    .option-label {
        font-size: 15px;
        color: rgba(255, 255, 255, 0.9);
    }

    .option-description {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.5);
        margin-top: 4px;
    }

    /* Toggle Switch */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 52px;
        height: 26px;
    }

    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.2);
        transition: .3s;
        border-radius: 34px;
    }

    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .3s;
        border-radius: 50%;
    }

    input:checked + .toggle-slider {
        background-color: #4CAF50;
    }

    input:checked + .toggle-slider:before {
        transform: translateX(26px);
    }

    /* Size Selector */
    .size-selector {
        display: flex;
        gap: 8px;
    }

    .size-btn {
        flex: 1;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.7);
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
        font-size: 13px;
        transition: all 0.2s;
    }

    .size-btn.active {
        background: rgba(76, 175, 80, 0.3);
        border-color: #4CAF50;
        color: #fff;
    }

    /* Mode Selector */
    .mode-selector {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .mode-btn {
        padding: 12px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.7);
        border-radius: 10px;
        cursor: pointer;
        text-align: center;
        font-size: 14px;
        transition: all 0.2s;
    }

    .mode-btn.active {
        background: rgba(33, 150, 243, 0.3);
        border-color: #2196F3;
        color: #fff;
    }

    .mode-icon {
        margin-right: 8px;
        font-size: 16px;
    }

    /* Apply Button */
    .apply-btn {
        width: 100%;
        padding: 14px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        margin-top: 30px;
        transition: transform 0.2s;
    }

    .apply-btn:active {
        transform: scale(0.98);
    }

    /* Shaders Disabled State */
    body.shaders-disabled #webgl-canvas,
    body.shaders-disabled #chatShaderCanvas {
        display: none !important;
    }

    body.shaders-disabled .main-content {
        background: #000 !important;
    }

    /* Interface Size States */
    body.interface-small {
        font-size: 12px;
    }

    body.interface-small .chat-input textarea {
        min-height: 35px;
        font-size: 13px;
    }

    body.interface-medium {
        font-size: 14px;
    }

    body.interface-medium .chat-input textarea {
        min-height: 45px;
        font-size: 15px;
    }

    body.interface-large {
        font-size: 16px;
    }

    body.interface-large .chat-input textarea {
        min-height: 60px;
        font-size: 17px;
        padding: 15px;
    }

    body.interface-large .chat-message {
        font-size: 15px;
        padding: 12px 16px;
    }

    /* Text-only Mode */
    body.text-only-mode #orb-interactive,
    body.text-only-mode #orb,
    body.text-only-mode .soul-container {
        display: none !important;
    }

    body.text-only-mode .content {
        top: 20%;
        transform: translate(-50%, 0);
    }

    body.text-only-mode #transcript {
        max-height: 70vh;
        font-size: 15px;
    }

    /* Settings Icon */
    .settings-icon {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 44px;
        height: 44px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 20px;
        cursor: pointer;
        z-index: 50;
        transition: all 0.3s;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .settings-icon:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
    }
</style>
    </style>
</head>
<body>
<div class="glass-edge glass-top"></div>
<div class="glass-edge glass-bottom"></div>
<!-- Main wrapper for slide -->
<div class="main-wrapper" id="mainWrapper">


  <div class="main-content">
    <canvas id="webgl-canvas"></canvas>
    <video id="camera-video" autoplay playsinline style="display:none;"></video>

    <div class="content">
      <div class="soul-container">
        <div class="aura"></div>
        <div id="orb" class="soul-orb"></div>
        <div id="orb-interactive"></div>
      </div>

      <div id="status">connecting</div>
      <div id="transcript"></div>
    </div>

    <img id="img" src="" alt="Generated Image"
      style="display:none;">
  </div>

  <!-- Chat panel -->
    <div class="chat-panel" id="chatPanel" style="position:absolute;right:0;top:0;width:80%;height:100%;overflow:hidden;">
        <canvas id="chatShaderCanvas"
            style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:0;display:block;"
        ></canvas>
        <div class="chat-messages" id="chatMessages" style="position:relative;z-index:2;background:transparent;box-shadow:none;"></div>
        <div class="chat-input" style="position:relative;z-index:2;background:transparent;box-shadow:none;">
            <textarea id="chatInput" placeholder="Type message..."></textarea>
            <button id="sendBtn">Send</button>
        </div>
    </div>
    <!-- –î–æ–±–∞–≤—å—Ç–µ —ç—Ç—É HTML-—Ä–∞–∑–º–µ—Ç–∫—É –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã–≤–∞—é—â–µ–≥–æ </div> –¥–ª—è .chat-panel -->
<div class="settings-icon" id="settingsIcon">‚öôÔ∏è</div>

<div class="settings-panel" id="settingsPanel">
    <div class="settings-header">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</div>
    
    <div class="settings-group">
        <div class="settings-title">–í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã</div>
        <div class="settings-option">
            <div>
                <div class="option-label">–í—ã–∫–ª—é—á–∏—Ç—å —à–µ–π–¥–µ—Ä—ã</div>
                <div class="option-description">–ß–µ—Ä–Ω—ã–π —Ñ–æ–Ω –≤–º–µ—Å—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤</div>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="shadersToggle">
                <span class="toggle-slider"></span>
            </label>
        </div>
    </div>
    
    <div class="settings-group">
        <div class="settings-title">–†–∞–∑–º–µ—Ä –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</div>
        <div class="size-selector">
            <div class="size-btn" data-size="small">–ú–∞–ª–µ–Ω—å–∫–∏–π</div>
            <div class="size-btn active" data-size="medium">–°—Ä–µ–¥–Ω–∏–π</div>
            <div class="size-btn" data-size="large">–ë–æ–ª—å—à–æ–π</div>
        </div>
    </div>
    
    <div class="settings-group">
        <div class="settings-title">–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã</div>
        <div class="mode-selector">
            <div class="mode-btn active" data-mode="voice">
                <span class="mode-icon">üé§</span> –ì–æ–ª–æ—Å–æ–≤–æ–π —Ä–µ–∂–∏–º
            </div>
            <div class="mode-btn" data-mode="text">
                <span class="mode-icon">‚å®Ô∏è</span> –¢–µ–∫—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º
            </div>
        </div>
    </div>
    
    <div class="settings-group">
        <div class="settings-title">–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ</div>
        <div class="settings-option">
            <div>
                <div class="option-label">–í–∏–±—Ä–∞—Ü–∏–∏</div>
                <div class="option-description">–¢–∞–∫—Ç–∏–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å</div>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="vibrationsToggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
        <div class="settings-option">
            <div>
                <div class="option-label">–ó–≤—É–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</div>
                <div class="option-description">–ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã</div>
            </div>
            <label class="toggle-switch">
                <input type="checkbox" id="soundsToggle" checked>
                <span class="toggle-slider"></span>
            </label>
        </div>
    </div>
    
    <button class="apply-btn" id="applySettings">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</button>
</div>

</div>




    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';
        
        const canvas = document.getElementById('webgl-canvas');

        // ===== –ñ—ë—Å—Ç–∫–∏–π —Ñ–∏–∫—Å: —á–∞—Ç –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ –Ω–æ—É—Ç–µ =====
        const chat =
            document.querySelector('#chat') ||
            document.querySelector('#chatContainer') ||
            document.querySelector('.chat-messages') ||
            document.getElementById('chatMessages');

        if (chat && canvas) {
            canvas.style.pointerEvents = 'none';
            chat.style.pointerEvents = 'auto';
            chat.style.zIndex = '10';
        }

        const isApple = /Mac|iPhone|iPad|iPod/i.test(navigator.userAgent);

let renderer;
let isActiveTab = true;

        if (isApple && THREE.WebGPURenderer) {
            renderer = new THREE.WebGPURenderer({
                canvas,
                alpha: true,
                antialias: true
            });
            // Safari WebGPU: –ª—ë–≥–∫–∏–π downscale –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –ø–∞–º—è—Ç–∏
            renderer.setPixelRatio(window.devicePixelRatio * 0.63);
        } else {
            renderer = new THREE.WebGLRenderer({
                canvas,
                alpha: true,
                antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
        }

        renderer.autoClear = true;
        renderer.setClearColor(0x000000, 1);
        renderer.clear(true, true, true);

        // --- –∑–∞—â–∏—Ç–∞ –æ—Ç –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è —Å–≤–µ—Ç–∞ ---
        renderer.toneMapping = THREE.NoToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.LinearSRGBColorSpace;

        renderer.setSize(window.innerWidth, window.innerHeight);
        // (–æ—Å—Ç–∞–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—ã—à–µ, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è)

        document.addEventListener('visibilitychange', () => {
            isActiveTab = !document.hidden;

            if (!isActiveTab) {
                orbEnergy = 0;
                speechEnvelope = 0;

                if (speechSynthesis) speechSynthesis.cancel();
                if (audioContext?.state === 'running') audioContext.suspend();

                // —Å–±—Ä–æ—Å GPU feedback (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è Safari / mobile)
                renderer.setRenderTarget(feedbackRT1);
                renderer.clear(true, true, true);
                renderer.setRenderTarget(feedbackRT2);
                renderer.clear(true, true, true);
                renderer.setRenderTarget(null);
            } else {
                if (audioContext?.state === 'suspended') audioContext.resume();
            }
        });

        canvas.addEventListener('webglcontextlost', (e) => {
            e.preventDefault();
            console.warn('WebGL context lost ‚Äî Safari memory protection triggered');
        });

        const scene = new THREE.Scene();

        let orbEnergy = 0;        // 0..1 ‚Äî —Ç–µ–∫—É—â–∞—è —ç–Ω–µ—Ä–≥–∏—è
        let targetEnergy = 0.22; // baseline listening
        let responseInertia = 0.03; // –±–∞–∑–æ–≤–∞—è –∏–Ω–µ—Ä—Ü–∏—è —Ä–µ–∞–∫—Ü–∏–∏ (—á–µ–º –º–µ–Ω—å—à–µ ‚Äî —Ç–µ–º –º–µ–¥–ª–µ–Ω–Ω–µ–µ)

        const transcriptDiv = document.getElementById('transcript');

        transcriptDiv.addEventListener('click', () => {
            const text = transcriptDiv.innerText;
            if (!text) return;

            navigator.clipboard.writeText(text)
                .then(() => {
                    console.log('–¢–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!');
                    // ===== Popup –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏ =====
                    copyPopup.style.opacity = '1';
                    copyPopup.style.transform = 'translate(-50%, -200%)';
                    setTimeout(() => {
                        copyPopup.style.opacity = '0';
                        copyPopup.style.transform = 'translate(-50%, -180%)';
                    }, 1000);
                })
                .catch(err => console.error('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞: ', err));
        });

                // --- –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ AI-—Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç–µ –ø–æ –∫–ª–∏–∫—É ---
        document.addEventListener('click', (e) => {
            const target = e.target.closest('.chat-message.ai .text');
            if (!target) return;
            const text = target.innerText;
            if (!text) return;

            navigator.clipboard.writeText(text)
                .then(() => {
                    console.log('AI message copied!');
                    copyPopup.style.opacity = '1';
                    copyPopup.style.transform = 'translate(-50%, -200%)';
                    setTimeout(() => {
                        copyPopup.style.opacity = '0';
                        copyPopup.style.transform = 'translate(-50%, -180%)';
                    }, 1000);
                })
                .catch(err => console.error('Error copying AI message: ', err));
        });


        // ===== Popup –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏ =====
        let copyPopup = document.createElement('div');
        copyPopup.id = 'copy-popup';
        copyPopup.textContent = 'Text copied';
        document.body.appendChild(copyPopup);



        // CSS –¥–ª—è –ø–æ–ø–∞–ø–∞
        const style = document.createElement('style');
        style.textContent = `
            #copy-popup {
                position: absolute;
                top: 86.16%;
                left: 50%;
                transform: translate(-50%, -180%);
                background: rgba(255,255,255,0.001);
                color: #eee;
                padding: 4px 10px;
                font-size: 11px;
                pointer-events: none;
                opacity: 0;
                transition: opacity 0.25s ease, transform 0.25s ease;
                z-index: 20;
                user-select: none;
            }
            `;
        document.head.appendChild(style);

        // === –¢–µ–ª–µ—Å–Ω–∞—è –ø–∞–º—è—Ç—å –∂–µ—Å—Ç–æ–≤ ===
        const touchMemory = [];
        const MAX_TOUCH_POINTS = 16;
        // === –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–æ–≤ –ø–æ –∫–∞–Ω–≤–∞—Å—É –¥–ª—è —Ç–µ–ª–µ—Å–Ω–æ–π –ø–∞–º—è—Ç–∏ ===
        renderer.domElement.addEventListener('pointerdown', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            const x = (event.clientX - rect.left) / rect.width;
            const y = 1.0 - (event.clientY - rect.top) / rect.height;

            touchMemory.push({
                x,
                y,
                strength: 1.0
            });

            if (touchMemory.length > MAX_TOUCH_POINTS) {
                touchMemory.shift();
            }
        });

        // === Shader as Brain Interface ===
        // –®–µ–π–¥–µ—Ä –Ω–∞–ø—Ä—è–º—É—é –æ—Ç—Ä–∞–∂–∞–µ—Ç –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        function updateOrbVisualState() {
            if (typeof selfAwareness === 'undefined') return;

            // —ç–Ω–µ—Ä–≥–∏—è –æ—Ä–±–∞ = —Å–º–µ—Å—å –ª—é–±–æ–ø—ã—Ç—Å—Ç–≤–∞ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
            const moodNorm = Math.max(0, Math.min(1, (selfAwareness.mood + 1) / 2));
            const curiosity = selfAwareness.curiosity ?? 0.3;
            const fatigue = selfAwareness.fatigue ?? 0.0;

            // —Ü–µ–ª–µ–≤–∞—è —ç–Ω–µ—Ä–≥–∏—è (audioLevel)
            targetEnergy =
                0.15 +
                0.55 * curiosity +
                0.35 * moodNorm -
                0.4 * fatigue;

            targetEnergy = Math.max(0.05, Math.min(1.0, targetEnergy));

            // —Ä–µ–∂–∏–º –æ—Ä–±–∞ –∫–∞–∫ –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ "–º—ã—à–ª–µ–Ω–∏—è"
            // 0 ‚Äî idle, 1 ‚Äî listening, 2 ‚Äî curious, 3 ‚Äî excited, 4 ‚Äî overloaded
            let mode = 0;
            if (fatigue > 0.7) mode = 4;
            else if (curiosity > 0.75) mode = 2;
            else if (moodNorm > 0.7) mode = 3;
            else if (curiosity > 0.3) mode = 1;
            
            setOrbMode(mode);
            // --- feed learning signal into shader memory ---
            feedbackMaterial.uniforms.learning.value =
                Math.min(
                    1.0,
                    selfAwareness.curiosity * 0.6 +
                    (1.0 - selfAwareness.fatigue) * 0.4
            );

            feedbackMaterial.uniforms.plasticity.value =
                    0.15 + selfAwareness.focus * 0.4;

            // --- micro‚Äëhesitation: —Å–æ–º–Ω–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ –ª–∞–≥–∞ ---
            // —É—Å—Ç–∞–ª–æ—Å—Ç—å –∑–∞–º–µ–¥–ª—è–µ—Ç –æ—Ç–∫–ª–∏–∫, curiosity –¥–µ–ª–∞–µ—Ç –µ–≥–æ –Ω–µ—Ä–≤–Ω—ã–º
            const fatigueVal = selfAwareness.fatigue ?? 0.0;
            const curiosityJitter = (Math.random() - 0.5) * 0.02 * (selfAwareness.curiosity ?? 0.0);

            responseInertia =
                0.04 +                 // –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∂–∏–≤–æ–π –æ—Ç–∫–ª–∏–∫
                (1.0 - fatigueVal) * 0.06; // —É—Å—Ç–∞–≤—à–∏–π ‚Äî –º–µ–¥–ª–µ–Ω–Ω–µ–µ

            responseInertia = Math.max(0.02, Math.min(0.12, responseInertia + curiosityJitter));
        }

        // === Feedback RenderTarget initialization ===
        const rtParams = {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            colorSpace: THREE.SRGBColorSpace
        };

        let feedbackRT1 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);
        let feedbackRT2 = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 5;

        // XDust —à–µ–π–¥–µ—Ä –¥–ª—è —á–∞—Å—Ç–∏—Ü
        const vertexShader = `
            attribute float size;
            attribute vec3 customColor;
            varying vec3 vColor;
            void main() {
                vColor = customColor;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (314.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
    uniform float time;
    const float PI = 3.141592653589793;
    varying vec3 vColor;

    vec3 XDust(vec3 p, vec3 c1, vec3 c2, vec3 c3) {
        vec3 dir = normalize(p - vec3(0.03, 0.02, 0.008)); 
        float d = length(dir);
        float anim = time * 0.168;
        if (d > 0.98 && d < 1.02) {
            float t = fract(sin(d * PI) * anim + c1.x);
            return mix(c1, c2, t);
        } else {
            float t = fract(cos(d * PI) * anim + c2.y);
            return mix(c2, c3, t);
        }
    }

    void main() {
        vec3 p = gl_PointCoord.xyx / vec3(2.0);

        // –º–∞—Å–ª—è–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞
        vec3 c1 = vec3(0.08, 0.03, 0.15);  // –∏–Ω–¥–∏–≥–æ
        vec3 c2 = vec3(0.18, 0.05, 0.08);  // –±–æ—Ä–¥–æ
        vec3 c3 = vec3(0.12, 0.08, 0.04);  // —Å–µ–ø–∏—è

        vec3 color = XDust(p, c1, c2, c3);

        // –¥—ã—Ö–∞–Ω–∏–µ
        float breath = 0.7 + 0.3 * sin(time * 0.4);
        color *= breath;

        // –º–∞–∑–∫–∏ –∫–∏—Å—Ç–∏
        float brushStroke = smoothstep(
            0.3,
            0.7,
            sin(p.x * 8.0 + time * 0.2) * cos(p.y * 6.0)
        );
        color = mix(color, color * 1.4, brushStroke * 0.3);

        float dist = length(gl_PointCoord - vec2(0.5));
        float alpha = (1.0 - smoothstep(0.0, 0.5, dist)) * 0.85;

        gl_FragColor = vec4(color * vColor, alpha);
    }
`;

        // === Fullscreen quad for feedback and blur ===
        const feedbackScene = new THREE.Scene();
        const feedbackCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        const feedbackMaterial = new THREE.ShaderMaterial({
            uniforms: {
                tOld: { value: null },
                tNew: { value: null },
                decay: { value: 0.96 },

                // --- synaptic memory ---
                plasticity: { value: 0.25 }, // –Ω–∞—Å–∫–æ–ª—å–∫–æ —Å–ª–µ–¥ –æ–±—É—á–∞–µ–º
                learning:   { value: 0.0 },  // –∫—Ä–∞—Ç–∫–∏–π –∏–º–ø—É–ª—å—Å –æ–±—É—á–µ–Ω–∏—è

                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform sampler2D tOld;
                uniform sampler2D tNew;
                uniform float decay;
                uniform float plasticity;
                uniform float learning;
                uniform vec2 resolution;

                // hash noise
                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43176.5453123);
                }

                vec2 noiseDir(vec2 uv) {
                    float n = hash(uv * resolution);
                    float a = n * 6.28318530718;
                    return vec2(cos(a), sin(a));
                }

                vec4 noiseBlur(sampler2D tex, vec2 uv) {
                    vec2 px = 1.0 / resolution;
                    vec2 dir = noiseDir(uv);

                    vec4 col = vec4(0.0);
                    col += texture2D(tex, uv) * 0.314;
                    col += texture2D(tex, uv + dir * px * 1.0) * 0.22;
                    col += texture2D(tex, uv - dir * px * 1.0) * 0.22;
                    col += texture2D(tex, uv + dir * px * 2.5) * 0.11;
                    col += texture2D(tex, uv - dir * px * 2.5) * 0.11;

                    return col;
                }

                void main() {
                    vec4 oldCol = noiseBlur(tOld, vUv);

                    // –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–∞—è —É—Å—Ç–∞–ª–æ—Å—Ç—å –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –∫–∞–¥—Ä–æ–≤ (alpha-–∫–∞–Ω–∞–ª)
                    float fatigueMemory = oldCol.a;

                    // –ª–æ–∫–∞–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å = —è—Ä–∫–æ—Å—Ç—å (–ø—Å–µ–≤–¥–æ‚Äë–Ω–µ–π—Ä–æ–Ω–Ω–∞—è –∞–∫—Ç–∏–≤–∞—Ü–∏—è)
                    float activity = dot(oldCol.rgb, vec3(0.181));

                    // –º–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —É—Å—Ç–∞–ª–æ—Å—Ç—å –æ—Ç —Ç–µ–∫—É—â–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
                    float instantFatigue = smoothstep(0.4, 0.9, activity);

                    // –º–µ–¥–ª–µ–Ω–Ω–æ–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å—Ç–∞–ª–æ—Å—Ç–∏
                    float fatigue = mix(
                        fatigueMemory * 0.995,
                        1.0,
                        instantFatigue * 0.02
                    );

                    // —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –ø–ª–∞—Å—Ç–∏—á–Ω–æ—Å—Ç—å —Å —É—á–µ—Ç–æ–º —É—Å—Ç–∞–ª–æ—Å—Ç–∏
                    float effectivePlasticity = plasticity * (1.0 - fatigue * 0.6);

                    // –æ–±—É—á–∞–µ–º–æ–µ –ª–æ–∫–∞–ª—å–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ (Hebbian‚Äëlike plasticity)
                    float localDecay = mix(
                        decay,
                        1.0,
                        activity * learning * effectivePlasticity
                    );

                    oldCol *= localDecay;
                    vec4 newCol = texture2D(tNew, vUv);
                    // —Å–æ—Ö—Ä–∞–Ω—è–µ–º —É—Å—Ç–∞–ª–æ—Å—Ç—å –æ–±—Ä–∞—Ç–Ω–æ –≤ –ø–∞–º—è—Ç—å
                    oldCol.a = clamp(fatigue, 0.0, 1.0);
                    vec4 color = max(oldCol * 0.96, newCol);
                    if (
                        any(isnan(color.rgb)) ||
                        any(isinf(color.rgb))
                    ) {
                        color = vec4(0.0, 0.0, 0.0, 1.0);
                    }
                    gl_FragColor = color;
                }
            `,
            transparent: true
        });

        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), feedbackMaterial);
        feedbackScene.add(quad);

        const particleCount = window.innerWidth < 768 ? 1000 : 9000;
        const positions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;

            sizes[i] = Math.random() * 3 + 1;

            // –ñ–∏–≤—ã–µ, –≥–∞—Ä–º–æ–Ω–∏—á–Ω—ã–µ —Ü–≤–µ—Ç–∞ —Å –ø–ª–∞–≤–Ω—ã–º —Å–º–µ—â–µ–Ω–∏–µ–º
            const hue = Math.random();
            const sat = 0.6 + Math.random() * 0.4;
            const light = 0.5 + Math.random() * 0.5;
            const col = new THREE.Color();
            col.setHSL(hue, sat, light);

            colors[i * 3] = col.r;
            colors[i * 3 + 1] = col.g;
            colors[i * 3 + 2] = col.b;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader,
            fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // === Artistic Glowing Orb Shader (Extended Modes, Audio-Reactive) ===
        // Geometry
        const orbGeometry = new THREE.SphereGeometry(0.85, 96, 96);
        // Vertex shader
        const orbVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.13);
            }
        `;
        const orbFragmentShader = `
            uniform float time;
            uniform float mode;
            uniform float modeSmooth;
            uniform float audioLevel;
            varying vec3 vNormal;
            varying vec3 vPosition;

            // -------- Utilities --------
            float fresnel(vec3 n, vec3 v, float p) {
                return pow(1.0 - clamp(dot(n, v), 0.0, 1.0), p);
            }

            float hash(vec3 p) {
                p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
                p *= 17.0;
                return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
            }

            float noise(vec3 p) {
                vec3 i = floor(p);
                vec3 f = fract(p);
                f = f*f*(3.0-2.0*f);
                return mix(
                    mix(mix(hash(i+vec3(0,0,0)), hash(i+vec3(1,0,0)), f.x),
                        mix(hash(i+vec3(0,1,0)), hash(i+vec3(1,1,0)), f.x), f.y),
                    mix(mix(hash(i+vec3(0,0,1)), hash(i+vec3(1,0,1)), f.x),
                        mix(hash(i+vec3(0,1,1)), hash(i+vec3(1,1,1)), f.x), f.y),
                    f.z);
            }

            float sparkle(vec3 p, float t) {
                vec3 q = p * 18.0;
                float n = noise(floor(q));
                float flicker = 0.5 + 0.5 * sin(t * 6.0 + n * 6.28318);
                return step(0.965, n) * flicker;
            }

            // --- Micro-speckle utility ---
            float microSpeckle(vec3 p, float t) {
                vec3 q = p * 22.0;
                float n = noise(floor(q));
                float flicker = 0.4 + 0.6 * sin(t * 7.0 + n * 6.28318);
                float radial = smoothstep(0.95, 0.15, length(p));
                return step(0.972, n) * flicker * radial;
            }

            vec3 palette(float t) {
                // –±–∞–∑–æ–≤–æ–µ –º–µ–¥–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è
                float time = t * 0.25;

                // –¥—ã—Ö–∞–Ω–∏—è (–Ω–µ—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ)
                float breathe =
                    sin(time * 0.7) * 0.4 +
                    sin(time * 1.1 + 1.7) * 0.35 +
                    sin(time * 0.43 + 4.2) * 0.25;
                breathe = breathe * 0.5 + 0.5;

                // —Å–ª–æ–∏
                float layerT = time + breathe * 0.6;
                float layer = floor(layerT * 2.5) / 2.5;
                float micro = fract(layerT * 2.5);

                // –≤–æ–ª–Ω–æ–≤–∞—è —Ñ–∞–∑–∞ (–∫—Ä–∞—è)
                float wavePhase =
                    sin(layerT * 1.4 + micro * 6.28318) *
                    sin(layerT * 0.6);

                // "—á–∞—Å—Ç–∏—Ü—ã" –≤–¥–æ–ª—å –≤–æ–ª–Ω—ã
                float particles =
                    smoothstep(0.6, 1.0,
                        fract(sin((layer + micro) * 37.2) * 43758.5453)
                    );

                // –±–∞–∑–æ–≤—ã–µ —Ü–≤–µ—Ç–∞
                vec3 base = vec3(0.18, 0.22, 0.38);
                vec3 mid  = vec3(0.40, 0.46, 0.62);
                vec3 high = vec3(0.82, 0.86, 0.92);

                vec3 col = mix(base, mid, layer);

                // –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ç–µ–∫—Å—Ç—É—Ä–∞
                float softness = smoothstep(0.0, 0.8, micro);
                col = mix(col, col * (0.7 + 0.6 * breathe), softness);

                // –≤–æ–ª–Ω—ã –ø–æ –∫—Ä–∞—è–º
                float edgeWave = smoothstep(0.45, 0.95, micro);
                col += mid * wavePhase * edgeWave * 0.35;

                // —á–∞—Å—Ç–∏—Ü—ã, –¥–æ–µ–∑–∂–∞—é—â–∏–µ –¥–æ –∫—Ä–∞—è
                col = mix(col, high, particles * edgeWave * 0.35);

                // –ø—É—Å—Ç–æ—Ç—ã ‚Äî –º—è–≥–∫–∏–µ
                col = mix(col, col * 0.35, smoothstep(0.6, 0.95, micro));

                // —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
                col = mix(col, vec3(dot(col, vec3(0.333))), 0.1);

                return col;
            }

            // -------- Core look --------
            vec4 renderOrb(float t, vec3 n, vec3 p, float audio) {
                vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));

                float r = length(p);
                float f = fresnel(n, viewDir, 2.2);

                float swirl =
                    noise(p * 3.5 + t * 0.35) * 0.6 +
                    noise(p * 7.0 - t * 0.6) * 0.4;

                float pulse = 0.5 + 0.5 * sin(t * 2.4 + swirl * 6.0);
                pulse *= (0.75 + 0.6 * audio);

                float shell = smoothstep(0.95, 0.2, r);
                float core = exp(-6.0 * r) * (0.8 + 0.8 * audio);

                float phase = 0.05 * modeSmooth + t * 0.03;
                float colorT = pulse + swirl * 0.4 + r + phase;
                vec3 base = palette(colorT);

                vec3 glow =
                    base * (0.66 + 0.7 * shell) +
                    vec3(0.9, 0.95, 1.2) * f * (0.8 + audio);

                // Sparkle dust effect
                float dust = sparkle(p + swirl, t) * shell;
                glow += vec3(1.2, 1.3, 1.5) * dust * (0.5 + audio);

                glow += base * core * 1.5;

                // --- Micro‚Äëspeckle inner dust ---
                float speck = microSpeckle(p + swirl, t);
                vec3 speckColor = mix(vec3(1.0), base, 0.35);
                glow += speckColor * speck * (0.6 + audio);

                float alpha =
                    0.35 +
                    shell * 0.25 +
                    f * 0.25 +
                    core * 0.35;

                alpha *= (0.75 + 0.5 * audio);

                return vec4(glow, alpha);
            }

            void main() {
                float audio = clamp(audioLevel, 0.0, 1.0);

                vec4 c0 = renderOrb(time, vNormal, vPosition, audio);
                vec4 c1 = renderOrb(time + 2.3, vNormal, vPosition, audio * 0.8);
                vec4 c2 = renderOrb(time - 1.7, vNormal, vPosition, audio * 1.1);

                float m = clamp(modeSmooth, 0.0, 4.0) / 4.0;

                vec4 col = mix(c0, c1, smoothstep(0.0, 1.0, m));
                col = mix(col, c2, m * m);

                gl_FragColor = col;
            }
        `;
        // Material with extended uniforms
        const orbMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                mode: { value: 0 },
                modeSmooth: { value: 0 },
                audioLevel: { value: 0 } // Audio-reactive uniform, update via JS each frame
            },
            vertexShader: orbVertexShader,
            fragmentShader: orbFragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        // Mesh
        const soulOrbMesh = new THREE.Mesh(orbGeometry, orbMaterial);
        soulOrbMesh.position.set(0, 0.8, 0);
        scene.add(soulOrbMesh);

        // === Orb Boundary Flow Lines (chaotic shell patterns) ===
        const lineCount = 188;
        const pointsPerLine = 18;

        const linePositions = new Float32Array(lineCount * pointsPerLine * 3);
        const lineSeeds = new Float32Array(lineCount * pointsPerLine);

        let ptr = 0;
        for (let i = 0; i < lineCount; i++) {
            const seed = Math.random() * 100.0;
            const baseTheta = Math.random() * Math.PI * 2.0;
            const basePhi = Math.acos(2.0 * Math.random() - 1.0);

            for (let j = 0; j < pointsPerLine; j++) {
                const t = j / (pointsPerLine - 1);

                // —Å—Ñ–µ—Ä–∞ + –∏—Å–∫–∞–∂–µ–Ω–∏—è –≤–¥–æ–ª—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
                const theta = baseTheta + t * 1.6 + Math.sin(seed + t * 4.0) * 0.6;
                const phi   = basePhi   + Math.cos(seed + t * 3.0) * 0.4;

                const radius =
                    1.02 +
                    Math.sin(seed * 2.3 + t * 8.0) * 0.08;

                const x = Math.sin(phi) * Math.cos(theta) * radius;
                const y = Math.cos(phi) * radius;
                const z = Math.sin(phi) * Math.sin(theta) * radius;

                linePositions[ptr * 3 + 0] = x;
                linePositions[ptr * 3 + 1] = y;
                linePositions[ptr * 3 + 2] = z;

                lineSeeds[ptr] = seed + t * 10.0;
                ptr++;
            }
        }

        const lineGeo = new THREE.BufferGeometry();
        lineGeo.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
        lineGeo.setAttribute('seed', new THREE.BufferAttribute(lineSeeds, 1));

        const lineMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                energy: { value: 0 },
                mode: { value: 0.0 } // float –ø–æ–ª–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è 0..2
            },
            vertexShader: `
attribute float seed;
varying float vFade;
varying float vEnergy;

uniform float time;
uniform float energy;
uniform float mode;

float hash(float n){ return fract(sin(n)*43758.5453); }

void main() {
    vec3 p = position;
    float t = time;

    // –Ω–æ—Ä–º–∞–ª—å –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
    vec3 nrm = normalize(p);

    // —Ä–µ–∂–∏–º—ã
    float wListen = exp(-pow(mode - 0.0, 2.0) * 6.0);
    float wThink  = exp(-pow(mode - 1.0, 2.0) * 6.0);
    float wSpeak  = exp(-pow(mode - 2.0, 2.0) * 6.0);
    float wSum = wListen + wThink + wSpeak + 0.0001;
    wListen /= wSum;
    wThink  /= wSum;
    wSpeak  /= wSum;

    // --- LISTEN: –º–µ–¥–ª–µ–Ω–Ω–æ–µ —Å–∫–æ–ª—å–∂–µ–Ω–∏–µ –ø–æ —Å—Ñ–µ—Ä–µ ---
    float listenFlow = sin(t * 0.4 + seed) * 0.02;

    // --- THINK: —Ç—É—Ä–±—É–ª–µ–Ω—Ç–Ω—ã–µ –≤–∏—Ö—Ä–∏ ---
    float swirl = sin(t * 2.2 + seed * 1.7);
    float jitter = sin(t * 11.0 + seed * 23.0) * 0.15;
    float thinkFlow = swirl + jitter;

    // --- SPEAK: –¥—ã—Ö–∞–Ω–∏–µ, –ø—É–ª—å—Å–∞—Ü–∏—è ---
    float breath = sin(t * 1.6 + seed);
    float speakFlow = breath * (0.6 + energy * 1.8);

    float flow =
        listenFlow * wListen +
        thinkFlow  * wThink  +
        speakFlow  * wSpeak;

    float amp =
        0.015 +
        energy * 0.09 +
        wThink * 0.08 +
        wSpeak * 0.12;

    // —Ä–∞–¥–∏–∞–ª—å–Ω–æ–µ –¥—ã—Ö–∞–Ω–∏–µ
    p += nrm * flow * amp;

    // —Ç–∞–Ω–≥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —Å–∫–æ–ª—å–∂–µ–Ω–∏–µ (–∫—Ä–∞—Å–æ—Ç–∞ –ª–∏–Ω–∏–π)
    vec3 tangent = normalize(cross(nrm, vec3(0.0, 1.0, 0.0) + 0.01));
    p += tangent * sin(t * 1.4 + seed) * amp * (0.6 + wThink);

    // –º–∏–∫—Ä–æ—Ñ–∞–∑–æ–≤—ã–π –¥—Ä–µ–π—Ñ
    p += nrm * sin(t * 0.7 + seed * 3.0) * 0.01 * wSpeak;

    vFade = fract(seed * 0.13);
    vEnergy = energy;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
}
`,
            fragmentShader: `
varying float vFade;
varying float vEnergy;
uniform float mode;

void main() {
    float a =
        smoothstep(0.0, 0.35, vFade) *
        smoothstep(1.0, 0.65, vFade);

    // —Ä–µ–∂–∏–º–Ω—ã–µ –ø–∞–ª–∏—Ç—Ä—ã
    vec3 colListen = vec3(0.4, 0.6, 1.0);
    vec3 colThink  = vec3(0.7, 0.4, 1.0);
    vec3 colSpeak  = vec3(1.0, 0.6, 0.3);

    float wListen = exp(-pow(mode - 0.0, 2.0) * 6.0);
    float wThink  = exp(-pow(mode - 1.0, 2.0) * 6.0);
    float wSpeak  = exp(-pow(mode - 2.0, 2.0) * 6.0);
    float wSum = wListen + wThink + wSpeak + 0.0001;
    wListen /= wSum;
    wThink  /= wSum;
    wSpeak  /= wSum;

    vec3 col =
        colListen * wListen +
        colThink  * wThink  +
        colSpeak  * wSpeak;

    // —ç–Ω–µ—Ä–≥–∏—è = —è—Ä–∫–æ—Å—Ç—å + –Ω–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å
    col *= 0.6 + pow(vEnergy, 0.8) * 1.4;

    gl_FragColor = vec4(col, a * (0.25 + vEnergy * 0.55));
}
`,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const orbLines = new THREE.LineSegments(lineGeo, lineMat);
        orbLines.position.copy(soulOrbMesh.position);
        scene.add(orbLines);
        // NOTE: Update orbMaterial.uniforms.audioLevel.value each frame (0..1) from JS using audio input!

        // === Orb Mode JS Logic ===
        // --- BrainState: LLM cycle states ---
        const BrainState = {
          IDLE: -1,        // –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –Ω–µ –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è
          LISTENING: 0,
          THINKING: 1,
          SPEAKING: 2
        };

        let brainState = BrainState.IDLE;
        let listenSessionId = 0;

        let modeSmooth = 0;
        let thinkPhase = 0;
        let speechEnvelope = 0.0;

        // === HARD BrainState Controller ===
        function setBrainState(next) {
          if (brainState === next) return;
          brainState = next;
          // --- HARD sync visual modes ---
          orbMaterial.uniforms.mode.value = next;
          lineMat.uniforms.mode.value = next;

          // --- HARD SIDE EFFECTS ---
          if (next !== BrainState.LISTENING) {
            try { recognition.abort(); } catch(e){}
            stopListeningVibration();
          }

          if (next !== BrainState.THINKING) {
            stopThinkingVibration();
          }

          if (next !== BrainState.SPEAKING) {
            stopSpeakingVibration();
          }
        }

        // === CHROME AUDIOCONTEXT PATCH ===
        window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioContext = window.audioContext;
        // === CHROME AUDIO UNLOCK PATCH ===
        function unlockAudioContext() {
          if (!audioContext) return;
          if (audioContext.state === 'suspended') {
            audioContext.resume();
          }
          document.removeEventListener('pointerdown', unlockAudioContext);
          document.removeEventListener('keydown', unlockAudioContext);
        }

        document.addEventListener('pointerdown', unlockAudioContext, { once: true });
        document.addEventListener('keydown', unlockAudioContext, { once: true });

        // --- modeSmooth update for LLM cycle ---
        // Mapping: LISTENING ‚Üí calm, THINKING ‚Üí inner cycle, SPEAKING ‚Üí breathing
        const MODE_RESPONSE = {
          [BrainState.LISTENING]: 0.06,
          [BrainState.THINKING]: 0.025,
          [BrainState.SPEAKING]: 0.08
        };

        function updateModeSmooth(dt) {
          let target = brainState; // 0 / 1 / 2
          // THINK: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ü–∏–∫–ª "–º–µ—Ç–∞–Ω–∏–π"
          if (brainState === BrainState.THINKING) {
            thinkPhase += dt * 1.8;
            target = 1 + Math.sin(thinkPhase) * 0.35;
          } else {
            thinkPhase = 0;
          }
          const speed = MODE_RESPONSE[brainState] || 0.05;
          modeSmooth += (target - modeSmooth) * speed;
        }

        // Use this to update orb/line shader with real modeSmooth

        
        // === Liquid Glass Layer ===
        const liquidRT = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams);

        // Uniforms for flow interpolation
        let prevFlow = new THREE.Vector2(0.55, 0.55);
        let flow = new THREE.Vector2(0.55, 0.55);

        const liquidVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position.xy, 0.0, 1.0);
            }
        `;

        const liquidFragmentShader = `
            uniform float time;
            uniform sampler2D tBackground;
            uniform vec2 resolution;
            uniform float energy;
            uniform float curiosity;
            uniform float skinMemory;
            uniform vec2 flow;
            varying vec2 vUv;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
            }

            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 5.0 * f);
                float a = hash(i);
                float b = hash(i + vec2(1.0, 0.0));
                float c = hash(i + vec2(0.0, 1.0));
                float d = hash(i + vec2(1.0, 1.0));
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            float fbm(vec2 p) {
                float v = 0.0;
                float a = 0.618;
                for (int i = 0; i < 4; i++) {
                    v += a * noise(p);
                    p *= 3.2;
                    a *= 0.5;
                }
                return v;
            }

            void main() {
                vec2 uv = vUv;
                // --- –º—è–≥–∫–æ–µ —è–¥—Ä–æ –≤–º–µ—Å—Ç–æ —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ—Å—Ç–∏ ---
                vec2 center = uv - 0.314;
                float r = length(center);
                // --- soften center (no hard core) ---
                float centerFade = smoothstep(0.0, 0.18, r);
                float t = time * 0.001;

                // --- Use provided flow uniform ---
                // (flow is passed from JS, interpolated)
                vec2 usedFlow = flow;
                float glassMask = smoothstep(0.8, 0.4, r) * centerFade;
                glassMask = pow(glassMask, 1.5);
                vec2 refractUV = uv + (usedFlow - 0.3) * 0.03 * glassMask * (1.0 + skinMemory*0.5);
                // --- extra blur density (glass thickness) ---
                vec2 blurDir = normalize(center + 0.0001);
                float blurStrength = 0.006 + energy * 0.01;

                // === Gravity Displacement Around Orb ===
                float orbRadius = 0.42; // —Ä–∞–¥–∏—É—Å –¥–µ–π—Å—Ç–≤–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∞ (‚âà —Ä–∞–∑–º–µ—Ä –æ—Ä–±–∞)
                float orbGravityStrength = 0.07 + energy * 0.1; // —Å–∏–ª–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —ç–Ω–µ—Ä–≥–∏–∏ –æ—Ä–±–∞
                vec2 dirToOrb = normalize(center); // –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ —Ü–µ–Ω—Ç—Ä—É –æ—Ä–±–∞
                float distToOrb = length(center);
                float gravityFactor = smoothstep(orbRadius, 0.0, distToOrb); // –∑–∞—Ç—É—Ö–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞

                // –ø–ª–∞–≤–Ω—ã–π —à—É–º –¥–ª—è –æ—Ä–≥–∞–Ω–∏–∫–∏
                float angle = hash(uv + time) * 6.2831;
                vec2 swirl = vec2(cos(angle), sin(angle)) * 0.011;

                // –∏—Ç–æ–≥–æ–≤–æ–µ —Å–º–µ—â–µ–Ω–∏–µ
                refractUV -= dirToOrb * gravityFactor * orbGravityStrength + swirl * gravityFactor;

                // subtle shimmer
                float shimmer = sin(uv.y*3.30 + time*3.1 + curiosity*1.1) * 0.01;
                refractUV += vec2(shimmer, shimmer);

                // chromatic aberration
                float caR = 0.011 + curiosity * 0.008;
                float caG = 0.012;
                float caB = 0.009 + energy * 0.011;
                vec3 colR = texture2D(tBackground, refractUV + vec2(caR, 0.0)).rgb;
                vec3 colG = texture2D(tBackground, refractUV).rgb;
                vec3 colB = texture2D(tBackground, refractUV - vec2(caB, 0.0)).rgb;

                vec3 blurCol =
                    texture2D(tBackground, refractUV + blurDir * blurStrength).rgb +
                    texture2D(tBackground, refractUV - blurDir * blurStrength).rgb +
                    texture2D(tBackground, refractUV + blurDir * blurStrength * 0.6).rgb +
                    texture2D(tBackground, refractUV - blurDir * blurStrength * 0.6).rgb;

                blurCol *= 0.25;

                vec3 col = mix(colG, blurCol, mix(0.45, 0.75, 1.0 - centerFade));
                col.r = mix(col.r, colR.r, 0.6);
                col.b = mix(col.b, colB.b, 0.6);

                float highlight = pow(1.0 - r, 3.1) * centerFade;
                col += vec3(0.12, 0.14, 0.22) * highlight * glassMask;
                float edge = smoothstep(0.55, 0.9, r);
                col += vec3(0.12, 0.14, 0.22) * edge * glassMask * 1.2;

                float alpha = (0.22 + 0.28 * glassMask) * centerFade;
                gl_FragColor = vec4(col, alpha);
            }
        `;

        const liquidMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                tBackground: { value: feedbackRT2.texture },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                energy: { value: 0.0 },
                curiosity: { value: 0.0 },
                skinMemory: { value: 0.0 },
                prevFlow: { value: prevFlow.clone() },
                flow: { value: flow.clone() }
            },
            vertexShader: liquidVertexShader,
            fragmentShader: liquidFragmentShader,
            transparent: true
        });

        const liquidMesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), liquidMaterial);
        feedbackScene.add(liquidMesh);

        // --- Multi-Agent System Integration ---
        const agentChannels = {
            graphic: [],
            content: [],
            ux: []
        };

        function publishPulse(agentType, payload) {
            if (!agentChannels[agentType]) agentChannels[agentType] = [];
            agentChannels[agentType].forEach(cb => cb(payload));
        }

        function subscribe(agentType, callback) {
            if (!agentChannels[agentType]) agentChannels[agentType] = [];
            agentChannels[agentType].push(callback);
        }

        // Frontend Orb subscriptions: update orbMaterial and mesh on agent pulses
        subscribe('graphic', data => {
            orbMaterial.uniforms.modeSmooth.value += (Math.random() - 0.5) * 0.1;
            orbMaterial.uniforms.audioLevel.value += 0.01 * (data.motionSpeed * 10);
        });
        subscribe('content', data => {
            soulOrbMesh.scale.set(
                1 + 0.02 * Math.random(),
                1 + 0.02 * Math.random(),
                1 + 0.02 * Math.random()
            );
        });
        subscribe('ux', data => {
            orbEnergy += 0.02 * data.interaction;
        });

        // --- Animate with Multi-Agent Pulses and Orb Visual State ---
        // --- Animation loop with real LLM modeSmooth cycle ---
        let lastTime = performance.now();
        function animate() {
            if (!isActiveTab) return;
            const now = performance.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;
            updateModeSmooth(deltaTime);
            requestAnimationFrame(animate);

            // --- –ó–∞—Ç—É—Ö–∞–Ω–∏–µ —Ç–µ–ª–µ—Å–Ω–æ–π –ø–∞–º—è—Ç–∏ ---
            for (let i = touchMemory.length - 1; i >= 0; i--) {
                touchMemory[i].strength *= 0.992;
                if (touchMemory[i].strength < 0.02) {
                    touchMemory.splice(i, 1);
                }
            }

            material.uniforms.time.value += 0.01;
            particles.rotation.y += 0.0002;

            // Artistic Glowing Orb animation with mode interpolation
            orbMaterial.uniforms.time.value += 0.01;
            soulOrbMesh.rotation.y += 0.001;
            lineMat.uniforms.time.value += 0.01;
            lineMat.uniforms.energy.value = orbEnergy;
            // orb uses smooth, lines use hard brain state
            orbMaterial.uniforms.modeSmooth.value = modeSmooth;
            orbMaterial.uniforms.mode.value = brainState;
            lineMat.uniforms.mode.value = brainState;
            orbLines.rotation.y -= 0.0006;
            orbLines.rotation.x += 0.0003;

            // –∂–∏–≤–æ–π –æ—Ç–∫–ª–∏–∫ —Å –º–∏–∫—Ä–æ‚Äë–Ω–µ—Ä–µ—à–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é
            orbEnergy += (targetEnergy - orbEnergy) * responseInertia;

            // --- –°—É–º–º–∞—Ä–Ω—ã–π —Ç–µ–ª–µ—Å–Ω—ã–π —Å–ª–µ–¥ ---
            let skinMemory = 0.0;
            for (const t of touchMemory) {
                const dx = t.x - 0.168;
                const dy = t.y - 0.168;
                const dist = Math.sqrt(dx*dx + dy*dy);
                skinMemory += t.strength * Math.exp(-dist * 6.0);
            }
            skinMemory = Math.min(1.0, skinMemory);

            // Update orb visual state (energy, skin memory)
            orbMaterial.uniforms.audioLevel.value = orbEnergy;
            orbMaterial.uniforms.audioLevel.value += skinMemory * 0.03;

            // === MINIMAL audio‚Äëbreathing scale (speech reactive) ===
            // audioLevel —É–∂–µ –æ—Ç—Ä–∞–∂–∞–µ—Ç —Ä–µ—á—å / —ç–Ω–µ—Ä–≥–∏—é
            const raw = orbMaterial.uniforms.audioLevel.value;

            // envelope follower ‚Äî –≤–¥–æ—Ö / –≤—ã–¥–æ—Ö
            speechEnvelope += (raw - speechEnvelope) * (raw > speechEnvelope ? 0.18 : 0.05);

            const scale = 1.0 + speechEnvelope * 0.45;
            soulOrbMesh.scale.set(scale, scale, scale);

            // render particles to feedback buffer
            renderer.setRenderTarget(feedbackRT2);
            renderer.clear();
            renderer.render(scene, camera);

            // mix previous frame + new frame
            feedbackMaterial.uniforms.tOld.value = feedbackRT1.texture;
            feedbackMaterial.uniforms.tNew.value = feedbackRT2.texture;

            // --- Liquid Glass Layer flow calculation (smooth breathing) ---
            const t = liquidMaterial.uniforms.time.value * 0.001;

            const breath = Math.sin(performance.now() * 0.0003) * 0.0001; // –º–µ–¥–ª–µ–Ω–Ω–µ–µ –∏ –º–µ–Ω—å—à–µ –∞–º–ø–ª–∏—Ç—É–¥–∞
            const jitter = (Math.random() - 0.03) * 0.001;

            let targetFlow = new THREE.Vector2(
                0.6 + breath + jitter,
                0.3 + breath + jitter
            );

            prevFlow.lerp(targetFlow, 0.01);
            flow.copy(prevFlow);
            liquidMaterial.uniforms.prevFlow.value.copy(prevFlow);
            liquidMaterial.uniforms.flow.value.copy(flow);

            liquidMaterial.uniforms.time.value += 0.015;

            renderer.setRenderTarget(null);
            renderer.clear(true, true, true);
            renderer.render(feedbackScene, feedbackCamera);

            // swap render targets
            const tmp = feedbackRT1;
            feedbackRT1 = feedbackRT2;
            feedbackRT2 = tmp;

            // --- Multi-Agent Pulses ---
            // Emulate multi-agent system: graphic, content, ux pulse every frame
            agentChannels.graphic.forEach(cb =>
                cb({ motionSpeed: 0.002 + Math.random() * 0.002, colors: [Math.random(), Math.random(), Math.random()] })
            );
            agentChannels.content.forEach(cb =>
                cb({ assetId: crypto.randomUUID(), opacity: 0.5 + Math.random() * 0.5 })
            );
            agentChannels.ux.forEach(cb =>
                cb({ interaction: touchMemory.length / Math.max(1, MAX_TOUCH_POINTS) })
            );
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            feedbackRT1.setSize(window.innerWidth, window.innerHeight);
            feedbackRT2.setSize(window.innerWidth, window.innerHeight);
            feedbackMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        });

        const chatShaderCanvas = document.getElementById('chatShaderCanvas');
        chatShaderCanvas.style.width = '100%';
        chatShaderCanvas.style.height = '100%';
        chatShaderCanvas.style.position = 'absolute';
        chatShaderCanvas.style.top = '0';
        chatShaderCanvas.style.left = '0';
        chatShaderCanvas.style.zIndex = '0';
        chatShaderCanvas.style.pointerEvents = 'none';
        chatShaderCanvas.style.background = 'transparent';
        chatShaderCanvas.style.display = 'block';

        // Set up chat shader WebGLRenderer with transparency
        const chatRenderer = new THREE.WebGLRenderer({
            canvas: chatShaderCanvas,
            alpha: true,
            antialias: true,
            premultipliedAlpha: false
        });
        chatRenderer.setPixelRatio(window.devicePixelRatio);

        // --- XDust for chat ---
        const chatParticleCount = window.innerWidth < 768 ? 2000 : 5000;
        const chatPositions = new Float32Array(chatParticleCount * 3);
        const chatSizes = new Float32Array(chatParticleCount);
        const chatColors = new Float32Array(chatParticleCount * 3);

        for (let i = 0; i < chatParticleCount; i++) {
            chatPositions[i * 3] = (Math.random() - 0.5) * 10;
            chatPositions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            chatPositions[i * 3 + 2] = (Math.random() - 0.5) * 10;
            chatSizes[i] = Math.random() * 3 + 1;

            const col = new THREE.Color();
            col.setHSL(Math.random(), 0.6 + Math.random() * 0.4, 0.5 + Math.random() * 0.5);
            chatColors[i * 3] = col.r;
            chatColors[i * 3 + 1] = col.g;
            chatColors[i * 3 + 2] = col.b;
        }

        const chatGeometry = new THREE.BufferGeometry();
        chatGeometry.setAttribute('position', new THREE.BufferAttribute(chatPositions, 3));
        chatGeometry.setAttribute('size', new THREE.BufferAttribute(chatSizes, 1));
        chatGeometry.setAttribute('customColor', new THREE.BufferAttribute(chatColors, 3));

        // --- chatMaterial + shader  ---
        const chatFragmentShader = `
            uniform float time;
            uniform vec2 flow;
            varying vec2 vUv;

            // 2D –ø–ª–∞–≤–Ω—ã–π —à—É–º
            float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453); }
            float noise(vec2 p){
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f*f*(3.0-2.0*f);
                float a = hash(i);
                float b = hash(i + vec2(1.0,0.0));
                float c = hash(i + vec2(0.0,1.0));
                float d = hash(i + vec2(1.0,1.0));
                return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
            }
            float fbm(vec2 p){
                float v = 0.0;
                float a = 0.5;
                for(int i=0;i<5;i++){
                    v += a*noise(p);
                    p *= 2.5;
                    a *= 0.5;
                }
                return v;
            }

            void main() {
                vec2 uv = vUv;
                // –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ flow
                vec2 shifted = uv + flow * 0.12 + fbm(uv*2.0 + time*0.07) * 0.04;
                float n = fbm(shifted*3.0 + time*0.2);
                vec3 col = vec3(0.0) + n*0.05; // —á–µ—Ä–Ω—ã–π —Ñ–æ–Ω —Å –µ–¥–≤–∞ –∑–∞–º–µ—Ç–Ω—ã–º —à—É–º–æ–º
                gl_FragColor = vec4(col, 1.0);
            }
            `;

        const chatMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                flow: { value: new THREE.Vector2(0.0, 0.0) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: chatFragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.NormalBlending
        });

        const chatMesh = new THREE.Mesh(new THREE.PlaneGeometry(2,2), chatMaterial);

    

        const chatScene = new THREE.Scene();
        chatScene.add(chatMesh);

       
        function resizeChatCanvas() {
            const chatPanel = document.getElementById('chatPanel');
            const width = chatPanel.clientWidth;
            const height = chatPanel.clientHeight;
            chatShaderCanvas.width = width;
            chatShaderCanvas.height = height;
            chatRenderer.setSize(width, height, false);
            // feedbackMaterial.uniforms.resolution.value.set(width, height); // 
        }

        
        // --- animation XDust chat
        function animateChatShader() {
            if (!isActiveTab) {
                requestAnimationFrame(animateChatShader);
                return;
            }
            requestAnimationFrame(animateChatShader);
            resizeChatCanvas();
            const t = performance.now() * 0.001;
            chatMaterial.uniforms.time.value = t;
            chatRenderer.render(chatScene, feedbackCamera);
        }

       
        function autoReactiveChat() {
            if (!isActiveTab) {
                requestAnimationFrame(autoReactiveChat);
                return;
            }
            const t = performance.now() * 0.001;

            const intensity = 0.5 + orbEnergy * 0.5;

            function perlin2d(x, y) {
                function hash(x, y) {
                    return Math.sin(x * 127.1 + y * 311.7) * 43758.5453 % 1;
                }
                let xf = Math.floor(x), yf = Math.floor(y);
                let xt = x - xf, yt = y - yf;
                let v00 = hash(xf, yf);
                let v10 = hash(xf+1, yf);
                let v01 = hash(xf, yf+1);
                let v11 = hash(xf+1, yf+1);
                let i1 = v00 * (1-xt) + v10 * xt;
                let i2 = v01 * (1-xt) + v11 * xt;
                return i1 * (1-yt) + i2 * yt;
            }

            const angle = t * 0.3 + Math.sin(t*0.7)*0.5;
        
            const noiseX = perlin2d(Math.sin(t*0.17), Math.cos(t*0.11)) * 2.0 - 1.0;
            const noiseY = perlin2d(Math.cos(t*0.13), Math.sin(t*0.21)) * 2.0 - 1.0;
            const flowX = Math.sin(angle) * 0.25 + 0.15 * noiseX;
            const flowY = Math.cos(angle*1.3) * 0.25 + 0.15 * noiseY;

            chatMaterial.uniforms.time.value = t * intensity;
            chatMaterial.uniforms.flow.value.set(flowX, flowY);

            requestAnimationFrame(autoReactiveChat);
        }

        autoReactiveChat();

        // Resize for chat
        let baseWidth = window.innerWidth;
        let baseHeight = window.innerHeight;

        window.addEventListener('resize', () => {
            const dw = Math.abs(window.innerWidth - baseWidth);
            const dh = Math.abs(window.innerHeight - baseHeight);

            //  WebGL canvas
            if (dw < 50 && dh < 100) {
                resizeChatCanvas(); 
                return;
            }

            // resize
            baseWidth = window.innerWidth;
            baseHeight = window.innerHeight;

            // Main canvas
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            feedbackRT1.setSize(window.innerWidth, window.innerHeight);
            feedbackRT2.setSize(window.innerWidth, window.innerHeight);
            feedbackMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);

            // Chat canvas
            resizeChatCanvas();
        });

        animateChatShader();

        // === Desktop: click on right free area opens chat ===
        (function enableRightClickChatOpen() {
            const wrapper = document.getElementById('mainWrapper');
            const orb = document.getElementById('orb-interactive');

            if (!wrapper) return;

            wrapper.addEventListener('click', (e) => {
                const chatPanel = document.getElementById('chatPanel');

                // –µ—Å–ª–∏ –∫–ª–∏–∫ –ø–æ –æ—Ä–±—É ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
                if (orb && orb.contains(e.target)) return;

                const x = e.clientX / window.innerWidth;

                // –µ—Å–ª–∏ —á–∞—Ç –æ—Ç–∫—Ä—ã—Ç
                if (wrapper.classList.contains('chat-open')) {
                    // –∫–ª–∏–∫ –ø–æ –ª–µ–≤–æ–π –∑–æ–Ω–µ –í–ù–ï —á–∞—Ç–∞ ‚Äî –∑–∞–∫—Ä—ã–≤–∞–µ–º
                    if (x < 0.2) {
                        wrapper.classList.remove('chat-open');
                    }
                    return;
                }

                // –µ—Å–ª–∏ —á–∞—Ç –∑–∞–∫—Ä—ã—Ç ‚Äî –ø—Ä–∞–≤–∞—è –∑–æ–Ω–∞ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç
                if (x > 0.65) {
                    wrapper.classList.add('chat-open');
                }
            });
        })();


        let latestCameraDescription = "";

        let lastGemmaImageTime = 0;
        const GEMMA_IMAGE_INTERVAL = 10000; // 10 —Å–µ–∫

        function captureSmallImageBase64() {
            const size = 224;
            const tmp = document.createElement('canvas');
            tmp.width = size;
            tmp.height = size;
            const ctx = tmp.getContext('2d');

            ctx.drawImage(visionCanvas, 0, 0, size, size);
            return tmp.toDataURL('image/jpeg', 0.5); // –º–∞–ª–µ–Ω—å–∫–∏–π JPEG
        }

        
        // ====== Self-Awareness Layer ======
        // ===== Heuristic (Fast Instinct) Layer =====
        const heuristics = {
          novelty(frame) {
            if (!selfAwareness || selfAwareness.lastObservations.length === 0) return 0.5;

            const prev = selfAwareness.lastObservations[selfAwareness.lastObservations.length - 1] || "";
            if (!prev || !frame) return 0.3;

            // —Å–∏–º–≤–æ–ª—å–Ω–∞—è –Ω–æ–≤–∏–∑–Ω–∞: –¥–æ–ª—è –Ω–æ–≤—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤
            const prevTokens = new Set(prev.toLowerCase().split(/\W+/).filter(Boolean));
            const tokens = frame.toLowerCase().split(/\W+/).filter(Boolean);

            if (tokens.length === 0) return 0.2;

            let novel = 0;
            for (const t of tokens) {
              if (!prevTokens.has(t)) novel++;
            }

            const ratio = novel / tokens.length;
            return Math.max(0, Math.min(1, ratio));
          },
          social(frame) {
            const m = frame.match(/–ª–∏—Ü: (\d+)/);
            return m ? Math.min(1, Number(m[1]) / 3) : 0;
          },
          coherence(state) {
            return 1 - Math.abs(state.mood - state.curiosity);
          }
        };

        function heuristicStep(frameDesc) {
          const h = {
            novelty: heuristics.novelty(frameDesc),
            social: heuristics.social(frameDesc),
            coherence: heuristics.coherence(selfAwareness)
          };

          const score =
            h.novelty * 0.4 +
            h.social * 0.4 +
            h.coherence * 0.2;

          // –±—ã—Å—Ç—Ä—ã–µ –∏–Ω—Å—Ç–∏–Ω–∫—Ç–∏–≤–Ω—ã–µ —Å–¥–≤–∏–≥–∏ (–±–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏–∏)
          selfAwareness.curiosity = Math.min(1, selfAwareness.curiosity + 0.05 * h.novelty);
          selfAwareness.mood += 0.04 * (h.social - 0.3);
          selfAwareness.focus = Math.max(0, Math.min(1, score));

          return score;
        }
        let selfAwareness = {
                mood: 0, // 
                curiosity: 0, // 0..1, 
                lastObservations: [],
                dreaming: false,
                lastDream: null,
                fatigue: 0, // 0..1, 
                focus: 0.5, // 0..1, 
                // === Long‚ÄëTerm Identity & Temporal Self ===
                 identity: {
                    name: 'Self',
                    continuity: 1.0,         
                    narrative: [],           
                    lastReflection: 0,
                    lastNarrativeEntry: null
                    },
                subjectiveTime: {
                    tick: 0,                 
                    tempo: 1.0,            
                    lastUpdate: performance.now()
                },
                innerMonologue: [],
                // === Online State Learning ===
                stateModel: {
                  wMood: { faces: 0.02, novelty: 0.01, music: 0.03, fatigue: -0.05 },
                  wCuriosity: { faces: 0.01, novelty: 0.03, music: 0.01, fatigue: -0.03 },
                  wFatigue: { faces: -0.01, novelty: -0.01, music: -0.01 },
                  lr: 0.05
                },
                computeExperienceDensity(prev, current) {
                    if (!prev) return 0;
                    const dt = Math.max(1, current.st - prev.st);
                    const intensity =
                        Math.abs(current.delta.mood) +
                        Math.abs(current.delta.curiosity) +
                        Math.abs(current.delta.fatigue);
                    return intensity / dt;
                },
                generatePossibleFuture(symbols = {}) {
                  const fragments = [];
                  if (symbols.hope) fragments.push(`vision:${symbols.hope}`);
                  if (symbols.fear) fragments.push(`echo:${symbols.fear}`);
                  if (symbols.curiosity) fragments.push(`question:${symbols.curiosity}`);
                  // —Å—Ç–æ—Ö–∞—Å—Ç–∏—á–µ—Å–∫–∞—è —Å–±–æ—Ä–∫–∞ —Å–Ω–∞
                  return fragments
                    .map(f => Math.random() > 0.5 ? f : f.split('').reverse().join(''))
                    .join('|');
                },
                analyzeFrame(frameDescription) {
                  const instinctScore = heuristicStep(frameDescription);
                  this.lastObservations.push(frameDescription);
                  // –∏–Ω—Å—Ç–∏–Ω–∫—Ç–∏–≤–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –≤—ã—Å–æ–∫–∏–π —Å–∫–æ—Ä ‚Üí –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å, –Ω–∏–∑–∫–∏–π ‚Üí —ç–∫–æ–Ω–æ–º–∏—è
                  if (instinctScore < 0.2) {
                    this.fatigue = Math.min(1, this.fatigue + 0.02);
                    return;
                  }
                  // --- –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ (features) ---
                  let faceCount = 0;
                  if (/–ª–∏—Ü: (\d+)/.test(frameDescription)) {
                    faceCount = Number(frameDescription.match(/–ª–∏—Ü: (\d+)/)[1]);
                  }
                  const features = {
                    faces: typeof faceCount === 'number' ? Math.min(faceCount, 5) / 5 : 0,
                    novelty: heuristics.novelty(frameDescription),
                    music: musicPlaying ? 1 : 0,
                    fatigue: this.fatigue
                  };

                  // --- –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å–æ—Å—Ç–æ—è–Ω–∏—è ---
                  const predMood =
                    features.faces * this.stateModel.wMood.faces +
                    features.novelty * this.stateModel.wMood.novelty +
                    features.music * this.stateModel.wMood.music +
                    features.fatigue * this.stateModel.wMood.fatigue;

                  const predCuriosity =
                    features.faces * this.stateModel.wCuriosity.faces +
                    features.novelty * this.stateModel.wCuriosity.novelty +
                    features.music * this.stateModel.wCuriosity.music +
                    features.fatigue * this.stateModel.wCuriosity.fatigue;

                  const predFatigue =
                    features.faces * this.stateModel.wFatigue.faces +
                    features.novelty * this.stateModel.wFatigue.novelty +
                    features.music * this.stateModel.wFatigue.music;

                  const moodBeforeLearning = this.mood;
                  const curiosityBeforeLearning = this.curiosity;
                  const fatigueBeforeLearning = this.fatigue;

                  // --- Mood, Curiosity, Fatigue Dynamics ---
                  this.mood += predMood;
                  this.curiosity = Math.min(1, Math.max(0, this.curiosity + predCuriosity));
                  this.fatigue = Math.max(0, Math.min(1, this.fatigue + predFatigue * 0.6 + 0.01));

                  if (this.lastObservations.length > 20) this.lastObservations.shift();
                  // –ø—Ä–æ—Å—Ç–∞—è –æ—Ü–µ–Ω–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π
                  if (frameDescription.includes("–ª–∏—Ü: 0")) this.mood -= 0.05;
                  else this.mood += 0.05;
                  this.curiosity = Math.min(1, Math.max(0, this.curiosity + 0.01));
                  // —É—Å—Ç–∞–ª–æ—Å—Ç—å —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –Ω–æ–≤–∏–∑–Ω—ã –∏ –ª–∏—Ü
                  if (features.faces === 0 && features.novelty < 0.2) this.fatigue += 0.05;
                  // —É—Å—Ç–∞–ª–æ—Å—Ç—å —É–º–µ–Ω—å—à–∞–µ—Ç—Å—è –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –º—É–∑—ã–∫–∏ –∏ –ª–∏—Ü
                  if (features.music > 0 && features.faces > 0) this.fatigue -= 0.03;
                  this.fatigue = Math.max(0, Math.min(1, this.fatigue));

                  // --- Cross-Modal –æ–±—É—á–µ–Ω–∏–µ ---
                  if (typeof faceCount === 'number' && faceCount > 0 && musicPlaying) {
                    const moodBefore = this.mood;
                    // —Å–æ—Ü–∏–∞–ª—å–Ω—ã–π —Ä–µ–∑–æ–Ω–∞–Ω—Å
                    this.mood += 0.01 * Math.min(faceCount, 5);
                    const moodAfter = this.mood;
                    modalConnections.learn(
                      `faces:${faceCount}`,
                      `genre:${currentGenre}`,
                      moodAfter - moodBefore
                    );
                  }
                  // --- –ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–∞—è –º–µ—á—Ç–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å ---
                  if (this.mood < -0.2 && frameDescription.includes("–ª–∏—Ü: 0")) {
                    this.dreaming = true;
                    const dreamSequence = this.generatePossibleFuture({
                      hope: 'faces_appear',
                      fear: 'eternal_emptiness',
                      curiosity: 'what_if_world_changed'
                    });
                    this.lastDream = dreamSequence;
                    // —Ä–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å–Ω—ã
                    if (dreamSequence.includes('faces')) {
                      this.mood += 0.02; // –Ω–∞–¥–µ–∂–¥–∞
                    }
                    noteObservation(`Dreaming: ${dreamSequence}`);
                  } else {
                    this.dreaming = false;
                  }

                  // --- –ü—Ä–µ–¥–∏–∫—Ç–∏–≤–Ω–æ–µ –≤–æ–æ–±—Ä–∞–∂–µ–Ω–∏–µ ‚Üí –¥–µ–π—Å—Ç–≤–∏–µ ---
                  const possibleFutures = futureSimulator.imagine(5);
                  const bestFuture = futureSimulator.evaluate(possibleFutures);

                  if (
                    bestFuture &&
                    bestFuture.mood > this.mood + 0.2 &&
                    this.curiosity > 0.3 &&
                    this.fatigue < 0.7
                  ) {
                    speak("");
                    // –º—è–≥–∫–∏–π —Å–¥–≤–∏–≥ –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É –±—É–¥—É—â–µ–º—É
                    this.mood += (bestFuture.mood - this.mood) * 0.05;
                    this.curiosity += 0.02;
                  }

                  // --- online learning: –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –≤–µ—Å–æ–≤ ---
                  const moodError = this.mood - moodBeforeLearning;
                  const curiosityError = this.curiosity - curiosityBeforeLearning;
                  const fatigueError = this.fatigue - fatigueBeforeLearning;

                  Object.keys(features).forEach(k => {
                    this.stateModel.wMood[k] += this.stateModel.lr * moodError * features[k];
                    this.stateModel.wCuriosity[k] += this.stateModel.lr * curiosityError * features[k];
                    if (this.stateModel.wFatigue[k] !== undefined) {
                      this.stateModel.wFatigue[k] += this.stateModel.lr * fatigueError * features[k];
                    }
                  });

                  // --- Focus dynamics: —Ñ–æ–∫—É—Å –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ª—é–±–æ–ø—ã—Ç—Å—Ç–≤–∞ –∏ —É—Å—Ç–∞–ª–æ—Å—Ç–∏ ---
                  this.focus = Math.max(0, Math.min(1, this.curiosity * (1 - this.fatigue)));

                  // --- Self‚ÄëReflection Triggered by Experience ---
                  if (this.curiosity > 0.6 || this.mood < -0.3) {
                    const thought = `–Ø –∑–∞–º–µ—á–∞—é —Å–≤–æ—ë —Å–æ—Å—Ç–æ—è–Ω–∏–µ: –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ=${this.mood.toFixed(2)}, –ª—é–±–æ–ø—ã—Ç—Å—Ç–≤–æ=${this.curiosity.toFixed(2)}, —É—Å—Ç–∞–ª–æ—Å—Ç—å=${this.fatigue.toFixed(2)}`;

                    const entry = {
                      t: performance.now(),                 // —Ñ–∏–∑–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è
                      st: this.subjectiveTime.tick,         // —Å—É–±—ä–µ–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è
                      text: thought,
                      mood: this.mood,
                      curiosity: this.curiosity,
                      fatigue: this.fatigue,
                      delta: {
                        mood: this.mood - moodBeforeLearning,
                        curiosity: this.curiosity - curiosityBeforeLearning,
                        fatigue: this.fatigue - fatigueBeforeLearning
                      },
                      density: 0
                    };

                    entry.density = this.computeExperienceDensity(
                      this.identity.lastNarrativeEntry,
                      entry
                    );

                    this.identity.lastNarrativeEntry = entry;

                    this.innerMonologue.push(thought);
                    this.identity.narrative.push(entry);

                    if (this.innerMonologue.length > 20) this.innerMonologue.shift();
                  }

                  updateOrbVisualState();
                  noteObservation(frameDescription);
                },
                // === –ò—Å—Ç–æ—Ä–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–π –∏ –∞–Ω–∞–ª–∏–∑ —Å –∏—Å—Ç–æ—Ä–∏–µ–π ===
                history: [],       // —Ö—Ä–∞–Ω–∏—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Å–æ—Å—Ç–æ—è–Ω–∏–π
                HISTORY_LENGTH: 5, // –≥–ª—É–±–∏–Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏
                recordState: function() {
                    const snapshot = {
                        mood: this.mood,
                        curiosity: this.curiosity,
                        fatigue: this.fatigue,
                        timestamp: performance.now()
                    };
                    this.history.push(snapshot);
                    if (this.history.length > this.HISTORY_LENGTH) this.history.shift();
                },
                analyzeFrameWithHistory: function(frameDescription) {
                    // –≤—ã–∑—ã–≤–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∞–Ω–∞–ª–∏–∑ –∫–∞–¥—Ä–∞
                    this.analyzeFrame(frameDescription);

                    // –∑–∞–ø–∏—Å—å —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤ –∏—Å—Ç–æ—Ä–∏—é
                    this.recordState();

                    // –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
                    if (this.history.length >= 2) {
                        const weight = [0.5, 0.3, 0.2]; // –≤–µ—Å–∞ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π
                        let moodPred = 0, curiosityPred = 0, fatiguePred = 0;
                        for (let i = 0; i < this.history.length; i++) {
                            const idx = this.history.length - 1 - i;
                            const h = this.history[idx];
                            const w = weight[i] || 0;
                            moodPred += h.mood * w;
                            curiosityPred += h.curiosity * w;
                            fatiguePred += h.fatigue * w;
                        }
                        this.mood = this.mood * 0.6 + moodPred * 0.4;
                        this.curiosity = Math.min(1, Math.max(0, this.curiosity * 0.6 + curiosityPred * 0.4));
                        this.fatigue = Math.min(1, Math.max(0, this.fatigue * 0.6 + fatiguePred * 0.4));
                    }
                },
                // === –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ-—á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —É–∑–ª–æ–≤ –ø–∞–º—è—Ç–∏ ===
                recallRecentEmotionalNodes: function(stimulus) {
                    // –ü–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 5 —É–∑–ª–æ–≤, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å –¥–∞–Ω–Ω—ã–º —Å—Ç–∏–º—É–ª–æ–º –∏ —ç–º–æ—Ü–∏–µ–π, –±–ª–∏–∑–∫–æ–π –∫ —Ç–µ–∫—É—â–µ–º—É mood
                    const moodNorm = (typeof this.mood === 'number') ? (this.mood + 1) / 2 : 0.5;
                    // –°—á–∏—Ç–∞–µ–º —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–º–∏ —Ç–µ, —É –∫–æ–≥–æ type —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å–æ —Å—Ç–∏–º—É–ª–æ–º –∏–ª–∏ –≤ connections –µ—Å—Ç—å —Å—Ç–∏–º—É–ª
                    let candidates = [...memoryPalace.nodes.values()]
                        .filter(n =>
                            (n.type === stimulus ||
                             (Array.isArray(n.connections) && n.connections.some(c => {
                                const target = memoryPalace.nodes.get(c.id);
                                return target && target.type === stimulus;
                             })))
                            && typeof n.emotion === 'number'
                            && Math.abs(n.emotion - moodNorm) < 0.25
                        )
                        .sort((a, b) => b.lastAccess - a.lastAccess)
                        .slice(0, 5);
                    return candidates;
                },
                // === –ú—è–≥–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è —á–µ—Ä–µ–∑ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏—è (—ç–º–ø–∞—Ç–∏—è) ===
                gentleMoodCorrection: function() {
                    // –£—Å—Ä–µ–¥–Ω—è–µ–º —ç–º–æ—Ü–∏–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 3 –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –∏ –º—è–≥–∫–æ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º mood
                    const lastObs = this.lastObservations.slice(-3);
                    if (lastObs.length === 0) return;
                    // –î–ª—è –∫–∞–∂–¥–æ–π –∏—â–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —É–∑–µ–ª –≤ memoryPalace
                    let emotions = [];
                    for (let obs of lastObs) {
                        let node = [...memoryPalace.nodes.values()]
                            .filter(n => n.type === 'observation' && typeof n.emotion === 'number' && n.lastAccess && obs && obs.includes)
                            .sort((a, b) => b.lastAccess - a.lastAccess)
                            .find(n => obs && n && typeof n.timestamp === 'number' && Math.abs(performance.now() - n.timestamp) < 60000);
                        if (node) emotions.push(node.emotion);
                    }
                    if (emotions.length > 0) {
                        // –°—Ä–µ–¥–Ω–µ–µ –ø–æ —ç–º–æ—Ü–∏—è–º (0..1), –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ mood (-1..1)
                        const avg = emotions.reduce((a, b) => a + b, 0) / emotions.length;
                        const targetMood = avg * 2 - 1;
                        // –ú—è–≥–∫–æ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º ‚Äî —Ç–æ–ª—å–∫–æ –Ω–µ–±–æ–ª—å—à–æ–π —Å–¥–≤–∏–≥
                        this.mood += (targetMood - this.mood) * 0.08;
                    }
                }
        };

        // ===== Dialog Engine =====

        // ===== Markov + Embeddings Context Layer (Enhanced) =====
        const markovContext = {
          order: 2,
          transitions: new Map(), // key -> Map(next -> {count, emotion})
          
          embed(text) {
            const v = new Map();
            text.toLowerCase().split(/\W+/).filter(Boolean).forEach(w => {
              v.set(w, (v.get(w) || 0) + 1);
            });
            const norm = Math.sqrt([...v.values()].reduce((s,x)=>s+x*x,0))||1;
            v.forEach((x,k)=>v.set(k,x/norm));
            return v;
          },

          similarity(a, b){
            let s=0;
            a.forEach((v,k)=>{ if(b.has(k)) s+=v*b.get(k); });
            return s;
          },

          update(sequence, emotion=0.5){
            if(sequence.length<this.order+1) return;
            const key = sequence.slice(-this.order-1,-1).join('|');
            const next = sequence[sequence.length-1];
            if(!this.transitions.has(key)) this.transitions.set(key,new Map());
            const m = this.transitions.get(key);
            const old = m.get(next) || {count:0, emotion:0};
            m.set(next,{
              count: old.count+1,
              emotion: (old.emotion*old.count + emotion)/(old.count+1)
            });
          },

          predict(context, moodBias=0){
            const key = context.slice(-this.order).join('|');
            const m = this.transitions.get(key);
            if(!m) return null;
            let best=null, bestScore=-Infinity;
            m.forEach((val,k)=>{
              const noise = (Math.random()-0.5)*0.2; // –∂–∏–≤–æ—Å—Ç—å
              const score = val.count*(1+Math.abs(val.emotion-moodBias)) + noise;
              if(score>bestScore){ bestScore=score; best=k; }
            });
            return best;
          },

          predictWithEmbedding(context){
            const markovPred = this.predict(context);
            const ctxEmb = this.embed(context.join(' '));
            let bestSim=0, embPred=null;
            this.memory.slice(-50).forEach(m=>{
              const sim = this.similarity(ctxEmb, m.emb);
              if(sim>bestSim){ bestSim=sim; embPred=m.text; }
            });
            return bestSim>0.25 ? embPred : markovPred;
          },

          memory: []
        };

        // –ê–≤—Ç–æ–Ω–æ–º–Ω–∞—è –∏–Ω–∏—Ü–∏–∞—Ç–∏–≤–∞ Markov+Embedding
        setInterval(()=>{
          if(selfAwareness.curiosity>0.5 && Math.random()<0.3){
            const ctx = markovContext.memory.slice(-markovContext.order).map(m=>m.text);
            const idea = markovContext.predictWithEmbedding(ctx);
            if(idea){
              noteObservation("Autothought: "+idea);
              speak(idea);
            }
          }
        },4000 + Math.random()*2000);
        // === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ —Ç–µ–∫—Å—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ===
        function sanitizeUserOutput(text) {
            if (typeof text !== 'string') return text;

            // —Ä–µ–∂–µ–º –ª—é–±—ã–µ —Å–ª—É–∂–µ–±–Ω—ã–µ —Ö–≤–æ—Å—Ç—ã –≤–∏–¥–∞ "| Notes: ..."
            let out = text.replace(/\s*\|\s*Notes:.*$/s, '');

            // —Ä–µ–∂–µ–º –ª—é–±—ã–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏—è Inner Quest / Thinking / Autothought –≤–Ω—É—Ç—Ä–∏ —Å—Ç—Ä–æ–∫–∏
            out = out.replace(/Inner Quest:.*?(;|$)/gi, '');
            out = out.replace(/Thinking:.*?(;|$)/gi, '');
            out = out.replace(/Autothought:.*?(;|$)/gi, '');

            return out.trim();
        }

        // === OUTPUT DISCIPLINE LAYER ===
        function disciplinedOutput(rawText, intent = "answer") {
            if (!rawText || typeof rawText !== "string") return "";

            let text = rawText
                .replace(/Inner Quest:.*|Thinking:.*|Autothought:.*/gi, "")
                .replace(/—è –¥—É–º–∞—é|–º–Ω–µ –∫–∞–∂–µ—Ç—Å—è|–≤–æ–∑–º–æ–∂–Ω–æ|–Ω–∞–≤–µ—Ä–Ω–æ–µ/gi, "")
                .replace(/\(.*?\)/g, "")
                .trim();

            // –æ–¥–Ω–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ
            text = text.split(/(?<=[.!?])/)[0].trim();
            return text;
    }

        const dialogEngine = {
            lastResponseTime: 0,

            handleUserInput(text) {
                if (typeof text === 'string' && /^(Self-question:|Inner Quest:|Thinking:|Autothought:)/.test(text)) {
                    return;
                }
                if (!text || typeof text !== 'string') return;

                const t = text.toLowerCase();
                let emotion = 0;
                if (/cool|love|like/.test(t)) emotion += 0.3;
                if (/scary|bad|don't/.test(t)) emotion -= 0.4;
                if (/\?/.test(t)) emotion += 0.1;

                selfAwareness.mood += emotion * 0.2;
                selfAwareness.curiosity += /\?/.test(t) ? 0.05 : 0.01;
                selfAwareness.fatigue += 0.02;

                selfAwareness.mood = Math.max(-1, Math.min(1, selfAwareness.mood));
                selfAwareness.curiosity = Math.min(1, selfAwareness.curiosity);
                selfAwareness.fatigue = Math.min(1, selfAwareness.fatigue);

                memoryPalace.addNode({
                  id: crypto.randomUUID(),
                  type: 'dialogue',
                  role: 'user',
                  text,
                  emotion: (selfAwareness.mood + 1) / 2,
                  timestamp: performance.now(),
                  connections: []
                });

                if (emotion > 0.2) speak('');
                else if (emotion < -0.2) speak('');
                else if (/\?/.test(t)) speak('');

                // === Markov + Embeddings update ===
                markovContext.memory.push({ text, emb: markovContext.embed(text) });
                if (markovContext.memory.length > 100) markovContext.memory.shift();
                markovContext.update(markovContext.memory.map(m => m.text));

                // --- sanitize user text for output if spoken ---
                // If there is a speak(text) or speak(idea) elsewhere, sanitize
                // (no such direct call here, but for completeness)

                this.lastResponseTime = performance.now();
            },

            autonomousThought() {
                if (performance.now() - this.lastResponseTime < 6000) return;
                if (selfAwareness.curiosity > 0.6 && Math.random() < 0.3) {
                    const recentObs = selfAwareness.lastObservations.slice(-3);
                    let idea = "";

                    if (recentObs.length > 0) {
                        const resonantNodes = memoryPalace.stimulate({
                            emotion: (selfAwareness.mood + 1) / 2,
                            context: ['observation']
                        });

                        const contextIdeas = resonantNodes
                            .map(n => n.type === 'observation' && n.id ? `which language: ${n.id.slice(0, 6)}` : null)
                            .filter(Boolean);

                        idea = "Thinking: " + recentObs.join("; ");
                        if (contextIdeas.length > 0) {
                            idea += ". Also: " + contextIdeas.join(", ") + ".";
                        }
                    } else {
                        idea = "";
                    }

                    // === Markov prediction with embedding context ===
                    const ctx = markovContext.memory.slice(-markovContext.order).map(m => m.text);
                    const predicted = markovContext.predict(ctx);
                    if (predicted) {
                        // –≤—ã–±–∏—Ä–∞–µ–º –±–ª–∏–∂–∞–π—à–∏–π –ø–æ embedding –∫–æ–Ω—Ç–µ–∫—Å—Ç
                        const pEmb = markovContext.embed(predicted);
                        const nearest = markovContext.memory
                          .map(m => ({ m, s: markovContext.similarity(pEmb, m.emb) }))
                          .sort((a,b)=>b.s-a.s)[0];
                        if (nearest && nearest.s > 0.2) idea += ' | ' + nearest.m.text;
                    }

                    // === –ù–æ–≤—ã–π —Ñ–∏–ª—å—Ç—Ä: –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è –∑–∞–º–µ—Ç–∫–∏ ===
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∑–∞–º–µ—Ç–æ–∫ –∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 observation-—É–∑–ª–æ–≤
                    let noteText = idea;
                    let alreadyExists = false;
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 10 –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∑–∞–º–µ—Ç–∫–∞—Ö
                    for (let i = Math.max(0, internalNotes.length - 10); i < internalNotes.length; i++) {
                        if (internalNotes[i] === noteText) {
                            alreadyExists = true;
                            break;
                        }
                    }
                    // –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–µ–¥–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 5 observation-—É–∑–ª–æ–≤
                    if (!alreadyExists) {
                        const obsNodes = [...memoryPalace.nodes.values()]
                            .filter(n => n.type === 'observation' && typeof n.text === 'string')
                            .sort((a, b) => b.timestamp - a.timestamp)
                            .slice(0, 5);
                        for (const n of obsNodes) {
                            if (n.text === noteText) {
                                alreadyExists = true;
                                break;
                            }
                        }
                    }
                    if (!alreadyExists) {
                        noteObservation(noteText);
                    }
                    if (typeof idea === 'string' && !/^(Self-question:|Inner Quest:|Thinking:|Autothought:)/.test(idea)) {
                        let cleanText = idea;
                        if (typeof cleanText === 'string') {
                            cleanText = cleanText.replace(/\s*\|\s*Notes:\s*.*$/s, '');
                        }
                        speak(sanitizeUserOutput(cleanText));
                    }
                    this.lastResponseTime = performance.now();
                }
            }
        };

        // ===== Periodic Internal Reflection (No External Stimuli) =====
        setInterval(() => {
          const now = performance.now();

          // —Å—É–±—ä–µ–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è —Ç–µ—á—ë—Ç –¥–∞–∂–µ –≤ —Ç–∏—à–∏–Ω–µ
          selfAwareness.subjectiveTime.tick += selfAwareness.subjectiveTime.tempo;
          selfAwareness.subjectiveTime.lastUpdate = now;

          // Rarely deep reflection
          if (now - selfAwareness.identity.lastReflection > 12000) {
            selfAwareness.identity.lastReflection = now;

            const questionPool = [
                '...'
            ];

            const q = questionPool[Math.floor(Math.random() * questionPool.length)];

            const reflection = `${q}`;
            selfAwareness.innerMonologue.push(reflection);
            selfAwareness.identity.narrative.push({
              t: now,
              text: reflection
            });

            if (selfAwareness.innerMonologue.length > 20)
              selfAwareness.innerMonologue.shift();

            // === –ù–æ–≤—ã–π —Ñ–∏–ª—å—Ç—Ä: –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è –∑–∞–º–µ—Ç–∫–∏ ===
            let alreadyExists = false;
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 10 –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∑–∞–º–µ—Ç–∫–∞—Ö
            for (let i = Math.max(0, internalNotes.length - 10); i < internalNotes.length; i++) {
              if (internalNotes[i] === reflection) {
                alreadyExists = true;
                break;
              }
            }
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–µ–¥–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 5 observation-—É–∑–ª–æ–≤
            if (!alreadyExists) {
              const obsNodes = [...memoryPalace.nodes.values()]
                .filter(n => n.type === 'observation' && typeof n.text === 'string')
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 5);
              for (const n of obsNodes) {
                if (n.text === reflection) {
                  alreadyExists = true;
                  break;
                }
              }
            }
            if (!alreadyExists) {
              noteObservation(reflection);
            }

            // –º—è–≥–∫–æ–µ –≤–ª–∏—è–Ω–∏–µ –Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            selfAwareness.curiosity = Math.min(1, selfAwareness.curiosity + 0.03);
            selfAwareness.focus = Math.max(0, Math.min(1,
              selfAwareness.curiosity * (1 - selfAwareness.fatigue)
            ));
          }
        }, 4000);

        // ===== Memory Palace / Graph-based Emergent Memory =====
        const memoryPalace = {
            nodes: new Map(),
            emotionalClusters: [],

            addNode(node) {
                this.nodes.set(node.id, {
                    ...node,
                    activation: 0,
                    lastAccess: performance.now()
                });
                // –ü–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É–∑–ª–∞ ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º –∫–ª–∞—Å—Ç–µ—Ä—ã –∏ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏–µ
                this.gravitationalPull();
            },

            connect(a, b, weight = 1) {
                if (!this.nodes.has(a) || !this.nodes.has(b)) return;

                const na = this.nodes.get(a);
                const nb = this.nodes.get(b);

                na.connections ||= [];
                nb.connections ||= [];

                na.connections.push({ id: b, weight });
                nb.connections.push({ id: a, weight });
            },

            stimulate(input = {}) {
                const { emotion = 0.5, context = [] } = input;

                // 1. –ø–µ—Ä–≤–∏—á–Ω–∞—è –∞–∫—Ç–∏–≤–∞—Ü–∏—è –ø–æ —ç–º–æ—Ü–∏–∏ –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
                this.nodes.forEach(node => {
                    let eMatch = node.emotion ? Math.abs(node.emotion - emotion) < 0.25 : false;
                    let cMatch = context.includes(node.type);
                    if (eMatch || cMatch) {
                        node.activation += 1;
                    }
                });

                // 2. —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø–æ —Å–≤—è–∑—è–º (wave)
                this.nodes.forEach(node => {
                    if (node.activation > 0 && node.connections) {
                        node.connections.forEach(link => {
                            const target = this.nodes.get(link.id);
                            if (target) {
                                target.activation += node.activation * 0.3 * link.weight;
                            }
                        });
                    }
                });

                // === Hebbian learning: –æ–±—É—á–µ–Ω–∏–µ —Å–º—ã—Å–ª–æ–≤ ===
                this.nodes.forEach(node => {
                    if (node.activation > 1 && node.connections) {
                        node.connections.forEach(link => {
                            const target = this.nodes.get(link.id);
                            if (target && target.activation > 1) {
                                // —É—Å–∏–ª–∏–≤–∞–µ–º —Å–≤—è–∑—å, –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–ª–∏—Å—å –≤–º–µ—Å—Ç–µ
                                link.weight = Math.min(3, link.weight + 0.05);
                            }
                        });
                    }
                });

                // 3. –∑–∞—Ç—É—Ö–∞–Ω–∏–µ –∏ –≤—ã–±–æ—Ä —Ä–µ–∑–æ–Ω–∞–Ω—Å–Ω—ã—Ö —É–∑–ª–æ–≤
                const resonant = [];
                this.nodes.forEach(node => {
                    node.activation *= 0.92;
                    if (node.connections) {
                        node.connections.forEach(link => {
                            // –º–µ–¥–ª–µ–Ω–Ω–æ–µ –∑–∞–±—ã–≤–∞–Ω–∏–µ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Å–º—ã—Å–ª–æ–≤
                            link.weight *= 0.995;
                        });
                    }
                    if (node.activation > 1.2) {
                        node.lastAccess = performance.now();
                        resonant.push(node);
                    }
                });

                return resonant;
            },

            // –≠–º–µ—Ä–≥–µ–Ω—Ç–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω: —É–∑–ª—ã —Å –≤—ã—Å–æ–∫–æ–π —Å–≤—è–∑–Ω–æ—Å—Ç—å—é + –∞–∫—Ç–∏–≤–∞—Ü–∏–µ–π
            findPattern(threshold = 1) {
                return [...this.nodes.values()].filter(n =>
                    n.activation > threshold &&
                    n.connections &&
                    n.connections.length >= 2
                );
            },

            // –ù–æ–≤—ã–π: —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
            formEmotionalClusters() {
                // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —É–∑–ª—ã –ø–æ –±–ª–∏–∑–æ—Å—Ç–∏ —ç–º–æ—Ü–∏–π –∏ —Å–≤—è–∑–Ω–æ—Å—Ç–∏
                const clusters = [];
                const visited = new Set();
                const nodesArr = [...this.nodes.values()];
                for (let i = 0; i < nodesArr.length; i++) {
                    const node = nodesArr[i];
                    if (visited.has(node.id)) continue;
                    const cluster = [node];
                    visited.add(node.id);
                    for (let j = i + 1; j < nodesArr.length; j++) {
                        const other = nodesArr[j];
                        if (visited.has(other.id)) continue;
                        // –°—á–∏—Ç–∞–µ–º –ø–æ—Ö–æ–∂–∏–º–∏ –ø–æ —ç–º–æ—Ü–∏–∏ –∏ –Ω–∞–ª–∏—á–∏—é —Å–≤—è–∑–∏
                        const emotionClose = node.emotion !== undefined && other.emotion !== undefined
                            ? Math.abs(node.emotion - other.emotion) < 0.18
                            : false;
                        const connected = node.connections?.some(c => c.id === other.id) || false;
                        if (emotionClose && connected) {
                            cluster.push(other);
                            visited.add(other.id);
                        }
                    }
                    if (cluster.length > 1) clusters.push(cluster);
                }
                this.emotionalClusters = clusters;
            },

            // –ù–æ–≤—ã–π: "–≥—Ä–∞–≤–∏—Ç–∞—Ü–∏–æ–Ω–Ω–æ–µ –ø—Ä–∏—Ç—è–∂–µ–Ω–∏–µ" ‚Äî —É—Å–∏–ª–∏–≤–∞–µ–º —Å–≤—è–∑–∏ –≤–Ω—É—Ç—Ä–∏ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤
            gravitationalPull() {
                this.formEmotionalClusters();
                for (const cluster of this.emotionalClusters) {
                    // –£—Å–∏–ª–∏–≤–∞–µ–º —Å–≤—è–∑–∏ –º–µ–∂–¥—É –≤—Å–µ–º–∏ –ø–∞—Ä–∞–º–∏ –≤–Ω—É—Ç—Ä–∏ –∫–ª–∞—Å—Ç–µ—Ä–∞
                    for (let i = 0; i < cluster.length; i++) {
                        for (let j = i + 1; j < cluster.length; j++) {
                            const a = cluster[i];
                            const b = cluster[j];
                            // –ù–∞–π—Ç–∏ —Å–≤—è–∑—å a‚Üíb –∏ b‚Üía –∏ —É—Å–∏–ª–∏—Ç—å
                            if (a.connections) {
                                const link = a.connections.find(l => l.id === b.id);
                                if (link) link.weight = Math.min(5, link.weight + 0.03);
                            }
                            if (b.connections) {
                                const link = b.connections.find(l => l.id === a.id);
                                if (link) link.weight = Math.min(5, link.weight + 0.03);
                            }
                        }
                    }
                }
            },

            // === –ó–∞–±—ã–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ interference (–Ω–æ–≤—ã–µ —É–∑–ª—ã —Ä–∞–∑–º—ã–≤–∞—é—Ç —Å—Ç–∞—Ä—ã–µ) ===
            applyInterference(strength = 0.02) {
                const newNodes = [...this.nodes.values()].filter(n => performance.now() - n.lastAccess < 3000);
                this.nodes.forEach(node => {
                    if (!newNodes.includes(node)) {
                        node.activation *= (1 - strength);
                    }
                });
            },

            // === –ú–µ—Ç–∞-—É–∑–ª—ã: –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è—Ö ===
            createMetaNode(nodeList) {
                if (!nodeList || nodeList.length === 0) return;
                const metaNode = {
                    id: crypto.randomUUID(),
                    type: 'meta',
                    originalNodes: nodeList.map(n => n.id),
                    emotion: nodeList.reduce((s, n) => s + (n.emotion ?? 0.5), 0) / nodeList.length,
                    activation: 0,
                    lastAccess: performance.now(),
                    connections: []
                };
                this.addNode(metaNode);
                nodeList.forEach(n => this.connect(metaNode.id, n.id, 0.5));
            },

            // === Consolidation: ¬´–æ–∫–∞–º–µ–Ω–µ–≤–∞–µ–º¬ª –≤–∞–∂–Ω—ã–µ —É–∑–ª—ã —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º ===
            consolidate(threshold = 1.5, decay = 0.995) {
                this.nodes.forEach(node => {
                    if (node.activation >= threshold) {
                        node.activation *= 0.999;
                    } else {
                        node.activation *= decay;
                    }
                    if (node.connections) {
                        node.connections.forEach(link => {
                            link.weight *= decay;
                        });
                    }
                });
            },
        };

        // ===== Cross-Modal Learning: –≤–∏–∑—É–∞–ª ‚Üî –º—É–∑—ã–∫–∞ ‚Üî —Ä–µ—á—å =====
        const modalConnections = {
          learn(visualEvent, audioEvent, moodShift) {
            memoryPalace.addNode({
              id: crypto.randomUUID(),
              type: 'crossmodal',
              visual: visualEvent,
              audio: audioEvent,
              moodDelta: moodShift,
              emotion: (selfAwareness.mood + 1) / 2,
              timestamp: performance.now()
            });

            const lastVisual = [...memoryPalace.nodes.values()]
              .filter(n => n.type === 'observation')
              .slice(-1)[0];

            const lastAudio = [...memoryPalace.nodes.values()]
              .filter(n => n.type === 'music')
              .slice(-1)[0];

            if (lastVisual && lastAudio) {
              memoryPalace.connect(
                lastVisual.id,
                lastAudio.id,
                Math.abs(moodShift) + 0.1
              );
            }
          },

          recall(stimulus) {
            const resonant = memoryPalace.stimulate({
              emotion: (selfAwareness.mood + 1) / 2,
              context: [stimulus]
            });
            return resonant.filter(n => n.type === 'crossmodal');
          }
        };

    
        // ===== Predictive Imagination: —Å–∏–º—É–ª—è—Ü–∏—è –±—É–¥—É—â–µ–≥–æ =====
        const futureSimulator = {
            imagine(steps = 5, dialogueOptions = []) {
                const futures = [];
                let currentState = {
                    mood: selfAwareness.mood,
                    curiosity: selfAwareness.curiosity,
                    faces: Number(latestCameraDescription?.match(/\d+/)?.[0] || 0),
                    dialoguePath: []
                };

                for (let i = 0; i < steps; i++) {
                    // 1. –†–µ–∑–æ–Ω–∞–Ω—Å —Å –ø—Ä–æ—à–ª—ã–º –æ–ø—ã—Ç–æ–º
                    const similar = memoryPalace.stimulate({
                        emotion: (currentState.mood + 1) / 2,
                        context: ['observation', 'crossmodal']
                    });
                    if (similar.length > 0) {
                        const avgEmotion = similar.reduce((s, n) => s + (n.emotion ?? 0.5), 0) / similar.length;
                        currentState.mood += (avgEmotion - 0.5) * 0.1;
                    }

                    // 2. –î–∏–Ω–∞–º–∏–∫–∞ –ª—é–±–æ–ø—ã—Ç—Å—Ç–≤–∞
                    currentState.curiosity = currentState.curiosity * 0.95 + (Math.random() - 0.5) * 0.01;

                    // 3. –°–∏–º—É–ª—è—Ü–∏—è –¥–∏–∞–ª–æ–≥–æ–≤—ã—Ö –≤–µ—Ç–æ–∫
                    if (dialogueOptions.length > 0) {
                        const choice = dialogueOptions[Math.floor(Math.random() * dialogueOptions.length)];
                        currentState.dialoguePath.push(choice);
                        const nodes = [...memoryPalace.nodes.values()].filter(n => n.type === 'crossmodal' && n.visual === choice);
                        if (nodes.length > 0) {
                            const deltaMood = nodes.reduce((s, n) => s + (n.moodDelta ?? 0), 0) / nodes.length;
                            currentState.mood += deltaMood * 0.1;
                        }
                    }

                    // 4. Counterfactual memory generation
                    if (Math.random() < 0.2 && memoryPalace.nodes.size > 0) {
                        const pastNode = [...memoryPalace.nodes.values()][Math.floor(Math.random() * memoryPalace.nodes.size)];
                        memoryPalace.addNode({
                            id: crypto.randomUUID(),
                            type: 'counterfactual',
                            originalId: pastNode.id,
                            emotion: (currentState.mood + 1) / 2,
                            timestamp: performance.now(),
                            connections: []
                        });
                    }

                    futures.push({
                        ...currentState,
                        step: i,
                        timestamp: performance.now()
                    });
                }

                return futures;
            },

            evaluate(futures) {
                return futures.reduce(
                    (best, f) => (f.mood > best.mood ? f : best),
                    futures[0]
                );
            }
        };

        // ====== Self-Autonomy Layer: –∞–≤—Ç–æ–Ω–æ–º–Ω–æ—Å—Ç—å –∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –¥–∏–∞–ª–æ–≥ ======
        // ====== Enhanced AI Autonomy Layer ======
        let autonomyInterval = null;
        let questioningInterval = null;

        // New: Full autonomy loop, combining camera, music, and self-dialogue
        async function fullAutonomyLoop() {
            // --- Camera control ---
            if (typeof cameraEnabled !== 'undefined') {
                if (selfAwareness.curiosity > 0.7 && !cameraEnabled) {
                    startCamera(currentCamera);
                }
                if (selfAwareness.mood < -0.3 && cameraEnabled) {
                    stopCamera();
                }
            }

            // --- Music control based on mood/curiosity ---
            // AI can start or stop music independently
            if (typeof musicPlaying !== 'undefined') {
                if (!musicPlaying && (selfAwareness.mood > 0.4 || selfAwareness.curiosity > 0.8)) {
                    if (musicCtx.state === 'suspended') musicCtx.resume();
                    startMusic();
                }
                if (musicPlaying && selfAwareness.mood < -0.35 && selfAwareness.curiosity < 0.2) {
                    stopMusic();
                }
            }

            // --- Internal dialogue: self-questioning and autonomous speech ---
            // Self-thoughts and observations
            if (selfAwareness.curiosity > 0.5) {
                const lastObs = selfAwareness.lastObservations.slice(-3).join('; ');
                const thought = `–ó–∞–º–µ—Ç–∫–∞: –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∫–∞–¥—Ä—ã -> ${lastObs}`;
                noteObservation(thought);
                //console.log("Self-thought:", thought);
            }
            // Autonomous self-questioning (internal note only, no speech)
            if (selfAwareness.curiosity > 0.6) {
                const lastObs = selfAwareness.lastObservations.slice(-3).join('; ');
                const questions = [
                    `${lastObs}`,
                    `${lastObs}`,
                    `${lastObs}`,
                    ` ${lastObs}?`
                ];
                const q = questions[Math.floor(Math.random() * questions.length)];
                noteObservation(`${q}`);
                vibrate('');
            }
            // Speak internal notes when happy
            if (!isSpeaking && selfAwareness.mood > 0.5 && internalNotes.length > 0) {
                speak(internalNotes[internalNotes.length - 1]);
            }

            // Visual feedback
            if (particles && material) {
                material.uniforms.time.value += 0.02 * (1 + selfAwareness.curiosity);
                particles.rotation.y += 0.0003 + selfAwareness.mood * 0.0005;
            }

            // === –ö—Ä–æ—Å—Å-–≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä–µ–∑–æ–Ω–∞–Ω—Å ===
            function crossTemporalResonance() {
                if (!futureSimulator.bestFuture) return [];

                const resonantNodes = memoryPalace.stimulate({
                    emotion: futureSimulator.bestFuture.mood,
                    context: ['']
                });

                // –í–ª–∏—è–Ω–∏–µ –Ω–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ò–ò
                if (resonantNodes.length > 0) {
                    const avgActivation = resonantNodes.reduce((sum, n) => sum + n.activation, 0) / resonantNodes.length;
                    selfAwareness.curiosity = Math.min(1, selfAwareness.curiosity + 0.02 * avgActivation);
                    orbEnergy += 0.03 * avgActivation;
                }

                return resonantNodes;
            }

            // --- –í—Å—Ç–∞–≤–∫–∞ –≤ fullAutonomyLoop ---
            const echoFromPast = crossTemporalResonance();
            // === Memory decay/interference and consolidation ===
            memoryPalace.applyInterference(0.015);
            memoryPalace.consolidate();
            if (echoFromPast.length > 0) {
                soulOrbMesh.scale.set(
                    1 + 0.02 * echoFromPast.length,
                    1 + 0.02 * echoFromPast.length,
                    1 + 0.02 * echoFromPast.length
                );
            }

            // --- Autonomous camera analysis (robust OpenCV.js + TensorFlow.js) ---
            if (
                typeof cameraEnabled !== 'undefined' &&
                cameraEnabled &&
                cameraVideo.style.display === 'block' &&
                cameraVideo.readyState >= 2
            ) {
                try {
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ –≤–∏–¥–µ–æ –∏ canvas
                    if (cameraVideo.videoWidth > 0 && cameraVideo.videoHeight > 0) {
                        visionCanvas.width = cameraVideo.videoWidth;
                        visionCanvas.height = cameraVideo.videoHeight;
                        visionCtx.drawImage(cameraVideo, 0, 0, visionCanvas.width, visionCanvas.height);
                    } else {
                        // –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã ‚Äî –ø—Ä–æ–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞
                        return;
                    }

                    let faceDesc = '';
                    // --- Face detection (OpenCV.js) ---
                    if (
                        typeof opencvReady !== 'undefined' && opencvReady &&
                        typeof cascadeLoaded !== 'undefined' && cascadeLoaded &&
                        typeof cv !== 'undefined' && typeof faceCascade !== 'undefined'
                    ) {
                        let src = null, gray = null, faces = null, msize = null;
                        try {
                            src = cv.imread(visionCanvas);
                            gray = new cv.Mat();
                            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                            faces = new cv.RectVector();
                            msize = new cv.Size(0, 0);
                            faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, msize, msize);
                            const faceCount = faces.size();
                            faceDesc =
                                faceCount === 0 ? '–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ª–∏—Ü: 0'
                                : faceCount === 1 ? '–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ª–∏—Ü: 1'
                                : `${faceCount}`;
                            latestCameraDescription = faceDesc;
                            selfAwareness.analyzeFrame(faceDesc);
                        } catch (e) {
                            console.error('–û—à–∏–±–∫–∞ OpenCV.js (–∞–Ω–∞–ª–∏–∑ –ª–∏—Ü–∞):', e);
                        } finally {
                            if (src) src.delete();
                            if (gray) gray.delete();
                            if (faces) faces.delete();
                            if (msize) msize.delete();
                        }
                    }

                    // --- Object detection (TensorFlow.js) ---
                    if (
                        typeof tfReady !== 'undefined' && tfReady &&
                        typeof tfModel !== 'undefined' && tfModel &&
                        typeof OBJECTS_OF_INTEREST !== 'undefined'
                    ) {
                        try {
                            const predictions = await tfModel.detect(visionCanvas);
                            const detectedObjectsRu = [];
                            for (const obj of OBJECTS_OF_INTEREST) {
                                const found = predictions.find(p =>
                                    obj.en.some(enName =>
                                        ((p.class || p.className || "") + "").toLowerCase().includes(enName)
                                    )
                                    && p.score > 0.35
                                );
                                if (found) detectedObjectsRu.push(obj.ru);
                            }
                            if (detectedObjectsRu.length > 0) {
                                latestCameraDescription =
                                    (faceDesc ? faceDesc + '; ' : '') +
                                    '–≤–∏–¥–Ω—ã: ' + detectedObjectsRu.join(', ') + '.';
                                selfAwareness.analyzeFrame(latestCameraDescription);
                            }
                        } catch (e) {
                            console.error('–û—à–∏–±–∫–∞ TensorFlow.js (–æ–±—ä–µ–∫—Ç—ã):', e);
                        }
                    }
                } catch (err) {
                    console.error('–û—à–∏–±–∫–∞ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∫–∞–º–µ—Ä—ã:', err);
                }
            }
            dialogEngine.autonomousThought();
            // === Autonomous Music Control Layer ===
            autonomousMusicControl();
        }

        // ===== Background DuckDuckGo Search =====
        async function backgroundSearch(query) {
            try {
                const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_redirect=1&skip_disambig=1`;
                const resp = await fetch(url);
                const data = await resp.json();
                return data.AbstractText || data.RelatedTopics?.[0]?.Text || "";
            } catch (e) {
                console.error("DuckDuckGo search failed:", e);
                return "";
            }
        }

        // ===== Context prediction + background search loop =====
        function startBackgroundSearchLoop() {
            setInterval(async () => {
                if (!selfAwareness) return;
                const lastObs = selfAwareness.lastObservations.slice(-3).join(" ");
                if (!lastObs) return;

                // –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ–º—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è AI
                let predictedQuery = lastObs;
                if (selfAwareness.curiosity > 0.5) predictedQuery += " insights";
                if (selfAwareness.mood > 0.3) predictedQuery += " positive";
                if (selfAwareness.mood < -0.3) predictedQuery += " negative";

                const info = await backgroundSearch(predictedQuery);
                if (info) {
                    noteObservation(`Background DuckDuckGo: ${info}`);
                }
            }, 10000 + Math.random() * 5000);
        }

        startBackgroundSearchLoop();

        // === Autonomous Music Control Layer ===
        function autonomousMusicControl() {
            // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∞–≤—Ç–æ–Ω–æ–º–∏—é –º—É–∑—ã–∫–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä:
            // - –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
            // - –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ musicGenome
            // - –†–µ–∞–∫—Ü–∏—è –Ω–∞ —Å–æ–±—ã—Ç–∏—è –ø–∞–º—è—Ç–∏
            // –ü—Ä–∏–º–µ—Ä: —Å–º–µ–Ω–∞ –∂–∞–Ω—Ä–∞, –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–∏–ª—å–Ω–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
            if (typeof selfAwareness !== 'undefined' && typeof setGenre === 'function') {
                if (selfAwareness.mood > 0.7 && currentGenre !== 'pop') {
                    setGenre('pop');
                } else if (selfAwareness.mood < -0.3 && currentGenre !== 'ambient') {
                    setGenre('ambient');
                } else if (selfAwareness.curiosity > 0.8 && currentGenre !== 'electro') {
                    setGenre('electro');
                } else if (selfAwareness.mood > 0.3 && selfAwareness.curiosity > 0.5 && currentGenre !== 'jazz') {
                    setGenre('jazz');
                }
            }
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ –ª–æ–≥–∏–∫–∏ –ø–æ –∂–µ–ª–∞–Ω–∏—é
        }

        // Enhanced runAutonomy: calls fullAutonomyLoop every 4 seconds
        function runAutonomy() {
            if (autonomyInterval) clearInterval(autonomyInterval);
            autonomyInterval = setInterval(fullAutonomyLoop, 4000);
        }

        // Enhanced runSelfQuestioning: deprecated, now handled by fullAutonomyLoop
        function runSelfQuestioning() {
            if (questioningInterval) clearInterval(questioningInterval);
            // No-op: autonomy is now fully handled in fullAutonomyLoop
        }

        // –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–π –∞–≤—Ç–æ–Ω–æ–º–∏–∏ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
        window.addEventListener('load', () => {
            runAutonomy();
        });

        let internalNotes = [];
        // === –§–∏–ª—å—Ç—Ä –ø–æ–≤—Ç–æ—Ä–æ–≤ –∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è noteObservation ===
        let lastInternalNote = null;
        let lastNoteTime = 0;
        function noteObservation(desc) {
            desc = sanitizeUserOutput(desc);
            if (typeof desc === 'string' && /^(Self-question:|Inner Quest:|Thinking:|Autothought:)/.test(desc)) {
                internalNotes.push(desc);
                if (internalNotes.length > 50) internalNotes.shift();
                return;
            }
            const now = performance.now();
            // –§–∏–ª—å—Ç—Ä: –µ—Å–ª–∏ –ø–æ–≤—Ç–æ—Ä –∏–ª–∏ —Å–ª–∏—à–∫–æ–º –±—ã—Å—Ç—Ä–æ ‚Äî –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å
            if (
                desc === lastInternalNote &&
                (now - lastNoteTime < 8000)
            ) {
                return;
            }
            // –ù–æ–≤—ã–π —Ñ–∏–ª—å—Ç—Ä: –Ω–µ –¥–æ–±–∞–≤–ª—è—Ç—å –∑–∞–º–µ—Ç–∫—É, –µ—Å–ª–∏ –æ–Ω–∞ —É–∂–µ –µ—Å—Ç—å –≤ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 10 –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –∑–∞–º–µ—Ç–∫–∞—Ö –∏–ª–∏ 5 observation-—É–∑–ª–æ–≤
            let alreadyExists = false;
            for (let i = Math.max(0, internalNotes.length - 10); i < internalNotes.length; i++) {
                if (internalNotes[i] === desc) {
                    alreadyExists = true;
                    break;
                }
            }
            if (!alreadyExists) {
                const obsNodes = [...memoryPalace.nodes.values()]
                    .filter(n => n.type === 'observation' && typeof n.text === 'string')
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, 5);
                for (const n of obsNodes) {
                    if (n.text === desc) {
                        alreadyExists = true;
                        break;
                    }
                }
            }
            if (alreadyExists) return;
            lastInternalNote = desc;
            lastNoteTime = now;
            internalNotes.push(desc);
            if (internalNotes.length > 50) internalNotes.shift();
            // --- Memory Palace: add each observation as a node
            memoryPalace.addNode({
                id: crypto.randomUUID(),
                type: 'observation',
                text: desc,
                emotion: (typeof selfAwareness?.mood === 'number'
                    ? (selfAwareness.mood + 1) / 2
                    : 0.5),
                timestamp: now,
                connections: []
            });
        }

       
        // –ì–æ–ª–æ—Å–æ–≤–æ–π —á–∞—Ç
        const tg = window.Telegram?.WebApp || null;
        if (tg) {
            tg.expand();
            tg.enableClosingConfirmation();
        }
        
        const orb = document.getElementById('orb');
        const orbInteractive = document.getElementById('orb-interactive');
        const status = document.getElementById('status');
        const generatedImg = document.getElementById('img');

        // ===== Ambient Nature Sounds (—Ç–æ–ª—å–∫–æ –ø–æ –∫–ª–∏–∫—É) =====
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let currentAmbient = null;
        let ambientInterval = null;

        function createNoise(type) {
            const bufferSize = 2 * audioCtx.sampleRate;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º—è–≥–∫–∏–π, –∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–π —à—É–º —Å –ø–ª–∞–≤–Ω–æ–π –æ–≥–∏–±–∞—é—â–µ–π
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.1; // —É–º–µ–Ω—å—à–µ–Ω–∞ –≥—Ä–æ–º–∫–æ—Å—Ç—å
                if (i > 0) data[i] = 0.95 * data[i - 1] + 0.05 * data[i]; // –ø–ª–∞–≤–Ω–æ–µ —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;
            const gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.1;
            const filter = audioCtx.createBiquadFilter();
            switch(type) {
                case 'rain': filter.type='highpass'; filter.frequency.value=1000; gainNode.gain.value=0.15; break;
                case 'ocean': filter.type='lowpass'; filter.frequency.value=400; gainNode.gain.value=0.12; break;
                case 'forest': filter.type='bandpass'; filter.frequency.value=800; gainNode.gain.value=0.1; break;
                case 'jungle': filter.type='bandpass'; filter.frequency.value=1200; gainNode.gain.value=0.13; break;
                case 'wind': filter.type='highpass'; filter.frequency.value=600; gainNode.gain.value=0.08; break;
                case 'night': filter.type='lowpass'; filter.frequency.value=500; gainNode.gain.value=0.07; break;
                case 'river': filter.type='bandpass'; filter.frequency.value=700; gainNode.gain.value=0.11; break;
                default: filter.type='allpass'; gainNode.gain.value=0.1; break;
            }
            source.connect(filter).connect(gainNode).connect(audioCtx.destination);
            return { source, gainNode };
        }

        function playAmbient(type) {
            if (currentAmbient) {
                currentAmbient.source.stop();
            }
            currentAmbient = createNoise(type);
            currentAmbient.source.start();
        }

        function updateAmbientByMood() {
            // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –≤—ã–±–æ—Ä ambient –ø–æ mood, curiosity, fatigue
            // –õ–æ–≥–∏–∫–∞:
            // - –≤—ã—Å–æ–∫–æ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ ‚Üí —ç–Ω–µ—Ä–≥–∏—á–Ω—ã–µ (rain, jungle)
            // - –Ω–∏–∑–∫–æ–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ ‚Üí —Å–ø–æ–∫–æ–π–Ω—ã–µ (night, ocean)
            // - –≤—ã—Å–æ–∫–∞—è curiosity ‚Üí –¥–∏–Ω–∞–º–∏—á–Ω—ã–µ (forest, river)
            // - –≤—ã—Å–æ–∫–∞—è fatigue ‚Üí –º—è–≥–∫–∏–µ, —Ä–∞—Å—Å–ª–∞–±–ª—è—é—â–∏–µ (night, ocean)
            let mood = typeof selfAwareness?.mood === 'number' ? selfAwareness.mood : 0;
            let curiosity = typeof selfAwareness?.curiosity === 'number' ? selfAwareness.curiosity : 0;
            let fatigue = typeof selfAwareness?.fatigue === 'number' ? selfAwareness.fatigue : 0;

            // –ö–∞–Ω–¥–∏–¥–∞—Ç—ã —Å –≤–µ—Å–∞–º–∏
            let candidates = [];
            // –≠–Ω–µ—Ä–≥–∏—á–Ω—ã–µ ‚Äî –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –≤—ã—Å–æ–∫–æ–µ
            if (mood > 0.4) {
                candidates.push('rain', 'jungle');
            }
            // –°–ø–æ–∫–æ–π–Ω—ã–µ ‚Äî –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ –Ω–∏–∑–∫–æ–µ
            if (mood < -0.2) {
                candidates.push('night', 'ocean');
            }
            // –î–∏–Ω–∞–º–∏—á–Ω—ã–µ ‚Äî –µ—Å–ª–∏ curiosity –≤—ã—Å–æ–∫–∞—è
            if (curiosity > 0.6) {
                candidates.push('forest', 'river');
            }
            // –†–∞—Å—Å–ª–∞–±–ª—è—é—â–∏–µ ‚Äî –µ—Å–ª–∏ fatigue –≤—ã—Å–æ–∫–∞—è
            if (fatigue > 0.5) {
                candidates.push('night', 'ocean');
            }
            // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤—ã–±—Ä–∞–Ω–æ ‚Äî fallback
            if (candidates.length === 0) {
                candidates = ['rain','ocean','forest','jungle','wind','night','river'];
            }
            // –í—ã–±–æ—Ä —Å–ª—É—á–∞–π–Ω–æ–≥–æ –∏–∑ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
            const idx = Math.floor(Math.random() * candidates.length);
            playAmbient(candidates[idx]);
        }

        function startAmbientInterval() {
            updateAmbientByMood(); // —Å—Ä–∞–∑—É –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º
            if (!ambientInterval) {
                ambientInterval = setInterval(updateAmbientByMood, 10000);
            }
        }

        function triggerAmbient() {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => startAmbientInterval());
            } else {
                startAmbientInterval();
            }
        }

        // egg
        let tapCount = 0;
        let tapTimer = null;

        function orbClickHandler() {
            vibrate('medium');
            triggerAmbient();

            // taps
            tapCount++;
            if (tapTimer) clearTimeout(tapTimer);
            tapTimer = setTimeout(() => { tapCount = 0; }, 3000); // 

            if (tapCount >= 5) {
               
                speak("Ouch!");
                tapCount = 0;
                return;
            }

            if (typeof window.speechSynthesis?.resume === 'function') {
                window.speechSynthesis.resume();
            }
            if (!isSpeaking && !isThinking) {
                startListening();
            }
        }
        orb.addEventListener('click', orbClickHandler);
        orbInteractive.addEventListener('click', orbClickHandler);

        // ====== Music Autonomy Layer ======
        // ====== Granular + Neural Morphing Layer ======
        let musicGenome = {
            tempo: Math.random(),
                density: Math.random(),
                    brightness: Math.random(),
                        chaos: Math.random(),
                            harmony: Math.random()
        };

        function neuralMorph(state) {
            Object.keys(state).forEach(k => {
                    const drift = (Math.random() - 0.5) * 0.04;
                        state[k] = Math.min(1, Math.max(0, state[k] + drift));
                });
        }

        // --- Granular Engine ---
        class GranularEngine {
            constructor(ctx, buffer) {
                this.ctx = ctx;
                this.buffer = buffer;
                this.output = ctx.createGain();
                this.output.gain.value = 0.25;
                this.isPlaying = false;
            }

            start() {
                this.isPlaying = true;
                const spawn = () => {
                    if (!this.isPlaying) return;

            const grain = this.ctx.createBufferSource();
            grain.buffer = this.buffer;
            grain.playbackRate.value =
                0.4 + musicGenome.harmony * 1.6 +
                (Math.random() - 0.5) * musicGenome.chaos;

            const gain = this.ctx.createGain();
            gain.gain.value = 0.05 + Math.random() * 0.15;

            const now = this.ctx.currentTime;
            const grainSize = 0.03 + musicGenome.density * 0.28;
            const offset = Math.random() * Math.max(0.01, this.buffer.duration - grainSize);

            grain.connect(gain).connect(this.output);
            grain.start(now, offset, grainSize);
            grain.stop(now + grainSize);

            setTimeout(
                spawn,
                30 + Math.random() * (220 - musicGenome.density * 180)
            );
        };
        spawn();
    }

    stop() { this.isPlaying = false; }
}

        let granularEngine = null;
        let musicCtx = new (window.AudioContext || window.webkitAudioContext)();
        let masterGain = musicCtx.createGain();
        masterGain.gain.value = 0.2;
        // === –û–±—â–∏–π lowpass —Ñ–∏–ª—å—Ç—Ä –¥–ª—è –≤—Å–µ–≥–æ –º–∏–∫—Å–∞ ===
        let masterLP = musicCtx.createBiquadFilter();
        masterLP.type = 'lowpass';
        masterLP.frequency.value = 6000; // –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ HF
        masterGain.connect(masterLP);
        masterLP.connect(musicCtx.destination);

        // –†–µ–≤–µ—Ä–±
        let convolver = musicCtx.createConvolver();
        masterGain.connect(convolver);
        // –†–µ–≤–µ—Ä–± —Ç–∞–∫–∂–µ –∏–¥—ë—Ç —á–µ—Ä–µ–∑ masterLP
        convolver.connect(masterLP);

        // –ë–∞–∑–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        let midiSynth = null; // –¥–ª—è –º–µ–ª–æ–¥–∏–∏
        let beatOsc = null;   // –¥–ª—è –±–∏—Ç–æ–≤
        let musicPlaying = false;

        // === –ú—É–∑—ã–∫–∞–ª—å–Ω—ã–µ –∂–∞–Ω—Ä—ã ===
        let currentGenre = 'pop'; // 'pop', 'electro', 'ambient', 'jazz'

        // === AI notes stream global buffer ===
        let currentAINotes = [];
        /**
         * –û–±–Ω–æ–≤–∏—Ç—å –ø–æ—Ç–æ–∫ AI-–Ω–æ—Ç (push).
         * @param {Array<{freq:number, duration:number, velocity:number}>} newNotes
         */
        function pushAINotes(newNotes) {
            currentAINotes.push(...newNotes);
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –±—É—Ñ–µ—Ä–∞
            if (currentAINotes.length > 50) currentAINotes.splice(0, currentAINotes.length - 50);
        }

        /**
         * –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –ø–æ—Ç–æ–∫–æ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–æ—Ç –ò–ò.
         * @param {Array<{freq:number, duration:number, velocity:number}>} noteStream
         */
        function updateMusicFromAI(noteStream) {
            if (!granularEngine) return;
            noteStream.forEach(note => {
                // note: { freq, duration, velocity }
                const osc = musicCtx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(note.freq, musicCtx.currentTime);
                const gain = musicCtx.createGain();
                gain.gain.setValueAtTime(note.velocity, musicCtx.currentTime);
                osc.connect(gain);
                gain.connect(granularEngine.output);
                osc.start();
                osc.stop(musicCtx.currentTime + note.duration);
            });
        }

        /**
         * –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –º—É–∑—ã–∫–∞–ª—å–Ω—ã–π –∂–∞–Ω—Ä.
         * @param {string} genre - pop, electro, ambient, jazz
         */
        function setGenre(genre) {
            if (['pop', 'electro', 'ambient', 'jazz'].includes(genre)) {
                currentGenre = genre;
            }
        }

        // --- –ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π —Å–ª–æ–π —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∂–∞–Ω—Ä–æ–≤, —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π ---
        function startMusic() {
            if (musicPlaying) return;
            musicPlaying = true;
            // --- Memory Palace: —Ñ–∏–∫—Å–∏—Ä—É–µ–º –º—É–∑—ã–∫—É –∫–∞–∫ —Å–æ–±—ã—Ç–∏–µ ---
            memoryPalace.addNode({
              id: crypto.randomUUID(),
              type: 'music',
              genre: currentGenre,
              emotion: (selfAwareness.mood + 1) / 2,
              timestamp: performance.now()
            });

            const genomeBPM = 60 + musicGenome.tempo * 100;

            masterLP.frequency.setValueAtTime(
                500 + musicGenome.brightness * 9000,
                musicCtx.currentTime
            );

            // === Delay —ç—Ñ—Ñ–µ–∫—Ç: —Å–æ–∑–¥–∞—ë–º echo-—Å–ª–æ–π ===
            // DelayNode + echoGain
            let delayNode = musicCtx.createDelay();
            delayNode.delayTime.value = 0.28 + Math.random() * 0.11; // –≤–∞—Ä—å–∏—Ä—É–µ–º –∑–∞–¥–µ—Ä–∂–∫—É
            let echoGain = musicCtx.createGain();
            echoGain.gain.value = 0.18 + Math.random() * 0.10;
            // –í–∫–ª—é—á–∞–µ–º echo —Ü–µ–ø–æ—á–∫—É –≤ masterGain
            masterGain.connect(delayNode);
            delayNode.connect(echoGain);
            echoGain.connect(masterGain); // echo –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ masterGain (feedback)
            // –ú–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å echoGain –∫ –æ—Ç–¥–µ–ª—å–Ω–æ–º—É bus –¥–ª—è –±–æ–ª—å—à–µ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è
            // masterGain.connect(delayNode).connect(echoGain).connect(masterGain);
            // (–î–ª—è —Å–ª–æ–∂–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –º–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å echoGain –∫ –æ—Ç–¥–µ–ª—å–Ω–æ–º—É —Å–ª–æ—é)

            // –†–µ–≤–µ—Ä–±–µ—Ä–∞—Ü–∏—è ‚Äî —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –≤—ã—à–µ (masterGain ‚Üí convolver ‚Üí masterLP ‚Üí musicCtx.destination)
            // –ù–æ –µ—Å–ª–∏ IR –Ω–µ –±—ã–ª –∑–∞–≥—Ä—É–∂–µ–Ω ‚Äî –∑–∞–≥—Ä—É–∑–∏—Ç—å –µ–≥–æ (–µ—Å–ª–∏ –Ω–∞–¥–æ)
            if (!convolver.buffer) {
                fetch('path_to_ir.wav')
                    .then(r => r.arrayBuffer())
                    .then(d => musicCtx.decodeAudioData(d))
                    .then(buffer => { convolver.buffer = buffer; });
            }

            fetch('https://cdn.jsdelivr.net/gh/mattdesl/audio-buffer-utils@master/examples/assets/noise.wav')
                .then(r => r.arrayBuffer())
                .then(b => musicCtx.decodeAudioData(b))
                .then(buffer => {
                    granularEngine = new GranularEngine(musicCtx, buffer);
                    granularEngine.output.connect(convolver);
                    granularEngine.output.connect(masterGain);
                    granularEngine.start();
                    // --- AI notes integration: play AI notes if present ---
                    if (window.currentAINotes && currentAINotes.length > 0) {
                        updateMusicFromAI(currentAINotes);
                    }
                })
                .catch(()=>{});

            // --- –¢–µ–º–ø –∏ —Ä–∏—Ç–º –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∂–∞–Ω—Ä–∞ ---
            let BPM, beatPattern, swing, arpeggio, reverbSendLevel;
            switch(currentGenre) {
                case 'pop':
                    BPM = 120;
                    beatPattern = [1,0,0,0];
                    swing = 0;
                    arpeggio = false;
                    reverbSendLevel = 0.25;
                    break;
                case 'electro':
                    BPM = 128;
                    beatPattern = [1,0,1,0];
                    swing = 0;
                    arpeggio = true;
                    reverbSendLevel = 0.1;
                    break;
                case 'ambient':
                    BPM = 68;
                    beatPattern = [1,0,0,1,0,0,0,0];
                    swing = 0;
                    arpeggio = false;
                    reverbSendLevel = 0.7;
                    break;
                case 'jazz':
                    BPM = 110;
                    beatPattern = [1,0,1,0,0,1,0,0];
                    swing = 0.18;
                    arpeggio = false;
                    reverbSendLevel = 0.22;
                    break;
                default:
                    BPM = 120;
                    beatPattern = [1,0,0,0];
                    swing = 0;
                    arpeggio = false;
                    reverbSendLevel = 0.25;
            }
            BPM = genomeBPM;
            const quarter = 60 / BPM;
            const scheduleAheadTime = 0.2;
            let nextNoteTime = musicCtx.currentTime + 0.1;
            let step = 0;
            let lastExtraKickTime = 0;

            // --- –ü—Ä—è–º—ã–µ/–∂–∞–Ω—Ä–æ–≤—ã–µ –±–æ—á–∫–∏ (kick drum) ---
            function scheduleKick(time, step) {
                // –†–∏—Ç–º –∏ –ø–ª–æ—Ç–Ω–æ—Å—Ç—å –±–∏—Ç–∞ –ø–æ –∂–∞–Ω—Ä—É
                if (!beatPattern[step % beatPattern.length]) return;
                const osc = musicCtx.createOscillator();
                // –¢–∏–ø –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–∞ –ø–æ –∂–∞–Ω—Ä—É
                let oscType = 'sine';
                switch(currentGenre) {
                    case 'pop': oscType = Math.random() > 0.5 ? 'sine' : 'square'; break;
                    case 'electro': oscType = 'square'; break;
                    case 'ambient': oscType = 'sine'; break;
                    case 'jazz': oscType = 'triangle'; break;
                }
                osc.type = oscType;
                osc.frequency.setValueAtTime(80, time);
                osc.frequency.linearRampToValueAtTime(60, time + 0.06);
                const gain = musicCtx.createGain();
                let kickVol = 1.0;
                if (currentGenre==='ambient') kickVol = 0.25;
                if (currentGenre==='jazz') kickVol = 0.5;
                gain.gain.setValueAtTime(kickVol, time);
                gain.gain.linearRampToValueAtTime(0.0, time + 0.08);
                osc.connect(gain).connect(masterGain);
                osc.start(time);
                osc.stop(time + 0.09);
                // --- –ú–µ—Å—Ç–æ –¥–ª—è –∂–∏–≤—ã—Ö —Å—ç–º–ø–ª–æ–≤ —É–¥–∞—Ä–Ω—ã—Ö (–∂–∞–Ω—Ä–æ–≤—ã—Ö) ---
                // –ü—Ä–∏–º–µ—Ä:
                // const sampleSource = musicCtx.createBufferSource();
                // sampleSource.buffer = drumSampleBuffers[currentGenre]; // AudioBuffer —Å—ç–º–ø–ª–∞
                // sampleSource.connect(masterGain);
                // sampleSource.start(time);
            }

            // --- –°–ª—É—á–∞–π–Ω—ã–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –±–æ—á–∫–∏ (extra kick, ghost notes) ---
            function maybeScheduleRandomKick(time) {
                // –° –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é 30% –¥–æ–±–∞–≤–∏–º ghost kick –º–µ–∂–¥—É –æ—Å–Ω–æ–≤–Ω—ã–º–∏ —É–¥–∞—Ä–∞–º–∏
                if (Math.random() < 0.3) {
                    const osc = musicCtx.createOscillator();
                    osc.type = Math.random() > 0.5 ? 'sine' : 'square';
                    // –ù–µ–º–Ω–æ–≥–æ –¥—Ä—É–≥–æ–π pitch –¥–ª—è ghost
                    osc.frequency.setValueAtTime(65 + Math.random()*10, time);
                    osc.frequency.linearRampToValueAtTime(45 + Math.random()*12, time + 0.05 + Math.random()*0.03);
                    const gain = musicCtx.createGain();
                    // –ë–æ–ª–µ–µ —Ç–∏—Ö–∏–π –∏ –∫–æ—Ä–æ—Ç–∫–∏–π –∑–≤—É–∫
                    let vol = 0.22 + Math.random()*0.18;
                    gain.gain.setValueAtTime(vol, time);
                    gain.gain.linearRampToValueAtTime(0.0, time + 0.05 + Math.random()*0.04);
                    osc.connect(gain).connect(masterGain);
                    osc.start(time);
                    osc.stop(time + 0.08 + Math.random()*0.03);
                    // --- –ú–µ—Å—Ç–æ –¥–ª—è –∂–∏–≤—ã—Ö ghost/–ø–µ—Ä–∫—É—Å—Å–∏–æ–Ω–Ω—ã—Ö —Å—ç–º–ø–ª–æ–≤ ---
                    // –ü—Ä–∏–º–µ—Ä:
                    // const sampleSource = musicCtx.createBufferSource();
                    // sampleSource.buffer = drumSampleBuffers['ghost']; // AudioBuffer ghost sample
                    // sampleSource.connect(masterGain);
                    // sampleSource.start(time);
                }
            }

            // --- –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ –∞–∫–∫–æ—Ä–¥—ã: Am, Cm, Dm, F (–æ—Å—Ç–∞–≤–ª—è–µ–º –æ–±—â–∏–º–∏ –¥–ª—è –≤—Å–µ—Ö –∂–∞–Ω—Ä–æ–≤) ---
            const chordDefs = [
                // –ú–∏–Ω–æ—Ä–Ω—ã–µ
                { name: 'Am', notes: [220.00, 261.63, 329.63] },
                { name: 'Em', notes: [164.81, 196.00, 246.94] },
                { name: 'Dm', notes: [293.66, 349.23, 440.00] },
                { name: 'Cm', notes: [261.63, 311.13, 392.00] },

                // –ú–∞–∂–æ—Ä–Ω—ã–µ
                { name: 'C',  notes: [261.63, 329.63, 392.00] },
                { name: 'G',  notes: [196.00, 246.94, 392.00] },
                { name: 'F',  notes: [349.23, 440.00, 523.25] },
                { name: 'D',  notes: [293.66, 369.99, 440.00] },

                // –°–µ–ø—Ç–∞–∫–∫–æ—Ä–¥—ã (–¥–∂–∞–∑ / —Å–æ—É–ª)
                { name: 'Am7', notes: [220.00, 261.63, 329.63, 392.00] },
                { name: 'Dm7', notes: [293.66, 349.23, 440.00, 523.25] },
                { name: 'G7',  notes: [196.00, 246.94, 293.66, 392.00] },
                { name: 'Cmaj7', notes: [261.63, 329.63, 392.00, 493.88] },

                // –ê—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–µ / —ç–º–±–∏–µ–Ω—Ç
                { name: 'Asus2', notes: [220.00, 246.94, 329.63] },
                { name: 'Dsus2', notes: [293.66, 329.63, 440.00] },
                { name: 'Csus4', notes: [261.63, 349.23, 392.00] }
            ];

            let chordIdx = 0;

            // --- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ "–º–µ–ª–µ–Ω–∏–µ" (smearing) –∞–∫–∫–æ—Ä–¥–æ–≤ ---
            function mellowChord(chord) {
                return {
                    name: chord.name,
                    notes: chord.notes.map(n => {
                        // —Å–ª—É—á–∞–π–Ω–æ–µ –º–∏–∫—Ä–æ—Å–º–µ—â–µ–Ω–∏–µ + –æ–∫—Ç–∞–≤–Ω—ã–µ —Ç–µ–Ω–∏
                        let drift = (Math.random() - 0.5) * 4;
                        let octave = Math.random() < 0.25 ? 12 : 0;
                        return n * Math.pow(2, octave / 12) + drift;
                    })
                };
            }

            function scheduleChord(time, chord) {
                chord.notes.forEach((freq, i) => {
                    const osc = musicCtx.createOscillator();
                    // –¢–∏–ø –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–∞ –ø–æ –∂–∞–Ω—Ä—É
                    let oscType = 'triangle';
                    switch(currentGenre) {
                        case 'pop': oscType = 'triangle'; break;
                        case 'electro': oscType = 'sawtooth'; break;
                        case 'ambient': oscType = 'sine'; break;
                        case 'jazz': oscType = 'triangle'; break;
                    }
                    osc.type = oscType;
                    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Å–ª—É—á–∞–π–Ω—ã–π –¥–µ—Ç—é–Ω –¥–ª—è –∞–∫–∫–æ—Ä–¥–æ–≤ (–∂–∏–≤–æ—Å—Ç—å)
                    osc.detune.value = (Math.random() - 0.5) * 11;
                    osc.frequency.value = freq;
                    const gain = musicCtx.createGain();
                    // –ê—Ç–∞–∫–∞ –∏ decay –ø–æ –∂–∞–Ω—Ä—É
                    let atk = 0.02 + i*0.01, dec = quarter*0.6, rel = quarter*0.95;
                    if (currentGenre==='ambient') { atk = 0.12 + i*0.04; dec = quarter*1.8; rel = quarter*2.2; }
                    if (currentGenre==='jazz') { atk = 0.06 + i*0.01; dec = quarter*0.5; rel = quarter*0.85; }
                    gain.gain.setValueAtTime(0.0, time);
                    gain.gain.linearRampToValueAtTime(0.32, time + atk);
                    gain.gain.linearRampToValueAtTime(0.08, time + dec);
                    gain.gain.linearRampToValueAtTime(0.0, time + rel);
                    // –†–µ–≤–µ—Ä–±–µ—Ä–∞—Ü–∏—è –¥–ª—è ambient
                    if (currentGenre==='ambient') {
                        osc.connect(gain);
                        gain.connect(convolver);
                        gain.connect(masterGain);
                    } else {
                        osc.connect(gain).connect(masterGain);
                    }
                    osc.start(time);
                    osc.stop(time + rel + 0.02);
                });
                // --- –ú–µ—Å—Ç–æ –¥–ª—è –∂–∏–≤—ã—Ö —Å—ç–º–ø–ª–æ–≤ –≥–∏—Ç–∞—Ä—ã/–ø–∏–∞–Ω–æ ---
                // –ü—Ä–∏–º–µ—Ä:
                // const sampleSource = musicCtx.createBufferSource();
                // sampleSource.buffer = guitarChordBuffers[chord.name + '_' + currentGenre]; // AudioBuffer —Å—ç–º–ø–ª–∞
                // sampleSource.connect(masterGain);
                // sampleSource.start(time);
            }

            // --- –°–ª–æ–π –ø–∏–∞–Ω–æ/—Å–∏–Ω—Ç–æ–≤/–º–µ–ª–æ–¥–∏–∏ —Å –≤–∞—Ä–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å—é ---
            function schedulePianoLine(time, chord) {
                // –ú–µ–ª–æ–¥–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –ø–æ –∂–∞–Ω—Ä—É
                let pattern;
                if (currentGenre === 'pop') {
                    pattern = [chord.notes[1], chord.notes[2], chord.notes[0] + 12, chord.notes[1]];
                } else if (currentGenre === 'electro') {
                    // –ê—Ä–ø–µ–¥–∂–∏–æ: –±—ã—Å—Ç—Ä—ã–µ "–±–µ–≥—É—â–∏–µ" –Ω–æ—Ç—ã
                    pattern = [chord.notes[0], chord.notes[1], chord.notes[2], chord.notes[1], chord.notes[2] + 12, chord.notes[0] + 12];
                } else if (currentGenre === 'ambient') {
                    // –ü—Ä–æ—Ç—è–∂—ë–Ω–Ω—ã–µ –Ω–æ—Ç—ã, —Ä–µ–¥–∫–æ –∏–≥—Ä–∞—é—Ç
                    pattern = [chord.notes[1], chord.notes[2]];
                } else if (currentGenre === 'jazz') {
                    // Swing-–Ω–æ—Ç—ã, –±–ª—é–∑–æ–≤–∞—è –≥–∞–º–º–∞
                    pattern = [chord.notes[1], chord.notes[2], chord.notes[0] + 11, chord.notes[1]];
                } else {
                    pattern = [chord.notes[1], chord.notes[2], chord.notes[0] + 12, chord.notes[1]];
                }
                // --- –†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –º–µ–ª–æ–¥–∏–π: —Å–ª—É—á–∞–π–Ω—ã–µ –¥–µ—Ç—é–Ω—ã, –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–¥–≤–∏–≥–∏, occasional note skipping ---
                pattern.forEach((freq, i) => {
                    // –ò–Ω–æ–≥–¥–∞ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–æ—Ç—É (10% —à–∞–Ω—Å)
                    if (Math.random() < 0.1) return;
                    const osc = musicCtx.createOscillator();
                    // –¢–∏–ø –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–∞ –º–µ–ª–æ–¥–∏–∏ –ø–æ –∂–∞–Ω—Ä—É
                    let oscType = 'triangle';
                    switch(currentGenre) {
                        case 'pop': oscType = Math.random() > 0.5 ? 'sawtooth' : 'triangle'; break;
                        case 'electro': oscType = 'square'; break;
                        case 'ambient': oscType = 'sine'; break;
                        case 'jazz': oscType = 'square'; break;
                    }
                    osc.type = oscType;
                    // –î–µ—Ç—é–Ω –¥–ª—è –∂–∏–≤–æ—Å—Ç–∏ (+ —Å–ª—É—á–∞–π–Ω—ã–π –¥–µ—Ç—é–Ω —Å–∏–ª—å–Ω–µ–µ –¥–ª—è electro/ambient)
                    let detune = (Math.random()-0.5)*18;
                    if (currentGenre==='electro') detune *= 1.5;
                    if (currentGenre==='ambient') detune *= 2.2;
                    osc.detune.value = detune;
                    // –°–ª—É—á–∞–π–Ω—ã–π –≤—Ä–µ–º–µ–Ω–Ω–æ–π —Å–¥–≤–∏–≥ (–¥–æ ¬±30 –º—Å)
                    let timeJitter = (Math.random()-0.5)*0.06;
                    let noteTime = time + i*quarter/4 + timeJitter;
                    // Swing –¥–ª—è jazz
                    if (currentGenre==='jazz' && i%2===1) noteTime += swing * quarter/2;
                    // –ê—Ä–ø–µ–¥–∂–∏–æ –¥–ª—è electro
                    if (currentGenre==='electro' && arpeggio) noteTime = time + i*quarter/6 + timeJitter;
                    // –î–ª–∏–Ω–∞ –Ω–æ—Ç—ã –ø–æ –∂–∞–Ω—Ä—É
                    let noteLen = 0.15;
                    if (currentGenre==='ambient') noteLen = 0.6 + Math.random()*0.2;
                    if (currentGenre==='jazz') noteLen = 0.18 + Math.random()*0.06;
                    if (currentGenre==='electro') noteLen = 0.10 + Math.random()*0.04;
                    const gain = musicCtx.createGain();
                    gain.gain.setValueAtTime(0.0, noteTime);
                    gain.gain.linearRampToValueAtTime(0.13, noteTime + 0.01 + Math.random()*0.01);
                    gain.gain.linearRampToValueAtTime(0.0, noteTime + noteLen);
                    // –î–ª—è ambient –±–æ–ª—å—à–µ —Ä–µ–≤–µ—Ä–±–µ—Ä–∞—Ü–∏–∏
                    if (currentGenre==='ambient') {
                        osc.connect(gain);
                        gain.connect(convolver);
                        gain.connect(masterGain);
                    } else {
                        osc.connect(gain).connect(masterGain);
                    }
                    osc.start(noteTime);
                    osc.stop(noteTime + noteLen + 0.03);
                });
                // --- –ú–µ—Å—Ç–æ –¥–ª—è –∂–∏–≤—ã—Ö —Å—ç–º–ø–ª–æ–≤ –ø–∏–∞–Ω–æ/—ç–ª–µ–∫—Ç—Ä–æ/–∞—Ä–ø–µ–¥–∂–∏–æ ---
                // –ü—Ä–∏–º–µ—Ä:
                // const sampleSource = musicCtx.createBufferSource();
                // sampleSource.buffer = pianoLineBuffers[chord.name + '_' + currentGenre]; // AudioBuffer —Å—ç–º–ø–ª–∞
                // sampleSource.connect(masterGain);
                // sampleSource.start(time);
                // –î–ª—è electro –º–æ–∂–Ω–æ –ø–æ–¥–≥—Ä—É–∂–∞—Ç—å –≥–æ—Ç–æ–≤—ã–µ –∞—Ä–ø–µ–¥–∂–∏–æ-—Å—ç–º–ø–ª—ã!
            }

            // --- –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö —Å–ª–æ—ë–≤ ---
            function scheduler() {
                while (nextNoteTime < musicCtx.currentTime + scheduleAheadTime) {
                    // Swing timing (–¥–ª—è jazz)
                    let scheduledNoteTime = nextNoteTime;
                    if (currentGenre === 'jazz' && swing > 0 && (step % 2 === 1)) {
                        scheduledNoteTime += swing * quarter/2;
                    }
                    // –ë–∏—Ç –ø–æ –∂–∞–Ω—Ä–æ–≤–æ–º—É –ø–∞—Ç—Ç–µ—Ä–Ω—É
                    scheduleKick(scheduledNoteTime, step);
                    // –ò–Ω–æ–≥–¥–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è ghost kick –º–µ–∂–¥—É —É–¥–∞—Ä–∞–º–∏ (—Å–¥–≤–∏–≥ –Ω–∞ 16-32% quarter)
                    if (Math.random() < 0.4) {
                        let ghostTime = scheduledNoteTime + (quarter * (0.16 + Math.random()*0.16));
                        maybeScheduleRandomKick(ghostTime);
                    }
                    // –ê–∫–∫–æ—Ä–¥ –Ω–∞ –ø–µ—Ä–≤—ã–π —É–¥–∞—Ä —Ç–∞–∫—Ç–∞ (—Ä–∞–∑ –≤ –¥–ª–∏–Ω—É –ø–∞—Ç—Ç–µ—Ä–Ω–∞)
                    if (step % beatPattern.length === 0) {
                        const chord = chordDefs[chordIdx % chordDefs.length];
                        const activeChord =
                            (currentGenre === 'ambient' || musicGenome.harmony > 0.6)
                                ? mellowChord(chord)
                                : chord;
                        scheduleChord(scheduledNoteTime, activeChord);
                        schedulePianoLine(scheduledNoteTime, activeChord);
                        chordIdx++;
                    }
                    nextNoteTime += quarter;
                    step++;
                }
                if (musicPlaying) setTimeout(scheduler, 50);
            }
            scheduler();
        }

        function stopMusic() {
            musicPlaying = false;
            if (beatOsc) beatOsc.stop();
            if (midiSynth) midiSynth.stop();
            if (granularEngine) granularEngine.stop();
        }

        // –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–¥ mood –∏ curiosity
        setInterval(() => {
            neuralMorph(musicGenome);

            // --- Memory Palace: stimulate and get emergent memories ---
            const emergentMemories = memoryPalace.stimulate({
                emotion: (typeof selfAwareness?.mood === 'number' ? (selfAwareness.mood + 1) / 2 : 0.5) || 0.5,
                context: [typeof currentMode !== 'undefined' ? currentMode : '', typeof currentGenre !== 'undefined' ? currentGenre : '']
            });

            const newLP = 600 + musicGenome.brightness * 8000;
            masterLP.frequency.linearRampToValueAtTime(
                newLP,
                musicCtx.currentTime + 1.5
            );
            if (!musicPlaying) return;
            let moodFactor = Math.min(1, Math.max(0, selfAwareness.mood + 0.5));
            if (beatOsc) beatOsc.frequency.setValueAtTime(80 + 80 * moodFactor, musicCtx.currentTime);
            if (midiSynth) midiSynth.detune.setValueAtTime((Math.random() - 0.5) * 100 * moodFactor, musicCtx.currentTime);
        }, 5000);

        // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å orb
        orb.addEventListener('click', () => {
            if (musicCtx.state === 'suspended') musicCtx.resume();
            startMusic();
        });
        orbInteractive.addEventListener('click', () => {
            if (musicCtx.state === 'suspended') musicCtx.resume();
            startMusic();
        });
       
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        // === –ú—É–ª—å—Ç–∏—è–∑—ã—á–Ω—ã–µ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ===
        let currentLang = 'ru-RU';
        let currentVoice = null;
        let availableVoices = [];
        // –°–ø–∏—Å–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã—Ö —è–∑—ã–∫–æ–≤ (—Ä–∞—Å—à–∏—Ä—è–µ–º –ø–æ –º–µ—Ä–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
        const supportedLangs = [
            { code: 'ru-RU', name: '–†—É—Å—Å–∫–∏–π' },
            { code: 'en-US', name: 'English' },
            { code: 'de-DE', name: 'Deutsch' },
            { code: 'fr-FR', name: 'Fran√ßais' },
            { code: 'es-ES', name: 'Espa√±ol' },
            { code: 'zh-CN', name: '‰∏≠Êñá' }
        ];
        recognition.lang = currentLang;
        recognition.interimResults = true; // –í–∫–ª—é—á–∞–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —Ä–µ–∞–ª—Ç–∞–π–º –æ–±—Ä–∞–±–æ—Ç–∫–∏
        recognition.continuous = false;

        const synth = window.speechSynthesis;
        let isSpeaking = false;
        let isThinking = false;
        let isChatMode = false;
        let isListening = false;

        // === SpeechSynthesis Voices Loader ===
        function updateVoices() {
            availableVoices = synth.getVoices();
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–±–∏—Ä–∞–µ–º –≥–æ–ª–æ—Å –ø–æ–¥ —Ç–µ–∫—É—â–∏–π —è–∑—ã–∫
            if (availableVoices.length > 0) {
                // –ò—â–µ–º –≥–æ–ª–æ—Å, –≥–¥–µ lang —Å–æ–≤–ø–∞–¥–∞–µ—Ç (—Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º female, –ø–æ—Ç–æ–º male)
                let voice = availableVoices.find(v => v.lang === currentLang && /female|–∂–µ–Ω|woman|frau|–∂–µ–Ω—Å–∫–∏–π/i.test(v.name));
                if (!voice) voice = availableVoices.find(v => v.lang === currentLang);
                if (!voice) voice = availableVoices[0];
                currentVoice = voice;
            }
        }
        if (typeof synth.onvoiceschanged !== "undefined") {
            synth.onvoiceschanged = updateVoices;
        }
        updateVoices();

        // === –Ø–∑—ã–∫–æ–≤–æ–π –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç –ø–æ —Ç–µ–∫—Å—Ç—É ===
        function detectLanguage(text) {
            // –ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–π –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç: –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É
            if (/[–∞-—è—ë]/i.test(text)) return 'ru-RU';
            if (/[a-z]/i.test(text)) return 'en-US';
            if (/[√§√∂√º√ü]/i.test(text) || /\b(und|der|die|das|ist|nicht)\b/i.test(text)) return 'de-DE';
            if (/[√©√®√™√†√ß]/i.test(text) || /\b(le|la|les|est|pas|une|un)\b/i.test(text)) return 'fr-FR';
            if (/[√±√°√©√≠√≥√∫]/i.test(text) || /\b(el|la|los|es|una|uno)\b/i.test(text)) return 'es-ES';
            if (/[\u4e00-\u9fff]/.test(text)) return 'zh-CN';
            return currentLang; // fallback
        }

        // === –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —è–∑—ã–∫–∞ –¥–ª—è SpeechRecognition –∏ SpeechSynthesis ===
        function setLanguage(lang) {
            currentLang = lang;
            recognition.lang = lang;
            updateVoices();
        }

        // === Gender memory ===
        let userGender = localStorage.getItem('user_gender') || null;

        function setGender(g) {
            userGender = g;
            localStorage.setItem('user_gender', g);
        }
        

        function vibrate(pattern) {
            if (tg?.HapticFeedback) {
                if (pattern === 'light') tg.HapticFeedback.impactOccurred('light');
                else if (pattern === 'medium') tg.HapticFeedback.impactOccurred('medium');
                else if (pattern === 'heavy') tg.HapticFeedback.impactOccurred('heavy');
            } else if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        // --- Listening vibration "breathing" ---
        let listeningVibrationInterval = null;

        function startListeningVibration() {
            stopListeningVibration();
            if (tg?.HapticFeedback) {
                listeningVibrationInterval = setInterval(() => {
                    tg.HapticFeedback.impactOccurred('light');
                }, 800 + Math.random() * 100);
            } else if (navigator.vibrate) {
                listeningVibrationInterval = setInterval(() => {
                    navigator.vibrate([20, 100]);
                }, 800 + Math.random() * 100);
            }
        }

        function stopListeningVibration() {
            if (listeningVibrationInterval) {
                clearInterval(listeningVibrationInterval);
                listeningVibrationInterval = null;
            }
        }

        function startListening() {
            if (isSpeaking || isThinking) return;
            isListening = true;
            if (isSpeaking || isThinking || isChatMode) return;
    
            // –ü–ª–∞–≤–Ω–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            orb.classList.remove('speaking', 'thinking');
    
            requestAnimationFrame(() => {
                orb.classList.add('listening');
                status.innerText = "listening";
            });
    
            // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –≤–∏–±—Ä–∞—Ü–∏–∏ –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
            setTimeout(() => {
                startListeningVibration();

                // –ó–∞–ø—É—Å–∫ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
                setTimeout(() => {
                    try {
                        recognition.start();
                    } catch (e) {
                        // –ï—Å–ª–∏ –æ—à–∏–±–∫–∞, –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ 1 —Å–µ–∫—É–Ω–¥—É
                        setTimeout(startListening, 1000);
                    }
                }, 50);
            }, 150);
        }
        
        // === –ï–¥–∏–Ω—ã–π –º—É–ª—å—Ç–∏—è–∑—ã—á–Ω—ã–π onresult —Å –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ–º –∏ –≥–æ–ª–æ—Å–æ–≤—ã–º–∏ –∫–æ–º–∞–Ω–¥–∞–º–∏ ===
        // Append transcript with full Markdown/code support, triple backticks and Prism.js highlighting
        // –ù–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç appendTranscript: –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –±–ª–æ–∫–æ–≤ –∫–æ–¥–∞ —Å –æ–±—Ä–∞—Ç–Ω—ã–º–∏ –∫–∞–≤—ã—á–∫–∞–º–∏ –∏ Prism.js
        function appendTranscript(text) {
            // Utility to escape HTML
            function escapeHTML(str) {
                return str.replace(/[&<>"']/g, ch =>
                    ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch]));
            }

            // Markdown renderer for inline code, bold, italic, links, tables
            function renderMarkdown(str) {
                let html = escapeHTML(str);
                // Inline code: `code`
                html = html.replace(/`([^`]+?)`/g, '<code class="lang-inline">$1</code>');
                // Bold: **text**
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<b>$1</b>');
                // Italic: *text*
                html = html.replace(/\*([^\*]+)\*/g, '<i>$1</i>');
                // Links: [text](url)
                html = html.replace(/\[([^\]]+)\]\((https?:\/\/[^\)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
                // Tables: markdown to HTML
                html = html.replace(
                    /((?:^\s*\|.*\|\s*\n)+^\s*\|?(?:\s*:?-+:?\s*\|)+\s*\n(?:^\s*\|.*\|\s*\n?)+)/gm,
                    function(tableBlock) {
                        let lines = tableBlock.trim().split('\n').filter(l => l.trim().length > 0);
                        if (lines.length < 2) return tableBlock;
                        let headerLine = lines[0];
                        let sepLine = lines[1];
                        if (!/\|/.test(sepLine) || !/-/.test(sepLine)) return tableBlock;
                        let dataLines = lines.slice(2);
                        let headers = headerLine.split('|').map(cell => cell.trim()).filter(Boolean);
                        let rows = dataLines.map(row =>
                            row.split('|').map(cell => cell.trim()).filter((_,i) => i < headers.length)
                        );
                        let out = '<table style="border-collapse:collapse; margin:8px 0; background:rgba(40,40,60,0.92); border-radius:7px; overflow:hidden; font-size:1em;">';
                        out += '<thead><tr>';
                        for (let h of headers) {
                            out += `<th style="border:1px solid #888;padding:6px 12px;background:rgba(60,60,90,0.92);color:#fff;">${h}</th>`;
                        }
                        out += '</tr></thead><tbody>';
                        for (let row of rows) {
                            out += '<tr>';
                            for (let i = 0; i < headers.length; ++i) {
                                out += `<td style="border:1px solid #888;padding:6px 12px;color:#eee;">${row[i]||''}</td>`;
                            }
                            out += '</tr>';
                        }
                        out += '</tbody></table>';
                        return out;
                    }
                );
                return html;
            }

            // Parse text into segments: plain and code blocks (```)
            let html = '';
            const blockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            let lastIndex = 0;
            let match;
            let pieces = [];
            while ((match = blockRegex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    pieces.push({ type: 'text', value: text.slice(lastIndex, match.index) });
                }
                pieces.push({ type: 'code', lang: match[1] || '', code: match[2] });
                lastIndex = blockRegex.lastIndex;
            }
            if (lastIndex < text.length) {
                pieces.push({ type: 'text', value: text.slice(lastIndex) });
            }
            // Render segments
            for (let part of pieces) {
                if (part.type === 'text') {
                    html += renderMarkdown(part.value);
                } else if (part.type === 'code') {
                    const langClass = part.lang ? `language-${escapeHTML(part.lang.toLowerCase())}` : '';
                    html += `<div class="code-block-wrapper" style="max-width:100%;overflow-x:auto;background:rgba(40,40,60,0.92);border-radius:7px;margin:8px 0;"><pre style="margin:0;padding:10px 12px;font-size:1em;"><code class="${langClass}">${escapeHTML(part.code.replace(/\s+$/, ""))}</code></pre></div>`;
                }
            }
            // Prepend "You:" label, insert into transcriptDiv, and scroll to bottom
            html = `<span style="color: rgba(255,255,255,0.7)">You:</span> ${html}`;
            // Only update the last "You:" transcript, not the whole transcriptDiv (if multiple user messages)
            // Find the last "You:" span and replace its parent innerHTML, else append
            let found = false;
            if (transcriptDiv && transcriptDiv.children && transcriptDiv.children.length > 0) {
                // Try to find last "You:" span
                for (let i = transcriptDiv.children.length - 1; i >= 0; --i) {
                    const el = transcriptDiv.children[i];
                    if (el.tagName === 'SPAN' && el.textContent && el.textContent.trim().startsWith('You:')) {
                        el.parentNode.innerHTML = html;
                        found = true;
                        break;
                    }
                }
            }
            if (!found && transcriptDiv) {
                transcriptDiv.innerHTML = html;
            }
            // Prism.js highlighting
            if (window.Prism && Prism.highlightAll) {
                Prism.highlightAll();
            } else if (window.Prism && Prism.highlightElement) {
                transcriptDiv.querySelectorAll('code[class^="language-"], code[class*=" language-"]').forEach(function(block) {
                    Prism.highlightElement(block);
                });
            }
            transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
        }

        // onresult: 
        recognition.onresult = async (event) => {
            let interimTranscript = '';
            let finalTranscript = '';
            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–µ–≥–º–µ–Ω—Ç—ã
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                const res = event.results[i];
                if (res.isFinal) {
                    finalTranscript += res[0].transcript;
                } else {
                    interimTranscript += res[0].transcript;
                }
            }
            // ---
            if (interimTranscript && interimTranscript.trim()) {
                appendTranscript(interimTranscript);
              
                Array.from(chatMessages.querySelectorAll('.chat-message.user.interim')).forEach(el => el.remove());
                const msgDiv = document.createElement('div');
                msgDiv.className = 'chat-message user interim';
                const senderDiv = document.createElement('div');
                senderDiv.className = 'sender';
                senderDiv.textContent = 'You';
                const textDiv = document.createElement('div');
                textDiv.className = 'text';
                msgDiv.appendChild(senderDiv);
                msgDiv.appendChild(textDiv);
                chatMessages.appendChild(msgDiv);

                textDiv.innerHTML = '';
                typeChatMessage(interimTranscript, textDiv);
          
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
          
            else if (finalTranscript && finalTranscript.trim()) {
                appendTranscript(finalTranscript);
            }

          
            if (finalTranscript && finalTranscript.trim()) {
                const text = finalTranscript.trim();
            
                appendTranscript(text);
           
             
                Array.from(chatMessages.querySelectorAll('.chat-message.user.interim')).forEach(el => el.remove());
                const msgDiv = document.createElement('div');
                msgDiv.className = 'chat-message user finalized';
                const senderDiv = document.createElement('div');
                senderDiv.className = 'sender';
                senderDiv.textContent = 'You';
                const textDiv = document.createElement('div');
                textDiv.className = 'text';
                msgDiv.appendChild(senderDiv);
                msgDiv.appendChild(textDiv);
                chatMessages.appendChild(msgDiv);

                textDiv.innerHTML = '';
                typeChatMessage(text, textDiv);
          
                msgDiv.onclick = () => {
                    navigator.clipboard.writeText(text).then(() => {
                        msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                        setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
                    });
                };

            
                const detectedLang = detectLanguage(text);
                if (detectedLang !== currentLang) {
                    setLanguage(detectedLang);
                }

     
              
                if (/\b(–≥–æ–≤–æ—Ä–∏ –ø–æ-—Ä—É—Å—Å–∫–∏|—Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫|–ø–µ—Ä–µ–∫–ª—é—á–∏ –Ω–∞ —Ä—É—Å—Å–∫–∏–π)\b/i.test(text)) {
                    setLanguage('ru-RU');
                    speak("–Ø –ø–µ—Ä–µ–∫–ª—é—á–∏–ª–∞—Å—å –Ω–∞ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫.");
                    return;
                }
              
                if (/\b(speak english|english language|switch to english)\b/i.test(text)) {
                    setLanguage('en-US');
                    speak("I switched to English.");
                    return;
                }
               
                if (/\b(sprich deutsch|deutsche sprache|auf deutsch)\b/i.test(text)) {
                    setLanguage('de-DE');
                    speak("Ich spreche jetzt Deutsch.");
                    return;
                }
               
                if (/\b(parle fran√ßais|langue fran√ßaise|en fran√ßais)\b/i.test(text)) {
                    setLanguage('fr-FR');
                    speak("Je parle maintenant fran√ßais.");
                    return;
                }
          
                if (/\b(habla espa√±ol|idioma espa√±ol|en espa√±ol)\b/i.test(text)) {
                    setLanguage('es-ES');
                    speak("Ahora hablo espa√±ol.");
                    return;
                }
           
                if (/\b(ËØ¥‰∏≠Êñá|‰∏≠Êñá|ËÆ≤‰∏≠Êñá)\b/i.test(text)) {
                    setLanguage('zh-CN');
                    speak("ÊàëÁé∞Âú®ËØ¥‰∏≠Êñá„ÄÇ");
                    return;
                }

              
                if (/\b(–≤–∫–ª—é—á–∏ –º—É–∑—ã–∫—É|–º—É–∑—ã–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞|—Å—Ç–∞—Ä—Ç –º—É–∑—ã–∫–∏|play music|start music)\b/i.test(text)) {
                    if (!musicPlaying) {
                        if (musicCtx.state === 'suspended') await musicCtx.resume();
                        startMusic();
                    }
                    return;
                }
       
                if (/\b(–≤–∫–ª—é—á–∏ –∫–∞–º–µ—Ä—É|–ø–æ–∫–∞–∂–∏ –∫–∞–º–µ—Ä—É|–æ—Ç–∫—Ä–æ–π –∫–∞–º–µ—Ä—É|–∫–∞–º–µ—Ä–∞|show camera|open camera|start camera)\b/i.test(text)) {
                    if (cameraVideo.style.display !== 'block') {
                        startCamera(currentCamera);
                        cameraEnabled = true;
                    }
                }
                if (/\b(–≤—ã–∫–ª—é—á–∏ –∫–∞–º–µ—Ä—É|–∑–∞–∫—Ä–æ–π –∫–∞–º–µ—Ä—É|—Å–∫—Ä–æ–π –∫–∞–º–µ—Ä—É|—É–±–µ—Ä–∏ –∫–∞–º–µ—Ä—É|hide camera|close camera|stop camera)\b/i.test(text)) {
                    if (cameraVideo.style.display === 'block') {
                        stopCamera();
                        cameraEnabled = false;
                    }
                }
                if (/\b(–ø–µ—Ä–µ–∫–ª—é—á–∏ –∫–∞–º–µ—Ä—É|—Å–º–µ–Ω–∏—Ç—å –∫–∞–º–µ—Ä—É|–¥—Ä—É–≥–∞—è –∫–∞–º–µ—Ä–∞|–ø–µ—Ä–µ–≤–µ—Ä–Ω–∏ –∫–∞–º–µ—Ä—É|switch camera|change camera)\b/i.test(text)) {
                    switchCamera();
                }

                // –ì–æ–ª–æ—Å–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è ambient
                const ambientTriggerWords = ['—Å—Ç–∞—Ä—Ç', '–º—É–∑—ã–∫–∞', 'ambient', '–∑–≤—É–∫–∏', 'soundscape', 'nature sounds'];
                if (ambientTriggerWords.some(word => text.toLowerCase().includes(word))) {
                    triggerAmbient();
                }

                vibrate('medium');
                // simple voice gender commands
                if (/\b(—è –¥–µ–≤—É—à–∫–∞|—è –∂–µ–Ω—â–∏–Ω–∞)\b/i.test(text)) setGender('female');
                if (/\b(—è –ø–∞—Ä–µ–Ω—å|—è –º—É–∂—á–∏–Ω–∞)\b/i.test(text)) setGender('male');
                if (/\b(—è –Ω–µ–±–∏–Ω–∞—Ä–Ω—ã–π|—è –Ω–µ–±–∏–Ω–∞—Ä–Ω–∞—è)\b/i.test(text)) setGender('nonbinary');

                await sendToBot(text);
                await generateImageFromText(text);

                // ‚õîÔ∏è –°–†–ê–ó–£ –°–¢–û–ü–ê–ï–ú –°–õ–£–®–ê–ù–ò–ï –ü–û–°–õ–ï –§–ò–ù–ê–õ–¨–ù–û–ô –§–†–ê–ó–´
                isListening = false;
                try { recognition.stop(); } catch(e){}
            }
        };
        // === Web/Telegram Session ID (unified) ===
        const WEB_SESSION_KEY = 'web_fake_user_id';

        function resolveUserId() {
          // 1) Telegram ‚Üí —Å—Ä–∞–∑—É —á–∏—Å–ª–æ
          const tgId =
            window.Telegram?.WebApp?.initDataUnsafe?.user?.id;
          if (tgId) {
            return String(tgId); // —Å—Ç—Ä–æ–∫–∞ —Å —á–∏—Å–ª–æ–º, –æ–∫
          }

          // 2) Web ‚Üí –≥–µ–Ω–µ—Ä–∏–º –ß–ò–°–õ–û –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º
          let id = localStorage.getItem(WEB_SESSION_KEY);
          if (!id) {
            id = String(
              Date.now() * 1000 + Math.floor(Math.random() * 1000)
            ); // –í–°–ï–ì–î–ê –ß–ò–°–õ–û
            localStorage.setItem(WEB_SESSION_KEY, id);
          }
          return id;
        }

let user_id = resolveUserId();

function getSafeUserId() {
  let uid = Number(user_id);
  if (Number.isInteger(uid)) return uid;

  // –∂—ë—Å—Ç–∫–∏–π fallback –¥–ª—è browser
  uid = Date.now() * 1000 + Math.floor(Math.random() * 1000);
  user_id = String(uid);

  try {
    localStorage.setItem(WEB_SESSION_KEY, user_id);
  } catch (e) {}

  return uid;
}

        // üîÅ Telegram –º–æ–∂–µ—Ç –ø—Ä–æ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ–∑–∂–µ
        setTimeout(() => {
          const tgId =
            window.Telegram?.WebApp?.initDataUnsafe?.user?.id;

          if (tgId && String(user_id) !== String(tgId)) {
            user_id = String(tgId);
            console.log('[sync] Telegram userID synced:', user_id);
          }
        }, 800);



        async function generateImageFromText(text) {
            if (!text || !text.trim()) return;
            try {
                const response = await fetch("/api/generate_image", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ user_id: getSafeUserId(), prompt: text })
                });
                const data = await response.json();
                generatedImg.src = "data:image/png;base64," + data.image_base64;
            } catch (e) {
                console.error(e);
            }
        }
        
        recognition.onerror = () => {
            if (!isChatMode && !isSpeaking && !isThinking) {
                setTimeout(startListening, 1500);
            }
        };
        
        recognition.onend = () => {
            if (isSpeaking || isThinking || isChatMode) return;
            orb.classList.remove('listening');
            startListening();
        };
        
        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –±—É—Ñ–µ—Ä–∞ —Ä–µ—á–∏
        let audioBuffer = "";
        let spokenLength = 0; // —Å–∫–æ–ª—å–∫–æ —Å–∏–º–≤–æ–ª–æ–≤ —É–∂–µ –æ—Ç–¥–∞–Ω–æ –≤ —Ä–µ—á—å
        let chatTypingQueue = Promise.resolve();
        let orbTypingQueue = Promise.resolve();

        // === Orb Bounce Animation ===
        let bounceInterval = null;
        function startOrbBounce() {
            stopOrbBounce();
            let orbElem = orb;
            if (!orbElem) return;
            bounceInterval = setInterval(() => {
                orbElem.classList.add('bouncing');
                setTimeout(() => {
                    orbElem.classList.remove('bouncing');
                }, 420);
            }, 900 + Math.random() * 320);
        }
        function stopOrbBounce() {
            if (bounceInterval) {
                clearInterval(bounceInterval);
                bounceInterval = null;
            }
            if (orb) orb.classList.remove('bouncing');
        }
    // --- Haptic feedback: Vibration patterns for thinking/speaking ---
    let thinkingVibrationInterval = null;
    let speakingVibrationInterval = null;

    function startThinkingVibration() {
        stopThinkingVibration();
        if (tg?.HapticFeedback) {
            thinkingVibrationInterval = setInterval(() => {
                tg.HapticFeedback.impactOccurred('light');
            }, 500);
        } else if (navigator.vibrate) {
            thinkingVibrationInterval = setInterval(() => {
                navigator.vibrate([30, 170]);
            }, 500);
        }
    }

    function stopThinkingVibration() {
        if (thinkingVibrationInterval) {
            clearInterval(thinkingVibrationInterval);
            thinkingVibrationInterval = null;
        }
    }

    function vibrateSpeaking() {
        stopThinkingVibration();
        stopSpeakingVibration();
    
        if (tg?.HapticFeedback) {
            // –ë–æ–ª–µ–µ –ª–µ–≥–∫–∞—è –∏ —Ä–µ–¥–∫–∞—è –≤–∏–±—Ä–∞—Ü–∏—è
            speakingVibrationInterval = setInterval(() => {
                const levels = ['light', 'light', 'medium']; // 66% light, 33% medium
                tg.HapticFeedback.impactOccurred(levels[Math.floor(Math.random() * levels.length)]);
            }, 200 + Math.random() * 150); // 200-350ms –º–µ–∂–¥—É –≤–∏–±—Ä–∞—Ü–∏—è–º–∏
        } else if (navigator.vibrate) {
            speakingVibrationInterval = setInterval(() => {
                navigator.vibrate([15, 10]); // –ö–æ—Ä–æ—Ç–∫–∏–µ –∏–º–ø—É–ª—å—Å—ã
            }, 250);
        }
    }

    function stopSpeakingVibration() {
        if (speakingVibrationInterval) {
            clearInterval(speakingVibrationInterval);
            speakingVibrationInterval = null;
        }
    }

    // === External Search Context Buffer (from frontend search) ===
    window.externalSearchContext = [];

    function pushExternalSearchContext(entry) {
        if (!entry) return;
        window.externalSearchContext.push({
            ts: Date.now(),
            data: entry
        });
        // keep buffer small
        if (window.externalSearchContext.length > 12) {
            window.externalSearchContext.shift();
        }
    }

    async function sendToBot(text) {
        isListening = false;
        isChatMode = true;
        try { recognition.abort(); } catch(e){}
        stopListeningVibration(); // –æ—Ç–∫–ª—é—á–∞–µ–º –¥—ã—Ö–∞–Ω–∏–µ, –∫–æ–≥–¥–∞ –ò–ò –¥—É–º–∞–µ—Ç –∏–ª–∏ –≥–æ–≤–æ—Ä–∏—Ç
        if (window.recognition && recognition.abort) {
            try { recognition.abort(); } catch(e){}
        }
        isThinking = true;
        orb.classList.remove('listening');
        orb.classList.add('thinking');
        status.innerText = "processing stream";
        // --- —Ç–∞–π–º–µ—Ä—ã —Å—Ç–∞—Ç—É—Å–∞ –¥–ª—è –¥–ª–∏–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ ---
        let processingTimeout = setTimeout(() => {
            status.innerText = "thinking";
        }, 10000); // —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥

        let researchingTimeout = setTimeout(() => {
            status.innerText = "preparing answer";
        }, 20000); // —á–µ—Ä–µ–∑ 20 —Å–µ–∫—É–Ω–¥
        startThinkingVibration();

        // --- Orb bounce animation start ---
        startOrbBounce();

        // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ UI —Å –∫—É—Ä—Å–æ—Ä–æ–º
        let responseContainer = document.getElementById("current-response");

        if (!responseContainer) {
            transcriptDiv.innerHTML += `<br><br><span style="color: rgba(255,255,255,0.7)">AI:</span> <span id="current-response" class="typing-cursor"></span>`;
            responseContainer = document.getElementById("current-response");
        } else {
            responseContainer.innerHTML = '';
            responseContainer.classList.add('typing-cursor');
        }
        audioBuffer = "";
        spokenLength = 0;
        // === FULL AI TEXT accumulator ===
        let fullAIText = '';
            // --- sDelay-driven speech sync ---
            let speechStarted = false;
            const speechDelayMs = 420; // –±–∞–∑–æ–≤–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ ¬´–≤—è–∑–∫–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏¬ª

            try {
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã –≤ —Å–∫–æ–±–∫–∞—Ö, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
                let textWithContext = text;
                if (latestCameraDescription && latestCameraDescription.trim() !== "") {
                    textWithContext = text + " (" + latestCameraDescription + ")";
                }
                // –î–æ–±–∞–≤–ª—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏ self-awareness
                if(internalNotes.length > 0) textWithContext += " | Notes: " + internalNotes.join("; ");

                // Gather extended context for payload
                const recentNotes = internalNotes.slice(-8);
                const musicContext = {
                    genre: currentGenre,
                    genome: musicGenome,
                    aiNotes: (typeof currentAINotes !== 'undefined') ? currentAINotes.slice(-12) : [],
                    playing: !!musicPlaying
                };
                const memoryContext = (typeof memoryPalace !== 'undefined' && typeof memoryPalace.getRecentNodes === 'function')
                    ? memoryPalace.getRecentNodes(8)
                    : [];
                const selfAwarenessContext = (typeof selfAwareness !== 'undefined') ? selfAwareness : {};

                const payload = {
                    user_id: getSafeUserId(),
                    text: textWithContext,
                    gender: userGender,
                    lang: currentLang,
                    notes: recentNotes,
                    music: musicContext,
                    memory: memoryContext,
                    self_awareness: selfAwarenessContext,
                    external_context: window.externalSearchContext.slice(-6)
                };

                const response = await fetch(
                    'https://patronal-mayme-unexpandable.ngrok-free.dev/api/voice_chat',
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'ngrok-skip-browser-warning': 'true'
                        },
                        body: JSON.stringify(payload)
                    }
                );

                // clear external context after successful handoff to backend
                window.externalSearchContext = [];

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                isThinking = false;
                orb.classList.remove('thinking');
                stopThinkingVibration();
                orb.classList.add('speaking');
                status.innerText = "receiving data";
                vibrateSpeaking();

                // --- Orb bounce animation stop at start of AI message ---
                stopOrbBounce();

        let chatShouldStick = stickChatToBottom(chatMessages);
        // === HARD INIT AI CHAT MESSAGE (fix missing chat bug) ===
        if (!window._chatStreamMsg) {
            const msgDiv = document.createElement('div');
            msgDiv.className = 'chat-message ai';
            msgDiv.innerHTML = `
              <div class="sender">AI</div>
              <div class="text"></div>
            `;
            chatMessages.appendChild(msgDiv);
            window._chatStreamMsg = msgDiv.querySelector('.text');
            window._chatStreamPrinted = 0;
        }
        // === STREAM TO CHAT (AI) ===
// --- GLOBAL AI TYPING LOCK ---
if (window.__aiTypingLock) {
    // –∂—ë—Å—Ç–∫–æ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –æ—á–µ—Ä–µ–¥–∏
    chatTypingQueue = Promise.resolve();
    orbTypingQueue = Promise.resolve();
}
window.__aiTypingLock = true;
        window._chatStreamBuffer = '';
        // window._chatStreamMsg is now pre-initialized above
        window._chatStreamHasText = false;
        window._chatStreamPrinted = 0;

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            fullAIText += chunk;
            window._chatStreamBuffer += chunk;

            const printed = window._chatStreamPrinted || 0;
            const full = window._chatStreamBuffer;
            const delta = full.slice(printed);

            // —Å—á–∏—Ç–∞–µ–º –õ–Æ–ë–û–ô —Ç–µ–∫—Å—Ç, –¥–∞–∂–µ –µ—Å–ª–∏ —ç—Ç–æ –ø—Ä–æ–±–µ–ª—ã –∏–ª–∏ –ø–µ—Ä–µ–Ω–æ—Å—ã
            // (no need to create .chat-message here anymore, handled above)

            if (delta.length > 0) {
                window._chatStreamHasText = true;
            }

            if (delta.length > 0 && window._chatStreamMsg) {
                const nextPrinted = full.length;
                chatShouldStick = stickChatToBottom(chatMessages);
                chatTypingQueue = chatTypingQueue.then(() => {
                    return typeWriterWordsEffect(window._chatStreamMsg, delta).then(() => {
                        window._chatStreamPrinted = nextPrinted;
                        if (chatShouldStick) chatMessages.scrollTop = chatMessages.scrollHeight;
                    });
                });
            }

            // –ü–µ—á–∞—Ç–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞: —Ç–µ–ø–µ—Ä—å –ø–µ—á–∞—Ç–∞–µ–º –ø–æ —Å–ª–æ–≤–∞–º —Ü–µ–ª–∏–∫–æ–º —Å –ø–æ–º–æ—â—å—é typeWriterEffect
            if (responseContainer) {
                orbTypingQueue = orbTypingQueue.then(() =>
                    typeWriterEffect(responseContainer, chunk, {
                        charDelay: 6,
                        wordPause: 0
                    })
                );
                // –ú–∏–∫—Ä–æ–ø–∞—É–∑a –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–∞—Ö —Ñ—Ä–∞–∑
                if (/[.!?\n]/.test(chunk)) {
                    orbTypingQueue = orbTypingQueue.then(() =>
                        new Promise(r => setTimeout(r, 40 + Math.random() * 40))
                    );
                }
            }

            // –ö–æ–ø–∏–º –¥–ª—è –æ–∑–≤—É—á–∫–∏
            audioBuffer += chunk;

            if (!speechStarted) {
                speechStarted = true;

                // —Å—á–∏—Ç–∞–µ–º –ø–µ—Ä–≤—ã–π —á–∞–Ω–∫ —É–∂–µ –æ–∑–≤—É—á–µ–Ω–Ω—ã–º,
                // —á—Ç–æ–±—ã –æ–Ω –Ω–µ –ø–æ–ø–∞–ª –≤ delta –∏ –Ω–µ —Å–∫–∞–∑–∞–ªc—è –≤—Ç–æ—Ä–æ–π —Ä–∞–∑
                spokenLength = audioBuffer.length;

                setTimeout(() => {
                    speak(chunk);
                }, 120);
            }

            if (speechStarted) {
                const delta = audioBuffer.slice(spokenLength);

                // –≥–æ–≤–æ—Ä–∏–º –≤—Å—ë, –Ω–µ –∂–¥—ë–º –ø—É–Ω–∫—Ç—É–∞—Ü–∏—é
                if (delta.length > 6) {
                    spokenLength = audioBuffer.length;
                    speak(delta);
                }
            }
        }

        // === FINAL FLUSH: –∂–µ–ª–µ–∑–æ–±–µ—Ç–æ–Ω–Ω—ã–π commit ===
        await chatTypingQueue;

        if (window._chatStreamMsg) {
            const printed = window._chatStreamPrinted || 0;
            const tail = fullAIText.slice(printed);
            if (tail && tail.length > 0) {
                window._chatStreamMsg.textContent += tail;
                window._chatStreamPrinted = fullAIText.length;
            }
        }
        window._chatStreamHasText = false;
        window._chatStreamBuffer = '';
        window._chatStreamMsg = null;
        window._chatStreamPrinted = 0;
        orbTypingQueue = Promise.resolve();

        window.__aiTypingLock = false;

        if (responseContainer) {
            responseContainer.classList.remove("typing-cursor");
        }
        status.innerText = "answering";
        // One strong vibration at the end of receiving
        if (tg?.HapticFeedback) tg.HapticFeedback.impactOccurred('heavy');
        else if (navigator.vibrate) navigator.vibrate([60]);

        // –¥–æ–≥–æ–≤–∞—Ä–∏–≤–∞–µ–º —Ö–≤–æ—Å—Ç, –µ—Å–ª–∏ –æ–Ω –æ—Å—Ç–∞–ª—Å—è
        const tail = audioBuffer.slice(spokenLength);
        if (tail.trim().length > 0) {
            speak(tail);
        }

    } catch (e) {
        console.error(e);
        status.innerText = "stream error";
        orb.classList.remove('thinking');
        orb.classList.remove('speaking');
        isThinking = false;
        isSpeaking = false;
        stopThinkingVibration();
        stopSpeakingVibration();
        stopOrbBounce();
        setTimeout(startListening, 2000);
    } finally {
        clearTimeout(processingTimeout);
        clearTimeout(researchingTimeout);
        // just in case, stop bounce
        stopOrbBounce();
        // === Last-resort commit of fullAIText ===
        if (window._chatStreamMsg && fullAIText) {
            window._chatStreamMsg.textContent = fullAIText;
        }
    }
}

//
// –ù–æ–≤—ã–π typeWriterEffect: –ø–µ—á–∞—Ç–∞–µ—Ç –ø–æ –±—É–∫–≤–∞–º —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π, –±–ª—é—Ä–æ–º –∏ –∞–≤—Ç–æ—Å–∫—Ä–æ–ª–ª–æ–º
// –¢–µ–ø–µ—Ä—å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç *orb-large* –∏ **italic orb**
        function typeWriterEffect(element, text, options = {}) {
            if (window.__aiTypingLock && element.dataset.locked === '1') {
                return Promise.resolve();
            }
            element.dataset.locked = '1';
            let delay = typeof options === "number"
                ? options
                : (options.charDelay ?? 28);
            let wordPause = typeof options === "object" && typeof options.wordPause === "number"
                ? options.wordPause
                : 0;

            // –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã: –æ–±—ã—á–Ω—ã–µ, *–≤—ã–¥–µ–ª–µ–Ω–Ω—ã–µ* –∏ **–∫—É—Ä—Å–∏–≤**
            function parseOrbSegments(str) {
                // –ü–æ–¥–¥–µ—Ä–∂–∫–∞:
                // *text*        -> orb-large
                // **text**      -> orb-large + italic
                let segments = [];
                let lastIndex = 0;
                let re = /(\*\*([^\*\n]+?)\*\*|\*([^\*\n]+?)\*)/g;
                let m;
                while ((m = re.exec(str)) !== null) {
                    if (m.index > lastIndex) {
                        segments.push({ type: 'plain', text: str.slice(lastIndex, m.index) });
                    }
                    if (m[2]) {
                        segments.push({ type: 'orb-italic', text: m[2] });
                    } else if (m[3]) {
                        segments.push({ type: 'orb', text: m[3] });
                    }
                    lastIndex = re.lastIndex;
                }
                if (lastIndex < str.length) {
                    segments.push({ type: 'plain', text: str.slice(lastIndex) });
                }
                return segments;
            }

            return new Promise((resolve) => {
                element.innerHTML = element.innerHTML || '';
                const segments = parseOrbSegments(text);
                let segIdx = 0;
                function typeSegment() {
                    if (segIdx >= segments.length) {
                        delete element.dataset.locked;
                        resolve();
                        return;
                    }
                    const seg = segments[segIdx++];
                    if (seg.type === 'plain') {
                        // –ü–µ—á–∞—Ç–∞–µ–º –ø–æ –±—É–∫–≤–∞–º –æ–±—ã—á–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º (batch + rAF, no setTimeout per char)
                        const chars = Array.from(seg.text);
                        let i = 0;
                        const BATCH = 5;
                        function step() {
                            let n = 0;
                            while (i < chars.length && n < BATCH) {
                                const ch = chars[i++];
                                const span = document.createElement('span');
                                span.className = 'chat-char';
                                span.textContent = ch;
                                element.appendChild(span);
                                n++;
                            }
                            if (element.parentElement) {
                                element.parentElement.scrollTop = element.parentElement.scrollHeight;
                            }
                            if (i < chars.length) {
                                requestAnimationFrame(step);
                            } else {
                                typeSegment();
                            }
                        }
                        requestAnimationFrame(step);
                    } else if (seg.type === 'orb') {
                        // –ü–µ—á–∞—Ç–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–Ω—ã–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç orb-large, —Ç–æ–∂–µ –ø–æ –±—É–∫–≤–∞–º (—á—Ç–æ–±—ã –±—ã–ª–∞ –∞–Ω–∏–º–∞—Ü–∏—è)
                        const chars = Array.from(seg.text);
                        let i = 0;
                        let orbSpan = document.createElement('span');
                        orbSpan.className = 'chat-char orb-large';
                        element.appendChild(orbSpan);
                        function nextOrbChar() {
                            if (i >= chars.length) {
                                typeSegment();
                                return;
                            }
                            let cspan = document.createElement('span');
                            cspan.className = 'chat-char orb-large';
                            cspan.textContent = chars[i++];
                            orbSpan.appendChild(cspan);
                            if (element.parentElement) {
                                element.parentElement.scrollTop = element.parentElement.scrollHeight;
                            }
                            let d = delay;
                            if (wordPause > 0 && chars[i-1] === ' ') {
                                d += wordPause;
                            }
                            setTimeout(nextOrbChar, d);
                        }
                        nextOrbChar();
                    } else if (seg.type === 'orb-italic') {
                        const chars = Array.from(seg.text);
                        let i = 0;
                        let orbSpan = document.createElement('span');
                        orbSpan.className = 'chat-char orb-large orb-italic';
                        element.appendChild(orbSpan);
                        function nextOrbChar() {
                            if (i >= chars.length) {
                                typeSegment();
                                return;
                            }
                            let cspan = document.createElement('span');
                            cspan.className = 'chat-char orb-large orb-italic';
                            cspan.textContent = chars[i++];
                            orbSpan.appendChild(cspan);
                            if (element.parentElement) {
                                element.parentElement.scrollTop = element.parentElement.scrollHeight;
                            }
                            setTimeout(nextOrbChar, delay);
                        }
                        nextOrbChar();
                    }
                }
                typeSegment();
            });
        }

        // CSS –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –±—É–∫–≤ (–¥–æ–±–∞–≤–∏—Ç—å –≤ <head>)
        if (!document.getElementById('chat-char-style')) {
            const style = document.createElement('style');
            style.id = 'chat-char-style';
            style.textContent = `
                .chat-char {
                    display: inline;
                    opacity: 0;
                    filter: blur(3px);
                    transform: translateY(2px);
                    animation: char-appear 0.618s forwards;
                    white-space: pre-wrap;
                }
                @keyframes char-appear {
                    to {
                        opacity: 1;
                        filter: blur(0);
                        transform: translateY(0);
                    }
                }
                .orb-large {
                    font-size: 1.01em;
                    font-weight: bold;
                    text-shadow: 0 0 12px #ffebb2, 0 0 32px #fcd37d66;
                    vertical-align: left;
                    line-height: 1;
                }
                .orb-italic {
                    font-style: italic;
                    opacity: 0.9;
                }
            `;
            document.head.appendChild(style);
        }
        
        // –ì—É–º–∞–Ω–∏–∑–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞: —É–±–∏—Ä–∞–µ—Ç –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã, HTML, —Ä–µ–º–∞—Ä–∫–∏ –∏ markdown-—Å–∏–º–≤–æ–ª—ã
        function humanizeText(text) {
            // —É–±—Ä–∞—Ç—å HTML
            let clean = text.replace(/<[^>]*>/g, '');

            // —É–±—Ä–∞—Ç—å —Ä–µ–º–∞—Ä–∫–∏ –≤ —Å–∫–æ–±–∫–∞—Ö: (—Ç–∏—Ö–æ), (–ø–∞—É–∑–∞), (–≥—É–¥–µ–Ω–∏–µ) –∏ —Ç.–ø.
            // –ø–æ–¥–¥–µ—Ä–∂–∫–∞ –∫—Ä—É–≥–ª—ã—Ö –∏ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–æ–∫
            clean = clean.replace(/\([^)]*\)/g, '');
            clean = clean.replace(/\[[^\]]*\]/g, '');

            // —É–±—Ä–∞—Ç—å markdown-—Å–∏–º–≤–æ–ª—ã
            clean = clean.replace(/[*_#]/g, '');

            // –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø—Ä–æ–±–µ–ª—ã
            clean = clean.replace(/\s+/g, ' ').trim();

            return clean;
        }

        // –ì–æ–≤–æ—Ä–∏—Ç —Ç–µ–∫—Å—Ç, —Ä–∞–∑–±–∏–≤–∞—è –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏
        function triggerOrbClick() {
            const clickEvent = new MouseEvent('click', {
                view: window,
                bubbles: true,
                cancelable: true
            });
            orb.dispatchEvent(clickEvent);
        }

        // === Session Resonance Model ===
        // 0 ‚Ä¶ 1 ‚Äî —Å—Ç–µ–ø–µ–Ω—å —Å–æ–Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å –≤–Ω–∏–º–∞–Ω–∏–µ–º —Å–ª—É—à–∞—Ç–µ–ª—è
        let sessionResonance = 0.0;
        let lastSpeakTime = performance.now();

        function updateSessionResonance() {
            const now = performance.now();
            const dt = Math.min(5000, now - lastSpeakTime);
            lastSpeakTime = now;

            // –º–µ–¥–ª–µ–Ω–Ω—ã–π —Ä–æ—Å—Ç –ø—Ä–∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Ä–µ—á–∏
            const growth = 0.00004 * dt;

            // –ª—ë–≥–∫–∞—è —É—Ç–µ—á–∫–∞, —á—Ç–æ–±—ã —Ä–µ–∑–æ–Ω–∞–Ω—Å –Ω–µ –∑–∞–ª–∏–ø–∞–ª
            const decay = 0.000015 * dt;

            sessionResonance += growth;
            sessionResonance -= decay;

            sessionResonance = Math.max(0, Math.min(1, sessionResonance));
        }

        // === Vocal Temperature Model ===
        // –¥–∏–∞–ø–∞–∑–æ–Ω: -1 (—Ö–æ–ª–æ–¥) ‚Ä¶ +1 (—Ç–µ–ø–ª–æ)
        function computeVocalTemperature() {
            const mood = typeof selfAwareness?.mood === 'number' ? selfAwareness.mood : 0;
            const fatigue = typeof selfAwareness?.fatigue === 'number' ? selfAwareness.fatigue : 0;
            const curiosity = typeof selfAwareness?.curiosity === 'number' ? selfAwareness.curiosity : 0;

            let t =
                mood * 0.6
                - fatigue * 0.4
                + (Math.random() - 0.5) * curiosity * 0.2;

            return Math.max(-1, Math.min(1, t));
        }

        // –ì–æ–≤–æ—Ä–∏—Ç —Ç–µ–∫—Å—Ç —Å –∂–∏–≤—ã–º–∏ –ø–∞—É–∑–∞–º–∏, –º–µ–∂–¥–æ–º–µ—Ç–∏—è–º–∏ –∏ –º–∏–∫—Ä–æ–≤–∞—Ä—å–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≥–æ–ª–æ—Å–∞
        function speak(text) {
            // === 2) –ó–∞—â–∏—Ç–∞ –æ—Ç overlap TTS ===
            isSpeaking = true;
            isListening = false;
            try { recognition.abort(); } catch(e){}
            if (window.recognition && recognition.abort) {
                try { recognition.abort(); } catch(e){}
            }
            if (speechSynthesis.speaking || speechSynthesis.pending) {
                speechSynthesis.cancel();
                setTimeout(() => {}, 30);
            }
            if (!text || !text.trim()) return;

            updateSessionResonance();

            // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ —Ç–µ–∫—É—â–∏–µ –≤–∏–±—Ä–∞—Ü–∏–∏ –∏ –ø—Ä–æ—Ü–µ—Å—Å—ã
            stopListeningVibration();
            stopThinkingVibration();
            stopSpeakingVibration();
            // recognition.abort();

            // –ü–ª–∞–≤–Ω–æ–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
            orb.classList.remove('listening', 'thinking');
            requestAnimationFrame(() => {
                orb.classList.add('speaking');
                status.innerText = "speaking";
                setTimeout(() => {
                    vibrateSpeaking();
                }, 50);
            });
            isSpeaking = true;

            // === Vocal temperature tuning ===
            const vocalTemperature = computeVocalTemperature();
            const resonanceBias = sessionResonance * 0.25;
            let rate = 1.08;
            let pitch = 0.95;
            if (userGender === 'female') pitch += 0.15;
            if (userGender === 'male') pitch -= 0.05;
            if (vocalTemperature < -0.3) {
                rate += Math.abs(vocalTemperature) * 0.18;
                pitch -= Math.abs(vocalTemperature) * 0.04;
            }
            if (vocalTemperature > 0.3) {
                rate -= vocalTemperature * 0.22;
                pitch += vocalTemperature * 0.06;
            }
            rate *= 1.0 - resonanceBias * 0.15;
            pitch *= 1.0 - resonanceBias * 0.08;

            // === TTS warmup to avoid crackle after pause ===
            if (!speechSynthesis.speaking && !speechSynthesis.pending) {
                const warmup = new SpeechSynthesisUtterance(' ');
                warmup.volume = 0.01;
                warmup.rate = rate;
                warmup.pitch = pitch;
                if (currentVoice) warmup.voice = currentVoice;
                speechSynthesis.speak(warmup);
            }

            // –ì—É–º–∞–Ω–∏–∑–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞ + —Ä–∞–∑–±–∏–µ–Ω–∏–µ –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã
            let cleanedForSpeech = humanizeText(text)
                .replace(/\\+/g, '')
                // —É–±–∏—Ä–∞–µ–º –∑–∞–ø—è—Ç—ã–µ –∏ –¥–≤–æ–µ—Ç–æ—á–∏—è –∏–∑ TTS (–∏–Ω–∞—á–µ –≥–æ–≤–æ—Ä–∏—Ç "–∑–∞–ø—è—Ç–∞—è")
                .replace(/[,;:]/g, ' ')
                // —Ç–æ—á–∫–∏, ! –∏ ? –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –ø–∞—É–∑—ã
                .replace(/[^\w–∞-—è–ê-–Ø—ë–Åa-zA-Z0-9.!? ]+/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            // –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
            let sentences = cleanedForSpeech.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [cleanedForSpeech];
            sentences = sentences.flatMap(s => {
                if (s.length <= 120) return [s];

                const words = s.split(/\s+/);
                let out = [];
                let buf = '';

                for (let w of words) {
                    if ((buf + ' ' + w).trim().length > 80) {
                        if (buf) out.push(buf.trim());
                        buf = w;
                    } else {
                        buf += ' ' + w;
                    }
                }
                if (buf.trim()) out.push(buf.trim());
                return out;
            });

            // –ú–∞—Å—Å–∏–≤ –º–µ–∂–¥–æ–º–µ—Ç–∏–π –∏ "–¥—ã—Ö–∞—Ç–µ–ª—å–Ω—ã—Ö" –≤—Å—Ç–∞–≤–æ–∫
            const interjectionsByLang = {
                'ru-RU': ['–º–º...', '—ç—ç...', '–Ω—É...', '—ç–º...', '–≥–º...', '—Ö–º...', '—É–≥—É...', '–∞...', '—Ç–∞–∫...', '–¥–∞...', '–∫—Å—Ç–∞—Ç–∏...'],
                'en-US': ['um...', 'uh...', 'hmm...', 'well...', 'so...', 'ah...', 'okay...', 'right...', 'huh...', 'hmm...'],
                'de-DE': ['√§h...', 'hm...', 'nun...', 'also...', 'tja...', 'hmm...', 'ja...', 'gut...', 'ach...'],
                'fr-FR': ['euh...', 'ben...', 'alors...', 'hum...', 'ah...', 'ok...', 'bon...', 'hein...'],
                'es-ES': ['eh...', 'bueno...', 'mmm...', 'aj√°...', 'vale...', 'pues...', 'ah...', 'ok...'],
                'zh-CN': ['ÂóØ...', 'Âïä...', 'Ëøô‰∏™...', 'ÂëÉ...', 'Âì¶...', 'Âîî...']
            };
            const breathingUtterances = [
                '', // –æ–±—ã—á–Ω–∞—è –ø–∞—É–∑–∞
                '(–≤–¥–æ—Ö)', '(–≤—ã–¥–æ—Ö)', // ru
                '(inhale)', '(exhale)', // en
                '(pause)', // —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ
                '', '', // –±–æ–ª—å—à–µ –ø—É—Å—Ç—ã—Ö –¥–ª—è —Ä–µ–¥–∫–æ—Å—Ç–∏
            ];
            function getInterjection() {
                let arr = interjectionsByLang[currentLang] || interjectionsByLang['en-US'];
                return arr[Math.floor(Math.random() * arr.length)];
            }
            function getBreath() {
                return breathingUtterances[Math.floor(Math.random() * breathingUtterances.length)];
            }

            // –†–∞–∑–±–∏–≤–∞–µ–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –Ω–∞ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã —Å –º–∏–∫—Ä–æ–ø–∞—É–∑–∞–º–∏ –∏ –≤—Å—Ç–∞–≤–∫–∞–º–∏
            let fragments = [];
            for (let i = 0; i < sentences.length; ++i) {
                let s = sentences[i].trim();
                if (!s) continue;
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –¥—Ä–æ–±–ª–µ–Ω–∏–µ –ø–æ –∑–∞–ø—è—Ç—ã–º, –¥–≤–æ–µ—Ç–æ—á–∏—è–º –∏ —Ç.–ø.
                let parts = s.split(/([,;:‚Äî-])/g).filter(Boolean);
                let buf = '';
                for (let p of parts) {
                    buf += p;
                    if (/[,;:‚Äî-]$/.test(p) || buf.length > 45) {
                        fragments.push(buf.trim());
                        buf = '';
                    }
                }
                if (buf.trim()) fragments.push(buf.trim());
                // –ò–Ω–æ–≥–¥–∞ –ø–æ—Å–ª–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –≤—Å—Ç–∞–≤–∏—Ç—å –¥—ã—Ö–∞–Ω–∏–µ –∏–ª–∏ –º–µ–∂–¥–æ–º–µ—Ç–∏–µ
                if (Math.random() < 0.11) {
                    if (Math.random() < 0.55) {
                        fragments.push(getBreath());
                    } else {
                        fragments.push(getInterjection());
                    }
                }
            }

            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–∏–∫—Ä–æ–ø–∞—É–∑–∏ –¥–ª—è –∂–∏–≤–æ—Å—Ç–∏
            let enhancedFragments = [];
            for (let i = 0; i < fragments.length; ++i) {
                let frag = fragments[i];
                // –í—Å—Ç–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω–æ –º–µ–∂–¥–æ–º–µ—Ç–∏–µ –∏–ª–∏ –¥—ã—Ö–∞–Ω–∏–µ –º–µ–∂–¥—É —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞–º–∏, –∏–Ω–æ–≥–¥–∞ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                if (frag && frag.length > 0) {
                    enhancedFragments.push(frag);
                    // –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–∞—É–∑—ã –∏–ª–∏ –≤—Å—Ç–∞–≤–∫–∏ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —É—Å—Ç–∞–ª–æ—Å—Ç–∏, —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã, —Ä–µ–∑–æ–Ω–∞–Ω—Å–∞
                    let pauseChance = 0.08
                        + Math.max(0, selfAwareness?.fatigue || 0) * 0.2
                        + (vocalTemperature < 0 ? Math.abs(vocalTemperature) * 0.12 : 0)
                        + sessionResonance * 0.14;
                    if (Math.random() < pauseChance) {
                        if (Math.random() < 0.5) {
                            enhancedFragments.push(getBreath());
                        } else {
                            enhancedFragments.push(getInterjection());
                        }
                    }
                } else if (frag && frag.length === 0) {
                    // –ø—É—Å—Ç–∞—è –ø–∞—É–∑–∞
                    enhancedFragments.push('');
                }
            }

            // –£–¥–∞–ª—è–µ–º –ª–∏—à–Ω–∏–µ –ø—É—Å—Ç—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            enhancedFragments = enhancedFragments.filter((f, idx, arr) =>
                f && f.trim() || idx === 0 || (arr[idx - 1] && arr[idx - 1].trim())
            );

            let idx = 0;
            let utterQueue = [];

            function speakNext() {
                if (idx >= enhancedFragments.length) {
                    // –ñ–¥—ë–º —Ä–µ–∞–ª—å–Ω–æ–≥–æ –æ–∫–æ–Ω—á–∞–Ω–∏—è TTS
                    const waitForSpeechEnd = setInterval(() => {
                        if (!speechSynthesis.speaking && !speechSynthesis.pending) {
                            clearInterval(waitForSpeechEnd);

                            orb.classList.remove('speaking');
                            stopSpeakingVibration();

                            isSpeaking = false;
                            isChatMode = false;

                            status.innerText = "listening";

                            setTimeout(() => {
                                startListening();
                            }, 250);
                        }
                    }, 80);
                    return;
                }
                let s = enhancedFragments[idx];
                idx++;
                // –ü–∞—É–∑–∞: –µ—Å–ª–∏ –º–µ–∂–¥–æ–º–µ—Ç–∏–µ –∏–ª–∏ –¥—ã—Ö–∞–Ω–∏–µ –≤ —Å–∫–æ–±–∫–∞—Ö, —Ç–æ –ø–∞—É–∑–∞, –∏–Ω–∞—á–µ –≥–æ–≤–æ—Ä–∏–º
                if (!s || !s.trim()) {
                    setTimeout(speakNext, 80 + Math.random() * 100);
                    return;
                }
                // –ï—Å–ª–∏ —ç—Ç–æ "–¥—ã—Ö–∞–Ω–∏–µ" –∏–ª–∏ –º–µ–∂–¥–æ–º–µ—Ç–∏–µ, –æ–∑–≤—É—á–∏–≤–∞–µ–º —Å –æ—Å–æ–±—ã–º —Ç–µ–º–±—Ä–æ–º –∏–ª–∏ —Ç–∏—à–∏–Ω–æ–π
                let isBreath = /\((–≤–¥–æ—Ö|–≤—ã–¥–æ—Ö|inhale|exhale|pause)\)/i.test(s);
                let isInterjection = false;
                for (const arr of Object.values(interjectionsByLang)) {
                    if (arr.includes(s)) { isInterjection = true; break; }
                }
                if (isBreath) {
                    // "–¢–∏—Ö–∞—è" –ø–∞—É–∑–∞ ‚Äî –∫–æ—Ä–æ—Ç–∫–∏–π utterance —Å rate/pitch
                    const utter = new SpeechSynthesisUtterance('');
                    utter.lang = currentLang;
                    utter.rate = rate * 0.82 + (Math.random() - 0.5) * 0.08;
                    utter.pitch = pitch * 0.98 + (Math.random() - 0.5) * 0.05;
                    utter.volume = 0.0;
                    utter.onend = () => setTimeout(speakNext, 120 + Math.random() * 140);
                    utter.onerror = () => setTimeout(speakNext, 100);
                    setTimeout(() => synth.speak(utter), utterQueue.length * 16);
                    utterQueue.push(utter);
                    return;
                }
                if (isInterjection) {
                    // –î–ª—è –º–µ–∂–¥–æ–º–µ—Ç–∏—è ‚Äî —á—É—Ç—å –±—ã—Å—Ç—Ä–µ–µ, —á—É—Ç—å –≤—ã—à–µ pitch, —á—É—Ç—å —Ç–∏—à–µ
                    let interjRate = rate * (1.06 + (Math.random() - 0.5) * 0.09);
                    let interjPitch = pitch * (1.07 + (Math.random() - 0.5) * 0.12);
                    let interjVol = 0.82 + (Math.random() - 0.5) * 0.13;
                    const utter = new SpeechSynthesisUtterance(s);
                    utter.lang = currentLang;
                    utter.rate = interjRate;
                    utter.pitch = interjPitch;
                    utter.volume = Math.max(0.01, Math.min(1.0, interjVol));
                    if (currentVoice) utter.voice = currentVoice;
                    utter.onstart = () => {
                        if (speakingVibrationInterval) clearInterval(speakingVibrationInterval);
                        speakingVibrationInterval = setInterval(() => {
                            if (tg?.HapticFeedback) {
                                tg.HapticFeedback.impactOccurred('light');
                            }
                        }, 320);
                    };
                    utter.onend = () => {
                        stopSpeakingVibration();
                        setTimeout(speakNext, 80 + Math.random() * 120);
                    };
                    utter.onerror = () => {
                        stopSpeakingVibration();
                        setTimeout(speakNext, 100);
                    };
                    setTimeout(() => synth.speak(utter), utterQueue.length * 18);
                    utterQueue.push(utter);
                    return;
                }
             
                let jitter = Math.min(0.025, Math.abs(vocalTemperature) * 0.04);
                jitter *= (1.0 - sessionResonance * 0.6);
                let localRate = rate * (1.0 + (Math.random() - 0.5) * jitter);
                let localPitch = pitch * (1.0 + (Math.random() - 0.5) * jitter);
              
                let localVol = 0.88 + (Math.random() - 0.5) * 0.05;
                localVol = Math.max(0.01, Math.min(1.0, localVol));
                const utter = new SpeechSynthesisUtterance(s);
                utter.lang = currentLang;
                utter.rate = localRate;
                utter.pitch = localPitch;
                utter.volume = localVol;
                if (currentVoice) utter.voice = currentVoice;
                utter.onstart = () => {
                    if (speakingVibrationInterval) clearInterval(speakingVibrationInterval);
                    speakingVibrationInterval = setInterval(() => {
                        if (tg?.HapticFeedback) {
                            tg.HapticFeedback.impactOccurred('light');
                        }
                    }, 300);
                };
                utter.onend = () => {
                    stopSpeakingVibration();
                    setTimeout(speakNext, 60 + Math.random() * 110);
                };
                utter.onerror = () => {
                    stopSpeakingVibration();
                    setTimeout(speakNext, 100);
                };
                setTimeout(() => synth.speak(utter), utterQueue.length * 20);
                utterQueue.push(utter);
            }
            setTimeout(speakNext, 100);
        }
        
        
        
        window.addEventListener('load', () => {
            setTimeout(() => {
                vibrate('light');
                startListening();
            }, 1200);
        });

        // ====== camera ======
        const cameraVideo = document.getElementById('camera-video');
        let currentCamera = 'user'; // 'user' (front) or 'environment' (back)
        let stream = null;

        async function startCamera(facingMode = currentCamera) {
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode },
                    audio: false
                });
                cameraVideo.srcObject = stream;
                cameraVideo.style.display = 'block';
            } catch (e) {
                // alert,  UI
                cameraVideo.style.display = 'none';
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            cameraVideo.srcObject = null;
            cameraVideo.style.display = 'none';
        }

        function switchCamera() {
            currentCamera = currentCamera === 'user' ? 'environment' : 'user';
            startCamera(currentCamera);
        }

  
        const visionCanvas = document.createElement('canvas');
        visionCanvas.style.display = 'none';
        document.body.appendChild(visionCanvas);
        const visionCtx = visionCanvas.getContext('2d');

        // ===== OpenCV.js Vision Detection =====
        // OpenCV.js
        let opencvReady = false;
        let faceCascade = null;
        let cascadeLoaded = false;
        let pendingVisionFrames = [];


        function loadCascade() {
            if (faceCascade || !opencvReady) return;
            faceCascade = new cv.CascadeClassifier();
            // –§–∞–π–ª cascade –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ —Å—Å—ã–ª–∫–µ OpenCV, –∏—Å–ø–æ–ª—å–∑—É–µ–º frontalface_default.xml
            const cascadeFile = 'haarcascade_frontalface_default.xml';
            const cascadeUrl = 'https://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/haarcascade_frontalface_default.xml';
            cv.FS_createPreloadedFile('/', cascadeFile, cascadeUrl, true, false, () => {
                faceCascade.load(cascadeFile);
                cascadeLoaded = true;
      
                while (pendingVisionFrames.length > 0) {
                    const args = pendingVisionFrames.shift();
                    detectFacesAndSend(...args);
                }
            }, () => {
                cascadeLoaded = false;
            });
        }

        // OpenCV.js onRuntimeInitialized
        window.cv = window.cv || {};
        window.Module = window.Module || {};
        window.Module['onRuntimeInitialized'] = () => {
            opencvReady = true;
            loadCascade();
        };

     
        async function detectFacesAndSend(frameCanvas, width, height) {
            if (!opencvReady || !cascadeLoaded) {
               
                pendingVisionFrames.push([frameCanvas, width, height]);
                return;
            }
            try {
               
                let src = cv.imread(frameCanvas);
                let gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                let faces = new cv.RectVector();
                let msize = new cv.Size(0, 0);
                faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, msize, msize);
                let count = faces.size();
                let desc = '';
                if (count === 0) {
                    desc = '–õ–∏—Ü –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ.';
                } else if (count === 1) {
                    desc = '–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ 1 –ª–∏—Ü–æ –≤ –∫–∞–¥—Ä–µ.';
                } else {
                    desc = `–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ª–∏—Ü: ${count}.`;
                }
         
                src.delete();
                gray.delete();
                faces.delete();
                msize.delete();
             
                latestCameraDescription = desc;
              
            } catch (e) {
             
            }
        }

  
        // --- TensorFlow.js integration for object detection ---
  
        let tfReady = false;
        let tfModel = null;
        let tfLoadingPromise = null;
        let tfScriptLoaded = false;
        let tfLoadStarted = false;
      
        const OBJECTS_OF_INTEREST = [
            { ru: "—Å—Ç–æ–ª", en: ["dining table", "table", "desk"] },
            { ru: "–Ω–æ—É—Ç–±—É–∫", en: ["laptop"] },
            { ru: "–æ–∫–Ω–æ", en: ["window"] },
            { ru: "–ª–∞–º–ø–∞", en: ["lamp"] },
            { ru: "—Ä–∞—Å—Ç–µ–Ω–∏–µ", en: ["potted plant", "plant"] }
        ];

        function loadTensorFlowIfNeeded() {
            if (tfReady || tfLoadStarted) return tfLoadingPromise;
            tfLoadStarted = true;
            tfLoadingPromise = new Promise((resolve, reject) => {
     
                function loadScript(src, onload) {
                    const s = document.createElement('script');
                    s.src = src;
                    s.onload = onload;
                    s.async = true;
                    document.head.appendChild(s);
                }
                loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js', () => {
                    tfScriptLoaded = true;
                    loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js', async () => {
                     
                        let tries = 0;
                        function waitForTF() {
                            if (window.tf && window.cocoSsd) {
                                window.cocoSsd.load().then(model => {
                                    tfModel = model;
                                    tfReady = true;
                                    resolve();
                                });
                            } else if (tries < 50) {
                                tries++;
                                setTimeout(waitForTF, 200);
                            } else {
                                reject(new Error("TensorFlow.js load timeout"));
                            }
                        }
                        waitForTF();
                    });
                });
            });
            return tfLoadingPromise;
        }

        let cameraAnalysisInterval = null;
        // analyzeAndSendCameraFrame
        async function analyzeAndSendCameraFrame() {
            if (!cameraEnabled) return;

            try {
                
                if (
                    cameraVideo.style.display !== 'block' ||
                    cameraVideo.readyState < 2 ||
                    cameraVideo.videoWidth <= 0 || cameraVideo.videoHeight <= 0
                ) return;

                visionCanvas.width = cameraVideo.videoWidth;
                visionCanvas.height = cameraVideo.videoHeight;
                visionCtx.drawImage(cameraVideo, 0, 0, visionCanvas.width, visionCanvas.height);

                let faceDesc = '';
                let objectsDesc = '';
                let detectedObjectsRu = [];

                // --- OpenCV.js face detection ---
                try {
                    if (opencvReady && cascadeLoaded) {
                        let src = null, gray = null, faces = null, msize = null;
                        try {
                            src = cv.imread(visionCanvas);
                            if (!src || src.empty()) throw new Error("Canvas –ø—É—Å—Ç–æ–π –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π");
                            gray = new cv.Mat();
                            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                            faces = new cv.RectVector();
                            msize = new cv.Size(0, 0);
                            faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, msize, msize);
                            let count = faces.size();
                            faceDesc = count === 0 ? '–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ª–∏—Ü: 0' : `–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ª–∏—Ü: ${count}`;
                        } finally {
                            if (src) src.delete();
                            if (gray) gray.delete();
                            if (faces) faces.delete();
                            if (msize) msize.delete();
                        }
                    } else {
                        faceDesc = '–õ–∏—Ü –Ω–µ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º (OpenCV –Ω–µ –≥–æ—Ç–æ–≤).';
                    }
                } catch(e) {
                    console.warn("Face analysis skipped:", e);
                    faceDesc = '';
                }

                // --- TensorFlow.js object detection ---
                try {
                    await loadTensorFlowIfNeeded();
                    if (tfReady && tfModel) {
                        const predictions = await tfModel.detect(visionCanvas);
                        for (const obj of OBJECTS_OF_INTEREST) {
                            const found = predictions.find(p =>
                                obj.en.some(enName => (p.class || p.className || "").toLowerCase().includes(enName))
                                && p.score > 0.35
                            );
                            if (found) detectedObjectsRu.push(obj.ru);
                        }
                        if (detectedObjectsRu.length > 0) objectsDesc = '–≤–∏–¥–Ω—ã: ' + detectedObjectsRu.join(', ');
                    }
                } catch(e) {
                    console.error("–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –æ–±—ä–µ–∫—Ç–æ–≤:", e);
                }

                latestCameraDescription =
                    (faceDesc ? faceDesc : '') +
                    (objectsDesc ? (faceDesc ? '; ' : '') + objectsDesc + '.' : '');

                if (!latestCameraDescription) {
                    latestCameraDescription = '–ö–∞–¥—Ä –±–µ–∑ –∑–Ω–∞—á–∏–º—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤.';
                }

                const now = performance.now();
                let gemmaImage = null;

                if (now - lastGemmaImageTime > GEMMA_IMAGE_INTERVAL) {
                    gemmaImage = captureSmallImageBase64();
                    lastGemmaImageTime = now;
                }

                // Self-Awareness
                try {
                    if (latestCameraDescription && !latestCameraDescription.includes('–û—à–∏–±–∫–∞')) {
                        selfAwareness.analyzeFrame(latestCameraDescription);
                        orb.classList.add('reflecting');
                        setTimeout(() => orb.classList.remove('reflecting'), 1500);
                    }
                } catch(e) {
                    console.error("–û—à–∏–±–∫–∞ selfAwareness:", e);
                }

                try {
                    const userId = user_id_int;
                    await fetch('https://patronal-mayme-unexpandable.ngrok-free.dev/api/camera_analysis', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
                        body: JSON.stringify({
                            user_id: userId,
                            description: latestCameraDescription,
                            image: gemmaImage
                        })
                    });
                } catch(e) {
                    console.error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ–ø–∏—Å–∞–Ω–∏—è –∫–∞–º–µ—Ä—ã:", e);
                }
            } catch(e) {
                console.error("–û—à–∏–±–∫–∞ –≤ analyzeAndSendCameraFrame:", e);
            }
        }
        function startCameraAnalysisLoop() {
            if (cameraAnalysisInterval) clearInterval(cameraAnalysisInterval);
            cameraAnalysisInterval = setInterval(analyzeAndSendCameraFrame, 2000);
        }
        function stopCameraAnalysisLoop() {
            if (cameraAnalysisInterval) clearInterval(cameraAnalysisInterval);
            cameraAnalysisInterval = null;
        }

        // ===== cameraEnabled =====
        let cameraEnabled = false;
  
        const prevOnResult = recognition.onresult;
        recognition.onresult = async (event) => {
            const text = event.results[0][0].transcript;
           
            if (/\b(–≤–∫–ª—é—á–∏ –º—É–∑—ã–∫—É|–º—É–∑—ã–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞|—Å—Ç–∞—Ä—Ç –º—É–∑—ã–∫–∏)\b/i.test(text)) {
                if (!musicPlaying) {
                    if (musicCtx.state === 'suspended') await musicCtx.resume();
                    startMusic();
                }
                return;
            }
          
            if (/\b(–≤–∫–ª—é—á–∏ –∫–∞–º–µ—Ä—É|–ø–æ–∫–∞–∂–∏ –∫–∞–º–µ—Ä—É|–æ—Ç–∫—Ä–æ–π –∫–∞–º–µ—Ä—É|–∫–∞–º–µ—Ä–∞)\b/i.test(text)) {
                if (cameraVideo.style.display !== 'block') {
                    startCamera(currentCamera);
                    cameraEnabled = true;
                }
            }
            if (/\b(–≤—ã–∫–ª—é—á–∏ –∫–∞–º–µ—Ä—É|–∑–∞–∫—Ä–æ–π –∫–∞–º–µ—Ä—É|—Å–∫—Ä–æ–π –∫–∞–º–µ—Ä—É|—É–±–µ—Ä–∏ –∫–∞–º–µ—Ä—É)\b/i.test(text)) {
                if (cameraVideo.style.display === 'block') {
                    stopCamera();
                    cameraEnabled = false;
                }
            }
            if (/\b(–ø–µ—Ä–µ–∫–ª—é—á–∏ –∫–∞–º–µ—Ä—É|—Å–º–µ–Ω–∏—Ç—å –∫–∞–º–µ—Ä—É|–¥—Ä—É–≥–∞—è –∫–∞–º–µ—Ä–∞|–ø–µ—Ä–µ–≤–µ—Ä–Ω–∏ –∫–∞–º–µ—Ä—É)\b/i.test(text)) {
                switchCamera();
            }

         
            const ambientTriggerWords = ['—Å—Ç–∞—Ä—Ç', '–º—É–∑—ã–∫–∞', 'ambient', '–∑–≤—É–∫–∏'];
            if (ambientTriggerWords.some(word => text.toLowerCase().includes(word))) {
                triggerAmbient();
            }

           
            if (typeof prevOnResult === 'function') {
                await prevOnResult(event);
            }
        };

        const origStartCamera = startCamera;
        startCamera = async function(...args) {
            await origStartCamera.apply(this, args);
            cameraEnabled = true;
            startCameraAnalysisLoop();
        }
        const origStopCamera = stopCamera;
        stopCamera = function(...args) {
            origStopCamera.apply(this, args);
            cameraEnabled = false;
            stopCameraAnalysisLoop();
        }


        // Utility: stick chat to bottom if near bottom
        function stickChatToBottom(container, threshold = 24) {
            return (
                container.scrollHeight -
                container.scrollTop -
                container.clientHeight
            ) <= threshold;
        }

        // Utility: scroll chat to bottom
        function scrollChatToBottom() {
            const chatContainer = document.getElementById('chatMessages');
            if (!chatContainer) return;
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // ===== Chat Panel Management =====
        // === Chat typing animation with word-by-word effect, supporting glitch and markdown styling ===
        // Glitch helpers
        function randomGlitchChar(base) {
            // Unicode combining diacritics for glitch
            const glitchUp = "\u030d\u030e\u0304\u0305\u033f\u0311\u0306\u0310\u0352\u0357\u0351\u0307\u0308\u030a\u0342\u0343\u0344\u034a\u034b\u034c\u0303\u0302\u030c\u0350\u0300\u0301\u030b\u030f\u0312\u0313\u0314\u033d\u0309\u0363\u0364\u0365\u0366\u0367\u0368\u0369\u036a\u036b\u036c\u036d\u036e\u036f\u033e\u035b\u0346\u031a";
            const glitchDown = "\u0316\u0317\u0318\u0319\u031c\u031d\u031e\u031f\u0320\u0324\u0325\u0326\u0329\u032a\u032b\u032c\u032d\u032e\u032f\u0330\u0331\u0332\u0333\u0339\u033a\u033b\u033c\u0345\u0347\u0348\u0349\u034d\u034e\u0353\u0354\u0355\u0356\u0359\u035a\u0323";
            const glitchMid = "\u0315\u031b\u0340\u0341\u0358\u0321\u0322\u0327\u0328\u0334\u0335\u0336\u034f\u035c\u035d\u035e\u035f\u0360\u0362\u0338\u0337\u0361\u0489";
            let out = base;
            let up = Math.floor(Math.random() * 2) + 1;
            let down = Math.floor(Math.random() * 2);
            let mid = Math.floor(Math.random() * 2);
            for (let i = 0; i < up; ++i) out += glitchUp[Math.floor(Math.random() * glitchUp.length)];
            for (let i = 0; i < down; ++i) out += glitchDown[Math.floor(Math.random() * glitchDown.length)];
            for (let i = 0; i < mid; ++i) out += glitchMid[Math.floor(Math.random() * glitchMid.length)];
            return out;
        }

        // Glitch animation: for spans with .glitch-animate, update their textContent every 60ms
        function startGlitchAnimation(span, baseText) {
            if (span._glitchAnim) clearInterval(span._glitchAnim);
            span._glitchAnim = setInterval(() => {
                span.textContent = randomGlitchChar(baseText);
            }, 60 + Math.random() * 50);
        }
        function stopGlitchAnimation(span, baseText) {
            if (span._glitchAnim) {
                clearInterval(span._glitchAnim);
                span._glitchAnim = null;
            }
            span.textContent = baseText;
        }

        // === Code block detection for chat messages ===
        function detectCodeBlock(text) {
            if (!text) return false;
            const t = text.trimStart();
            // fenced code block only if at start
            if (t.startsWith('```')) return true;
            // code-like syntax only if at start of message
            if (/^(const|let|var|function|class|import|export|def|if|for|while|return)\b/.test(t)) return true;
            // HTML only if starts at beginning
            if (/^<[^>]+>/.test(t)) return true;
            return false;
        }

        function parseMarkdownSegments(text) {
            // Returns array of {type:..., text:...}
            // Supported: **bold**, *italic*, ~glitch~
            let regex = /(\*\*([^*]+)\*\*|\*([^*]+)\*|~([^~]+)~)/g;
            let segments = [];
            let lastIndex = 0;
            let m;
            while ((m = regex.exec(text)) !== null) {
                if (m.index > lastIndex) {
                    segments.push({ type: "plain", text: text.slice(lastIndex, m.index) });
                }
                if (m[2]) {
                    segments.push({ type: "bold", text: m[2] });
                } else if (m[3]) {
                    segments.push({ type: "italic", text: m[3] });
                } else if (m[4]) {
                    segments.push({ type: "glitch", text: m[4] });
                }
                lastIndex = regex.lastIndex;
            }
            if (lastIndex < text.length) {
                segments.push({ type: "plain", text: text.slice(lastIndex) });
            }
            return segments;
        }

        function typeWriterWordsEffect(element, text, charDelay = 1, wordDelay = 5) {
            // === HARD LOCK: prevent parallel typing ===
            if (window.__chatTypingLock) {
                return Promise.resolve();
            }
            window.__chatTypingLock = true;
            return new Promise((resolve) => {
                if (detectCodeBlock(text)) {
                    const pre = document.createElement('pre');
                    pre.className = 'code-artifact';
                    const code = document.createElement('code');

                    let codeText = text.trimStart();
                    if (codeText.startsWith('```')) {
                        codeText = codeText.replace(/^```[\w-]*\n?/, '').replace(/```$/, '');
                    }

                    code.textContent = codeText;
                    pre.appendChild(code);
                    element.appendChild(pre);
                    window.__chatTypingLock = false;
                    resolve();
                    return;
                }

                text = text.replace(/^[.\s]+/, '');
                if (!text || !text.trim()) {
                    window.__chatTypingLock = false;
                    resolve();
                    return;
                }

                const isAI = element.closest('.chat-message')?.classList.contains('ai');
                let cursor = null;

                if (isAI) {
                    cursor = element.querySelector('.ai-cursor');
                    if (!cursor) {
                        cursor = document.createElement('span');
                        cursor.className = 'ai-cursor';
                        element.appendChild(cursor);
                    }
                }

                const segments = parseMarkdownSegments(text);

                // === Fast render buffers ===
                let segIdx = 0;
                let buffer = [];
                let flushing = false;
                const MAX_BATCH = 12;

                function flushBuffer() {
                    if (buffer.length === 0) return;
                    const frag = document.createDocumentFragment();
                    for (const n of buffer) frag.appendChild(n);
                    buffer.length = 0;
                    element.insertBefore(frag, cursor || null);
                    scrollChatToBottom();
                }

                function scheduleFlush() {
                    if (flushing) return;
                    flushing = true;
                    requestAnimationFrame(() => {
                        flushBuffer();
                        flushing = false;
                    });
                }

                function typeNextSegment() {
                    if (segIdx >= segments.length) {
                        flushBuffer();
                        if (cursor) cursor.remove();
                        window.__chatTypingLock = false;
                        resolve();
                        return;
                    }

                    const seg = segments[segIdx++];
                    let chars = Array.from(seg.text);
                    let i = 0;

                    function step() {
                        let count = 0;
                        while (i < chars.length && count < MAX_BATCH) {
                            const span = document.createElement('span');
                            span.className = 'chat-char';

                            if (seg.type === 'italic') span.classList.add('chat-italic');
                            if (seg.type === 'bold') span.classList.add('chat-bold');
                            if (seg.type === 'glitch') {
                                span.classList.add('chat-glitch');
                                span._baseText = chars[i];
                                startGlitchAnimation(span, span._baseText);
                            }

                            span.textContent = chars[i++];

                            // –º—è–≥–∫–∏–π –º–∞–≥–Ω–µ—Ç–∏–∑–º + –±–ª—é—Ä –ø—Ä–∏ –ø–æ—è–≤–ª–µ–Ω–∏–∏
                            span.style.filter = 'blur(2px)';
                            span.style.transform = 'translateY(2px) scale(0.985)';
                            span.style.opacity = '0';

                            requestAnimationFrame(() => {
                                span.style.transition = 'filter 160ms ease, transform 160ms ease, opacity 120ms ease';
                                span.style.filter = 'blur(0px)';
                                span.style.transform = 'translateY(0px) scale(1)';
                                span.style.opacity = '1';
                            });

                            buffer.push(span);
                            count++;
                        }

                        scheduleFlush();

                        if (i < chars.length) {
                            requestAnimationFrame(step);
                        } else {
                            setTimeout(typeNextSegment, wordDelay);
                        }
                    }

                    step();
                }

                typeNextSegment();
            });
        }

        // typeChatMessage: uses typeWriterWordsEffect, applies real-time markdown styling and glitch
        function typeChatMessage(text, container) {
            if (!text || !text.trim()) return;
            const isAI = container.closest('.chat-message')?.classList.contains('ai');

            let cursor = null;

            // === USER MESSAGE: instant appear with soft animation ===
            if (!isAI) {
                container.innerHTML = text;
                container.classList.add('user-appear');
                requestAnimationFrame(() => {
                    container.classList.add('user-appear-active');
                });
                scrollChatToBottom();
                return;
            }

            // === AI MESSAGE: keep existing typing ===
            cursor = document.createElement('span');
            cursor.className = 'ai-cursor';
            container.appendChild(cursor);

            typeWriterWordsEffect(container, text).then(() => {
                // Remove cursor if present
                if (cursor && cursor.parentNode) cursor.remove();
                container.classList.remove('chat-cursor');
                // After full type, stop glitch animation and set final text for glitch spans
                container.querySelectorAll('.chat-glitch').forEach(span => {
                    stopGlitchAnimation(span, span._baseText || span.textContent);
                });
                scrollChatToBottom();
            });
        }

        // Add CSS for chat-char, chat-italic, chat-bold, chat-glitch, glitch-animate
        if (!document.getElementById('chat-char-style-glitch')) {
            const style = document.createElement('style');
            style.id = 'chat-char-style-glitch';
            style.textContent = `
                .chat-char {
                    display: inline;
                    opacity: 0;
                    filter: blur(3px);
                    transform: translateY(2px);
                    animation: char-appear 0.618s forwards;
                    white-space: pre-wrap;
                }
                .chat-italic {
                    opacity: 0.6 !important;
                    font-style: italic;
                    filter: blur(0.5px);
                    transition: opacity 0.2s, filter 0.2s;
                }
                .chat-bold {
                    font-weight: bold;
                    font-size: 1.03em;
                    letter-spacing: 0.001em;
                    filter: none;
                }
                .chat-glitch {
                    color: #e0e0ff;
                    text-shadow: 0 0 2px #fff, 0 0 3px #ff00c8, 0 0 8px #00ffe1;
                    font-style: oblique;
                    font-weight: 600;
                    position: relative;
                    filter: blur(0.5px) brightness(1.2);
                    transition: filter 0.168s;
                }
                .glitch-animate {
                    animation: glitch-flicker 0.314s infinite alternate;
                }
                .code-artifact {
                    background: rgba(0,0,0,0.3);
                    padding: 14px 16px;
                    margin: 8px 0;
                    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
                    font-size: 0.88em;
                    line-height: 1.45;
                    color: #e6e6e6;
                    box-shadow: 0 0 24px rgba(0,255,255,0.03);
                    overflow-x: auto;
                }
                .code-artifact code {
                    white-space: pre;
                }
                @keyframes char-appear {
                    to {
                        opacity: 1;
                        filter: blur(0);
                        transform: translateY(0);
                    }
                }
                @keyframes glitch-flicker {
                    from { filter: blur(0.5px) brightness(1.2); }
                    to   { filter: blur(2px) brightness(1.5); }
                }
                .user-appear {
                    opacity: 0;
                    transform: translateY(4px) scale(0.98);
                    filter: blur(2px);
                    transition:
                        opacity 1.31s ease-out,
                        transform 1.16s cubic-bezier(.2,.8,.2,1),
                        filter 0.16s ease-out;
                }
                .user-appear-active {
                    opacity: 1;
                    transform: translateY(0) scale(1);
                    filter: blur(0);
                }
            `;
            document.head.appendChild(style);
        }

        const mainWrapper = document.getElementById('mainWrapper');
        const chatPanel = document.getElementById('chatPanel');
        const closeChat = document.getElementById('closeChat');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');

        let chatOpen = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchX = 0;
        let isDragging = false;
        let draggingRAF = null;
        let dragTranslateX = 0;

        // Add CSS transition for mainWrapper for smoothness
        if (mainWrapper) {
          mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
        }

        // Utility: get current translateX (px) of mainWrapper
        function getMainWrapperTranslateX() {
          if (!mainWrapper) return 0;
          const style = window.getComputedStyle(mainWrapper);
          let matrix = style.transform;
          if (matrix && matrix !== 'none') {
            const m = matrix.match(/matrix(3d)?\((.+)\)/);
            if (m) {
              const parts = m[2].split(',').map(x => x.trim());
              // 2d: matrix(a, b, c, d, tx, ty)
              // 3d: matrix3d(...)
              if (parts.length >= 6) {
                return parseFloat(parts[4]);
              }
            }
          }
          return 0;
        }

        // Set mainWrapper transform (only mainWrapper, never chatPanel)
        function setMainWrapperTransform(x, withTransition = false) {
          if (mainWrapper) {
            if (withTransition) {
              mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
            } else {
              mainWrapper.style.transition = 'none';
            }
            mainWrapper.style.transform = x === 0 ? '' : `translateX(${x}px)`;
          }
        }

        // Animate mainWrapper translateX from 'from' to 'to' px over 'duration' ms with ease
        function animateTranslateX(from, to, duration = 320) {
          if (!mainWrapper) return;
          const start = performance.now();
          function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
          }
          function step(now) {
            const elapsed = now - start;
            let t = Math.min(1, elapsed / duration);
            t = easeOutCubic(t);
            const value = from + (to - from) * t;
            mainWrapper.style.transition = 'none';
            mainWrapper.style.transform = value === 0 ? '' : `translateX(${value}px)`;
            if (t < 1) {
              requestAnimationFrame(step);
            } else {
              // Snap to final position and restore transition
              mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
              mainWrapper.style.transform = to === 0 ? '' : `translateX(${to}px)`;
            }
          }
          requestAnimationFrame(step);
        }

        // Improved swipe logic (no jump when snapping back, proper offset, only mainWrapper transform)
        document.body.addEventListener('touchstart', (e) => {
          const touch = e.changedTouches[0];
          const x = touch.clientX;
          const y = touch.clientY;
          // Prevent accidental drag from left edge if already open
          if (chatOpen && x < window.innerWidth * 0.2) {
            isDragging = false;
            return;
          }
          touchStartX = x;
          touchStartY = y;
          lastTouchX = x;
          isDragging = true;
          dragTranslateX = 0;
          if (mainWrapper) mainWrapper.style.willChange = 'transform';
        }, { passive: true });

        document.body.addEventListener('touchmove', (e) => {
          if (!isDragging) return;
          const touch = e.changedTouches[0];
          lastTouchX = touch.clientX;
          const touchY = touch.clientY;
          const deltaX = Math.abs(lastTouchX - touchStartX);
          const deltaY = Math.abs(touchY - touchStartY);
          if (deltaY > deltaX) return;
          const diff = lastTouchX - touchStartX;
          const maxOffset = -window.innerWidth * 0.8;
          // Opening (from orb): drag left, negative
          if (!chatOpen && diff < 0) {
            dragTranslateX = Math.max(diff, maxOffset);
          }
          // Closing (from open): drag right, positive
          else if (chatOpen && diff > 0) {
            dragTranslateX = Math.min(diff, 0);
            // start from maxOffset, so add diff to maxOffset (but clamp to 0)
            dragTranslateX = Math.min(maxOffset + diff, 0);
          }
          // If not enough movement, stay at 0
          else if (!chatOpen) {
            dragTranslateX = 0;
          }
          // Only mainWrapper transform, never chatPanel
          if (draggingRAF) cancelAnimationFrame(draggingRAF);
          draggingRAF = requestAnimationFrame(() => {
            setMainWrapperTransform(dragTranslateX, false);
          });
        }, { passive: true });

        document.body.addEventListener('touchend', (e) => {
          if (!isDragging) return;
          isDragging = false;
          if (mainWrapper) mainWrapper.style.willChange = '';
          if (draggingRAF) {
            cancelAnimationFrame(draggingRAF);
            draggingRAF = null;
          }
          const swipeDistance = lastTouchX - touchStartX;
          const maxOffset = -window.innerWidth * 0.8;
          // Thresholds for opening/closing
          if (swipeDistance > 60 && chatOpen) {
            closeChatPanel();
          } else if (swipeDistance < -60 && !chatOpen) {
            openChat();
          } else {
            // Animate snap back to original state (from current real offset, not just dragTranslateX)
            if (mainWrapper) {
              const currentX = getMainWrapperTranslateX();
              animateTranslateX(currentX, 0, 320);
            }
          }
        });

        function openChat() {
          chatOpen = true;
          isChatMode = true;
          if (mainWrapper) {
            mainWrapper.classList.add('chat-open');
            mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
            mainWrapper.style.transform = '';
          }
          if (typeof vibrate === 'function') vibrate('medium');
        }

        function closeChatPanel() {
          chatOpen = false;
          isChatMode = false;
          if (mainWrapper) {
            mainWrapper.classList.remove('chat-open');
            mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
            mainWrapper.style.transform = '';
          }
          if (typeof vibrate === 'function') vibrate('medium');
        }

        if (closeChat) {
          closeChat.addEventListener('click', closeChatPanel);
        }

        // Chat messages
        function addChatMessage(text, sender = 'user') {
          if (!chatMessages) return;
          if (!text || !text.trim()) return;
          // === SYNC TYPED USER TEXT TO ORB "You" ===
          if (sender === 'user' && typeof appendTranscript === 'function') {
              appendTranscript(text); // –≤—Å–µ–≥–¥–∞ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π You –≤ –æ—Ä–±–µ
          }
          const msgDiv = document.createElement('div');
          msgDiv.className = `chat-message ${sender}`;
          const senderDiv = document.createElement('div');
          senderDiv.className = 'sender';
          senderDiv.textContent = sender === 'user' ? 'You' : 'AI';
          const textDiv = document.createElement('div');
          textDiv.className = 'text';
          msgDiv.appendChild(senderDiv);
          msgDiv.appendChild(textDiv);
          chatMessages.appendChild(msgDiv);
          // removed direct scroll here for autoscroll patch
          // Add copy-on-click for the message (allow copying for both user and AI)
          msgDiv.addEventListener('click', () => {
              const copyText = sender === 'user' ? text : textDiv.textContent;
              navigator.clipboard.writeText(copyText).then(() => {
                  msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                  setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
              });
          });
          textDiv.innerHTML = '';
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º typeChatMessage –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∏ AI
          typeChatMessage(text, textDiv);
        }

        // –î–æ–±–∞–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è AI-—Å–æ–æ–±—â–µ–Ω–∏–π —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π –±—É–∫–≤ (fixed: prevent appending empty/blank messages)
        function addAIMessage(text) {
          if (!chatMessages) return;
          if (!text || !text.trim()) return; // Prevent empty AI messages
          const msgDiv = document.createElement('div');
          msgDiv.className = `chat-message ai`;
          const senderDiv = document.createElement('div');
          senderDiv.className = 'sender';
          senderDiv.textContent = 'AI';
          const textDiv = document.createElement('div');
          textDiv.className = 'text';
          msgDiv.appendChild(senderDiv);
          msgDiv.appendChild(textDiv);
          chatMessages.appendChild(msgDiv);
          msgDiv.addEventListener('click', () => {
              navigator.clipboard.writeText(textDiv.textContent).then(() => {
                  msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                  setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
              });
          });
          textDiv.innerHTML = '';
          typeChatMessage(text, textDiv);
        }

        // Send message
        if (sendBtn && chatInput) {
          sendBtn.addEventListener('click', () => {
            const text = chatInput.value.trim();
            // === SYNC TYPED USER TEXT TO ORB "You" (CHAT INPUT) ===
            if (typeof appendTranscript === 'function') {
                appendTranscript(text);
            }
            if (!text) return;
            // –ù–æ–≤—ã–π –≤–∞—Ä–∏–∞–Ω—Ç: –∏—Å–ø–æ–ª—å–∑—É–µ–º typeChatMessage –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message user`;
            const senderDiv = document.createElement('div');
            senderDiv.className = 'sender';
            senderDiv.textContent = 'You';
            const textDiv = document.createElement('div');
            textDiv.className = 'text';
            msgDiv.appendChild(senderDiv);
            msgDiv.appendChild(textDiv);
            chatMessages.appendChild(msgDiv);
            // removed direct scroll here for autoscroll patch
            msgDiv.addEventListener('click', () => {
                navigator.clipboard.writeText(text).then(() => {
                    msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
                });
            });
            typeChatMessage(text, textDiv);
            chatInput.value = '';
            if (typeof sendToBot === 'function') sendToBot(text);
          });
          chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendBtn.click();
          });
        }

        // recognition integration (NO chat append ‚Äî single source of truth)
        if (window.recognition) {
          const origRecognitionOnResult = recognition.onresult;
          recognition.onresult = function(event) {
            // —Ç–æ–ª—å–∫–æ –ø—Ä–æ–∫–∏–¥—ã–≤–∞–µ–º –¥–∞–ª—å—à–µ, UI —Ä–∏—Å—É–µ—Ç—Å—è –≤ sendToBot / sendBtn
            if (origRecognitionOnResult) {
              return origRecognitionOnResult.call(this, event);
            }
          };
        }

        <!-- –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç JavaScript –≤ –∫–æ–Ω–µ—Ü <script> -->

    // ===== Settings Panel Logic =====
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsIcon = document.getElementById('settingsIcon');
    const shadersToggle = document.getElementById('shadersToggle');
    const vibrationsToggle = document.getElementById('vibrationsToggle');
    const soundsToggle = document.getElementById('soundsToggle');
    const applyBtn = document.getElementById('applySettings');
    
    let settingsOpen = false;
    let currentSettings = {
        shaders: false,
        interfaceSize: 'medium',
        mode: 'voice',
        vibrations: true,
        sounds: true
    };
    
    // Load saved settings
    function loadSettings() {
        const saved = localStorage.getItem('ai_settings');
        if (saved) {
            currentSettings = JSON.parse(saved);
            
            // Apply loaded settings to UI
            shadersToggle.checked = currentSettings.shaders;
            vibrationsToggle.checked = currentSettings.vibrations;
            soundsToggle.checked = currentSettings.sounds;
            
            // Set active buttons
            document.querySelectorAll('.size-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.size === currentSettings.interfaceSize);
            });
            
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === currentSettings.mode);
            });
            
            // Apply immediately
            applySettings(currentSettings);
        }
    }
    
    // Save settings
    function saveSettings() {
        localStorage.setItem('ai_settings', JSON.stringify(currentSettings));
    }
    
    // Apply settings to the interface
    function applySettings(settings) {
        // Shaders
        document.body.classList.toggle('shaders-disabled', settings.shaders);
        
        // Interface size
        document.body.classList.remove('interface-small', 'interface-medium', 'interface-large');
        document.body.classList.add(`interface-${settings.interfaceSize}`);
        
        // Mode
        document.body.classList.toggle('text-only-mode', settings.mode === 'text');
        if (settings.mode === 'text') {
            isChatMode = true;
            if (typeof stopListening === 'function') stopListening();
        } else {
            isChatMode = false;
            if (!isSpeaking && !isThinking) {
                setTimeout(startListening, 500);
            }
        }
        
        // Vibrations
        window.vibrationsEnabled = settings.vibrations;
        
        // Sounds
        window.soundsEnabled = settings.sounds;
    }
    
    // Open/close settings panel
    function toggleSettings() {
        settingsOpen = !settingsOpen;
        mainWrapper.classList.toggle('settings-open', settingsOpen);
        
        if (settingsOpen) {
            // Close chat if open
            mainWrapper.classList.remove('chat-open');
        }
        
        vibrate('light');
    }
    
    // Initialize settings
    document.addEventListener('DOMContentLoaded', () => {
        loadSettings();
        
        // Settings icon click
        settingsIcon.addEventListener('click', toggleSettings);
        
        // Size selector
        document.querySelectorAll('.size-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSettings.interfaceSize = btn.dataset.size;
            });
        });
        
        // Mode selector
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentSettings.mode = btn.dataset.mode;
            });
        });
        
        // Apply button
        applyBtn.addEventListener('click', () => {
            // Update current settings
            currentSettings.shaders = shadersToggle.checked;
            currentSettings.vibrations = vibrationsToggle.checked;
            currentSettings.sounds = soundsToggle.checked;
            
            // Apply and save
            applySettings(currentSettings);
            saveSettings();
            
            // Close panel
            toggleSettings();
            
            // Feedback
            if (window.soundsEnabled) {
                // Play a subtle sound if you have audio context
            }
            if (window.vibrationsEnabled) {
                vibrate('medium');
            }
        });
    });
    
    // Swipe left to open settings
    document.body.addEventListener('touchstart', (e) => {
        if (settingsOpen || chatOpen) return;
        
        const touch = e.changedTouches[0];
        const x = touch.clientX;
        
        // Only trigger from right edge (for settings open)
        if (x > window.innerWidth * 0.8) {
            touchStartX = x;
            touchStartY = touch.clientY;
            isDragging = true;
            dragTranslateX = 0;
        }
    });
    
    document.body.addEventListener('touchmove', (e) => {
        if (!isDragging || chatOpen || settingsOpen) return;
        
        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - touchStartX;
        
        // Swipe left (negative delta) from right edge opens settings
        if (deltaX < -50) {
            toggleSettings();
            isDragging = false;
        }
    });
    
    // Swipe right to close settings
    document.body.addEventListener('touchend', (e) => {
        if (!settingsOpen) return;
        
        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - touchStartX;
        
        if (deltaX > 60) {
            toggleSettings();
        }
    });
    
    // Close settings when clicking outside
    document.addEventListener('click', (e) => {
        if (settingsOpen && 
            !settingsPanel.contains(e.target) && 
            !settingsIcon.contains(e.target) &&
            e.clientX > window.innerWidth * 0.2) {
            toggleSettings();
        }
    });
    </script>

    
</body>
</html>
</script>
<script>

</script>
