
    }

    // === External Search Context Buffer (from frontend search) ===
    window.externalSearchContext = [];

    function pushExternalSearchContext(entry) {
        if (!entry) return;
        window.externalSearchContext.push({
            ts: Date.now(),
            data: entry
        });
        // keep buffer small
        if (window.externalSearchContext.length > 12) {
            window.externalSearchContext.shift();
        }
    }

    async function sendToBot(text) {
            stopListeningVibration(); // отключаем дыхание, когда ИИ думает или говорит
            if (window.recognition && recognition.abort) {
                try { recognition.abort(); } catch(e){}
            }
            isThinking = true;
            orb.classList.remove('listening');
            orb.classList.add('thinking');
            status.innerText = "processing stream";
            // --- таймеры статуса для длинной обработки ---
            let processingTimeout = setTimeout(() => {
                status.innerText = "thinking";
            }, 10000); // через 10 секунд

            let researchingTimeout = setTimeout(() => {
                status.innerText = "preparing answer";
            }, 20000); // через 20 секунд
            startThinkingVibration();

            // --- Orb bounce animation start ---
            startOrbBounce();

            // Подготовка UI с курсором
            let responseContainer = document.getElementById("current-response");

            if (!responseContainer) {
                transcriptDiv.innerHTML += `<br><br><span style="color: rgba(255,255,255,0.7)">AI:</span> <span id="current-response" class="typing-cursor"></span>`;
                responseContainer = document.getElementById("current-response");
            } else {
                responseContainer.innerHTML = '';
                responseContainer.classList.add('typing-cursor');
            }
            audioBuffer = "";
            spokenLength = 0;
            // --- sDelay-driven speech sync ---
            let speechStarted = false;
            const speechDelayMs = 420; // базовая задержка «вязкого времени»

            try {
                const userId = tg?.initDataUnsafe?.user?.id || 0;
                // Добавляем описание камеры в скобках, если оно есть
                let textWithContext = text;
                if (latestCameraDescription && latestCameraDescription.trim() !== "") {
                    textWithContext = text + " (" + latestCameraDescription + ")";
                }
                // Добавляем внутренние заметки self-awareness
                if(internalNotes.length > 0) textWithContext += " | Notes: " + internalNotes.join("; ");

                // Gather extended context for payload
                const recentNotes = internalNotes.slice(-8);
                const musicContext = {
                    genre: currentGenre,
                    genome: musicGenome,
                    aiNotes: (typeof currentAINotes !== 'undefined') ? currentAINotes.slice(-12) : [],
                    playing: !!musicPlaying
                };
                const memoryContext = (typeof memoryPalace !== 'undefined' && typeof memoryPalace.getRecentNodes === 'function')
                    ? memoryPalace.getRecentNodes(8)
                    : [];
                const selfAwarenessContext = (typeof selfAwareness !== 'undefined') ? selfAwareness : {};

                const payload = {
                    user_id: userId,
                    text: textWithContext,
                    gender: userGender,
                    lang: currentLang,
                    notes: recentNotes,
                    music: musicContext,
                    memory: memoryContext,
                    self_awareness: selfAwarenessContext,
                    external_context: window.externalSearchContext.slice(-6)
                };

                const response = await fetch(
                    'https://patronal-mayme-unexpandable.ngrok-free.dev/api/voice_chat',
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'ngrok-skip-browser-warning': 'true'
                        },
                        body: JSON.stringify(payload)
                    }
                );

                // clear external context after successful handoff to backend
                window.externalSearchContext = [];

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                isThinking = false;
                orb.classList.remove('thinking');
                stopThinkingVibration();
                orb.classList.add('speaking');
                status.innerText = "receiving data";
                vibrateSpeaking();

                // --- Orb bounce animation stop at start of AI message ---
                stopOrbBounce();

                let chatShouldStick = stickChatToBottom(chatMessages);
                // === STREAM TO CHAT (AI) ===
                window._chatStreamBuffer = '';
                window._chatStreamMsg = null;
                window._chatStreamHasText = false;
                window._chatStreamPrinted = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    window._chatStreamBuffer += chunk;

                    const printed = window._chatStreamPrinted || 0;
                    const full = window._chatStreamBuffer;
                    const delta = full.slice(printed);

                    // считаем ЛЮБОЙ текст, даже если это пробелы или переносы
                    if (!window._chatStreamMsg && delta.length > 0) {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'chat-message ai';
                        msgDiv.innerHTML = `
                          <div class="sender">AI</div>
                          <div class="text"></div>
                        `;
                        chatMessages.appendChild(msgDiv);
                        window._chatStreamMsg = msgDiv.querySelector('.text');
                        window._chatStreamPrinted = printed;
                    }

                    if (delta.length > 0) {
                        window._chatStreamHasText = true;
                    }

                    if (delta.length > 0 && window._chatStreamMsg) {
                        const nextPrinted = full.length;
                        chatShouldStick = stickChatToBottom(chatMessages);
                        chatTypingQueue = chatTypingQueue.then(() => {
                            return typeWriterWordsEffect(window._chatStreamMsg, delta).then(() => {
                                window._chatStreamPrinted = nextPrinted;
                                if (chatShouldStick) chatMessages.scrollTop = chatMessages.scrollHeight;
                            });
                        });
                    }

                    // Печатание текста: теперь печатаем по словам целиком с помощью typeWriterEffect
                    if (responseContainer) {
                        orbTypingQueue = orbTypingQueue.then(() =>
                            typeWriterEffect(responseContainer, chunk, {
                                charDelay: 6,
                                wordPause: 0
                            })
                        );
                        // Микропаузa на границах фраз
                        if (/[.!?\n]/.test(chunk)) {
                            orbTypingQueue = orbTypingQueue.then(() =>
                                new Promise(r => setTimeout(r, 40 + Math.random() * 40))
                            );
                        }
                    }

                    // Копим для озвучки
                    audioBuffer += chunk;

                    if (!speechStarted) {
                        speechStarted = true;

                        // считаем первый чанк уже озвученным,
                        // чтобы он не попал в delta и не сказалcя второй раз
                        spokenLength = audioBuffer.length;

                        setTimeout(() => {
                            speak(chunk);
                        }, 120);
                    }

                    if (speechStarted) {
                        const delta = audioBuffer.slice(spokenLength);
                        // более ранний порог — речь дышит вместе с печатью
                        if (delta.length > 12 && /[.!?]|,|\n/.test(delta)) {
                            spokenLength = audioBuffer.length;
                            speak(delta);
                        }
                    }
                }

                // === FINAL FLUSH: дописываем хвост, если стрим оборвался ===
                if (window._chatStreamMsg) {
                    const printed = window._chatStreamPrinted || 0;
                    const full = window._chatStreamBuffer || '';
                    const tail = full.slice(printed);
                    if (tail && tail.trim().length > 0) {
                        await typeWriterWordsEffect(window._chatStreamMsg, tail);
                        window._chatStreamPrinted = full.length;
                    }
                }

                // После выхода из цикла проверяем, был ли текст
                if (window._chatStreamMsg && !window._chatStreamHasText) {
                    window._chatStreamMsg.closest('.chat-message')?.remove(); // удаляем пустой блок
                }
                window._chatStreamHasText = false;
                window._chatStreamBuffer = '';
                window._chatStreamMsg = null;
                window._chatStreamPrinted = 0;
                orbTypingQueue = Promise.resolve();

                if (responseContainer) {
                    responseContainer.classList.remove("typing-cursor");
                }
                status.innerText = "speaking";
                // One strong vibration at the end of receiving
                if (tg?.HapticFeedback) tg.HapticFeedback.impactOccurred('heavy');
                else if (navigator.vibrate) navigator.vibrate([60]);

                // договариваем хвост, если он остался
                const tail = audioBuffer.slice(spokenLength);
                if (tail.trim().length > 0) {
                    speak(tail);
                }

            } catch (e) {
                console.error(e);
                status.innerText = "stream error";
                orb.classList.remove('thinking');
                orb.classList.remove('speaking');
                isThinking = false;
                isSpeaking = false;
                stopThinkingVibration();
                stopSpeakingVibration();
                stopOrbBounce();
                setTimeout(startListening, 2000);
            } finally {
                clearTimeout(processingTimeout);
                clearTimeout(researchingTimeout);
                // just in case, stop bounce
                stopOrbBounce();
            }
        }

//
// Новый typeWriterEffect: печатает по буквам с анимацией, блюром и автоскроллом
// Теперь поддерживает *orb-large* и **italic orb**
        function typeWriterEffect(element, text, options = {}) {
            let delay = typeof options === "number"
                ? options
                : (options.charDelay ?? 28);
            let wordPause = typeof options === "object" && typeof options.wordPause === "number"
                ? options.wordPause
                : 0;

            // Разбиваем текст на фрагменты: обычные, *выделенные* и **курсив**
            function parseOrbSegments(str) {
                // Поддержка:
                // *text*        -> orb-large
                // **text**      -> orb-large + italic
                let segments = [];
                let lastIndex = 0;
                let re = /(\*\*([^\*\n]+?)\*\*|\*([^\*\n]+?)\*)/g;
                let m;
                while ((m = re.exec(str)) !== null) {
                    if (m.index > lastIndex) {
                        segments.push({ type: 'plain', text: str.slice(lastIndex, m.index) });
                    }
                    if (m[2]) {
                        segments.push({ type: 'orb-italic', text: m[2] });
                    } else if (m[3]) {
                        segments.push({ type: 'orb', text: m[3] });
                    }
                    lastIndex = re.lastIndex;
                }
                if (lastIndex < str.length) {
                    segments.push({ type: 'plain', text: str.slice(lastIndex) });
                }
                return segments;
            }

            return new Promise((resolve) => {
                element.innerHTML = element.innerHTML || '';
                const segments = parseOrbSegments(text);
                let segIdx = 0;
                function typeSegment() {
                    if (segIdx >= segments.length) {
                        resolve();
                        return;
                    }
                    const seg = segments[segIdx++];
                    if (seg.type === 'plain') {
                        // Печатаем по буквам обычным способом (batch + rAF, no setTimeout per char)
                        const chars = Array.from(seg.text);
                        let i = 0;
                        const BATCH = 5;
                        function step() {
                            let n = 0;
                            while (i < chars.length && n < BATCH) {
                                const ch = chars[i++];
                                const span = document.createElement('span');
                                span.className = 'chat-char';
                                span.textContent = ch;
                                element.appendChild(span);
                                n++;
                            }
                            if (element.parentElement) {
                                element.parentElement.scrollTop = element.parentElement.scrollHeight;
                            }
                            if (i < chars.length) {
                                requestAnimationFrame(step);
                            } else {
                                typeSegment();
                            }
                        }
                        requestAnimationFrame(step);
                    } else if (seg.type === 'orb') {
                        // Печатаем выделенный фрагмент orb-large, тоже по буквам (чтобы была анимация)
                        const chars = Array.from(seg.text);
                        let i = 0;
                        let orbSpan = document.createElement('span');
                        orbSpan.className = 'chat-char orb-large';
                        element.appendChild(orbSpan);
                        function nextOrbChar() {
                            if (i >= chars.length) {
                                typeSegment();
                                return;
                            }
                            let cspan = document.createElement('span');
                            cspan.className = 'chat-char orb-large';
                            cspan.textContent = chars[i++];
                            orbSpan.appendChild(cspan);
                            if (element.parentElement) {
                                element.parentElement.scrollTop = element.parentElement.scrollHeight;
                            }
                            let d = delay;
                            if (wordPause > 0 && chars[i-1] === ' ') {
                                d += wordPause;
                            }
                            setTimeout(nextOrbChar, d);
                        }
                        nextOrbChar();
                    } else if (seg.type === 'orb-italic') {
                        const chars = Array.from(seg.text);
                        let i = 0;
                        let orbSpan = document.createElement('span');
                        orbSpan.className = 'chat-char orb-large orb-italic';
                        element.appendChild(orbSpan);
                        function nextOrbChar() {
                            if (i >= chars.length) {
                                typeSegment();
                                return;
                            }
                            let cspan = document.createElement('span');
                            cspan.className = 'chat-char orb-large orb-italic';
                            cspan.textContent = chars[i++];
                            orbSpan.appendChild(cspan);
                            if (element.parentElement) {
                                element.parentElement.scrollTop = element.parentElement.scrollHeight;
                            }
                            setTimeout(nextOrbChar, delay);
                        }
                        nextOrbChar();
                    }
                }
                typeSegment();
            });
        }

        // CSS для плавного появления букв (добавить в <head>)
        if (!document.getElementById('chat-char-style')) {
            const style = document.createElement('style');
            style.id = 'chat-char-style';
            style.textContent = `
                .chat-char {
                    display: inline;
                    opacity: 0;
                    filter: blur(3px);
                    transform: translateY(2px);
                    animation: char-appear 0.618s forwards;
                    white-space: pre-wrap;
                }
                @keyframes char-appear {
                    to {
                        opacity: 1;
                        filter: blur(0);
                        transform: translateY(0);
                    }
                }
                .orb-large {
                    font-size: 1.01em;
                    font-weight: bold;
                    text-shadow: 0 0 12px #ffebb2, 0 0 32px #fcd37d66;
                    vertical-align: left;
                    line-height: 1;
                }
                .orb-italic {
                    font-style: italic;
                    opacity: 0.9;
                }
            `;
            document.head.appendChild(style);
        }
        
        // Гуманизация текста: убирает лишние пробелы, HTML, ремарки и markdown-символы
        function humanizeText(text) {
            // убрать HTML
            let clean = text.replace(/<[^>]*>/g, '');

            // убрать ремарки в скобках: (тихо), (пауза), (гудение) и т.п.
            // поддержка круглых и квадратных скобок
            clean = clean.replace(/\([^)]*\)/g, '');
            clean = clean.replace(/\[[^\]]*\]/g, '');

            // убрать markdown-символы
            clean = clean.replace(/[*_#]/g, '');

            // нормализовать пробелы
            clean = clean.replace(/\s+/g, ' ').trim();

            return clean;
        }

        // Говорит текст, разбивая на предложения для естественности
        function triggerOrbClick() {
            const clickEvent = new MouseEvent('click', {
                view: window,
                bubbles: true,
                cancelable: true
            });
            orb.dispatchEvent(clickEvent);
        }

        // === Session Resonance Model ===
        // 0 … 1 — степень сонастройки с вниманием слушателя
        let sessionResonance = 0.0;
        let lastSpeakTime = performance.now();

        function updateSessionResonance() {
            const now = performance.now();
            const dt = Math.min(5000, now - lastSpeakTime);
            lastSpeakTime = now;

            // медленный рост при стабильной речи
            const growth = 0.00004 * dt;

            // лёгкая утечка, чтобы резонанс не залипал
            const decay = 0.000015 * dt;

            sessionResonance += growth;
            sessionResonance -= decay;

            sessionResonance = Math.max(0, Math.min(1, sessionResonance));
        }

        // === Vocal Temperature Model ===
        // диапазон: -1 (холод) … +1 (тепло)
        function computeVocalTemperature() {
            const mood = typeof selfAwareness?.mood === 'number' ? selfAwareness.mood : 0;
            const fatigue = typeof selfAwareness?.fatigue === 'number' ? selfAwareness.fatigue : 0;
            const curiosity = typeof selfAwareness?.curiosity === 'number' ? selfAwareness.curiosity : 0;

            let t =
                mood * 0.6
                - fatigue * 0.4
                + (Math.random() - 0.5) * curiosity * 0.2;

            return Math.max(-1, Math.min(1, t));
        }

        // Говорит текст с живыми паузами, междометиями и микроварьированием голоса
        function speak(text) {
            // === 2) Защита от overlap TTS ===
            if (window.recognition && recognition.abort) {
                try { recognition.abort(); } catch(e){}
            }
            if (speechSynthesis.speaking || speechSynthesis.pending) {
                speechSynthesis.cancel();
                setTimeout(() => {}, 30);
            }
            if (!text || !text.trim()) return;

            updateSessionResonance();

            // Остановить все текущие вибрации и процессы
            stopListeningVibration();
            stopThinkingVibration();
            stopSpeakingVibration();
            // recognition.abort();

            // Плавное визуальное переключение с анимацией
            orb.classList.remove('listening', 'thinking');
            requestAnimationFrame(() => {
                orb.classList.add('speaking');
                status.innerText = "speaking";
                setTimeout(() => {
                    vibrateSpeaking();
                }, 50);
            });
            isSpeaking = true;

            // === Vocal temperature tuning ===
            const vocalTemperature = computeVocalTemperature();
            const resonanceBias = sessionResonance * 0.25;
            let rate = 1.08;
            let pitch = 0.95;
            if (userGender === 'female') pitch += 0.15;
            if (userGender === 'male') pitch -= 0.05;
            if (vocalTemperature < -0.3) {
                rate += Math.abs(vocalTemperature) * 0.18;
                pitch -= Math.abs(vocalTemperature) * 0.04;
            }
            if (vocalTemperature > 0.3) {
                rate -= vocalTemperature * 0.22;
                pitch += vocalTemperature * 0.06;
            }
            rate *= 1.0 - resonanceBias * 0.15;
            pitch *= 1.0 - resonanceBias * 0.08;

            // === TTS warmup to avoid crackle after pause ===
            if (!speechSynthesis.speaking && !speechSynthesis.pending) {
                const warmup = new SpeechSynthesisUtterance(' ');
                warmup.volume = 0.01;
                warmup.rate = rate;
                warmup.pitch = pitch;
                if (currentVoice) warmup.voice = currentVoice;
                speechSynthesis.speak(warmup);
            }

            // Гуманизация текста + разбиение на фрагменты
            let cleanedForSpeech = humanizeText(text)
                .replace(/\\+/g, '')
                // убираем запятые и двоеточия из TTS (иначе говорит "запятая")
                .replace(/[,;:]/g, ' ')
                // точки, ! и ? оставляем как паузы
                .replace(/[^\wа-яА-ЯёЁa-zA-Z0-9.!? ]+/g, '')
                .replace(/\s+/g, ' ')
                .trim();

            // Разбиваем на предложения
            let sentences = cleanedForSpeech.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [cleanedForSpeech];
            sentences = sentences.flatMap(s => {
                if (s.length <= 120) return [s];

                const words = s.split(/\s+/);
                let out = [];
                let buf = '';

                for (let w of words) {
                    if ((buf + ' ' + w).trim().length > 80) {
                        if (buf) out.push(buf.trim());
                        buf = w;
                    } else {
                        buf += ' ' + w;
                    }
                }
                if (buf.trim()) out.push(buf.trim());
                return out;
            });

            // Массив междометий и "дыхательных" вставок
            const interjectionsByLang = {
                'ru-RU': ['мм...', 'ээ...', 'ну...', 'эм...', 'гм...', 'хм...', 'угу...', 'а...', 'так...', 'да...', 'кстати...'],
                'en-US': ['um...', 'uh...', 'hmm...', 'well...', 'so...', 'ah...', 'okay...', 'right...', 'huh...', 'hmm...'],
                'de-DE': ['äh...', 'hm...', 'nun...', 'also...', 'tja...', 'hmm...', 'ja...', 'gut...', 'ach...'],
                'fr-FR': ['euh...', 'ben...', 'alors...', 'hum...', 'ah...', 'ok...', 'bon...', 'hein...'],
                'es-ES': ['eh...', 'bueno...', 'mmm...', 'ajá...', 'vale...', 'pues...', 'ah...', 'ok...'],
                'zh-CN': ['嗯...', '啊...', '这个...', '呃...', '哦...', '唔...']
            };
            const breathingUtterances = [
                '', // обычная пауза
                '(вдох)', '(выдох)', // ru
                '(inhale)', '(exhale)', // en
                '(pause)', // универсально
                '', '', // больше пустых для редкости
            ];
            function getInterjection() {
                let arr = interjectionsByLang[currentLang] || interjectionsByLang['en-US'];
                return arr[Math.floor(Math.random() * arr.length)];
            }
            function getBreath() {
                return breathingUtterances[Math.floor(Math.random() * breathingUtterances.length)];
            }

            // Разбиваем предложения на фрагменты с микропаузами и вставками
            let fragments = [];
            for (let i = 0; i < sentences.length; ++i) {
                let s = sentences[i].trim();
                if (!s) continue;
                // Дополнительное дробление по запятым, двоеточиям и т.п.
                let parts = s.split(/([,;:—-])/g).filter(Boolean);
                let buf = '';
                for (let p of parts) {
                    buf += p;
                    if (/[,;:—-]$/.test(p) || buf.length > 45) {
                        fragments.push(buf.trim());
                        buf = '';
                    }
                }
                if (buf.trim()) fragments.push(buf.trim());
                // Иногда после предложения вставить дыхание или междометие
                if (Math.random() < 0.11) {
                    if (Math.random() < 0.55) {
                        fragments.push(getBreath());
                    } else {
                        fragments.push(getInterjection());
                    }
                }
            }

            // Дополнительные микропаузи для живости
            let enhancedFragments = [];
            for (let i = 0; i < fragments.length; ++i) {
                let frag = fragments[i];
                // Вставляем случайно междометие или дыхание между фрагментами, иногда пропускаем
                if (frag && frag.length > 0) {
                    enhancedFragments.push(frag);
                    // Вероятность паузы или вставки зависит от усталости, температуры, резонанса
                    let pauseChance = 0.08
                        + Math.max(0, selfAwareness?.fatigue || 0) * 0.2
                        + (vocalTemperature < 0 ? Math.abs(vocalTemperature) * 0.12 : 0)
                        + sessionResonance * 0.14;
                    if (Math.random() < pauseChance) {
                        if (Math.random() < 0.5) {
                            enhancedFragments.push(getBreath());
                        } else {
                            enhancedFragments.push(getInterjection());
                        }
                    }
                } else if (frag && frag.length === 0) {
                    // пустая пауза
                    enhancedFragments.push('');
                }
            }

            // Удаляем лишние пустые элементы
            enhancedFragments = enhancedFragments.filter((f, idx, arr) =>
                f && f.trim() || idx === 0 || (arr[idx - 1] && arr[idx - 1].trim())
            );

            let idx = 0;
            let utterQueue = [];

            function speakNext() {
                if (idx >= enhancedFragments.length) {
                    // Ждём реального окончания TTS
                    const waitForSpeechEnd = setInterval(() => {
                        if (!speechSynthesis.speaking && !speechSynthesis.pending) {
                            clearInterval(waitForSpeechEnd);
                            requestAnimationFrame(() => {
                                orb.classList.remove('speaking');
                                isSpeaking = false;
                                stopSpeakingVibration();
                                status.innerText = "listening";
                                if (tg?.HapticFeedback) {
                                    tg.HapticFeedback.impactOccurred('light');
                                }
                                setTimeout(() => {
                                    if (window.recognition && recognition.start) {
                                        try { recognition.start(); } catch(e){}
                                    } else {
                                        startListening();
                                    }
                                }, 400);
                            });
                        }
                    }, 120);
                    return;
                }
                let s = enhancedFragments[idx];
                idx++;
                // Пауза: если междометие или дыхание в скобках, то пауза, иначе говорим
                if (!s || !s.trim()) {
                    setTimeout(speakNext, 80 + Math.random() * 100);
                    return;
                }
                // Если это "дыхание" или междометие, озвучиваем с особым тембром или тишиной
                let isBreath = /\((вдох|выдох|inhale|exhale|pause)\)/i.test(s);
                let isInterjection = false;
                for (const arr of Object.values(interjectionsByLang)) {
                    if (arr.includes(s)) { isInterjection = true; break; }
                }
                if (isBreath) {
                    // "Тихая" пауза — короткий utterance с rate/pitch
                    const utter = new SpeechSynthesisUtterance('');
                    utter.lang = currentLang;
                    utter.rate = rate * 0.82 + (Math.random() - 0.5) * 0.08;
                    utter.pitch = pitch * 0.98 + (Math.random() - 0.5) * 0.05;
                    utter.volume = 0.0;
                    utter.onend = () => setTimeout(speakNext, 120 + Math.random() * 140);
                    utter.onerror = () => setTimeout(speakNext, 100);
                    setTimeout(() => synth.speak(utter), utterQueue.length * 16);
                    utterQueue.push(utter);
                    return;
                }
                if (isInterjection) {
                    // Для междометия — чуть быстрее, чуть выше pitch, чуть тише
                    let interjRate = rate * (1.06 + (Math.random() - 0.5) * 0.09);
                    let interjPitch = pitch * (1.07 + (Math.random() - 0.5) * 0.12);
                    let interjVol = 0.82 + (Math.random() - 0.5) * 0.13;
                    const utter = new SpeechSynthesisUtterance(s);
                    utter.lang = currentLang;
                    utter.rate = interjRate;
                    utter.pitch = interjPitch;
                    utter.volume = Math.max(0.01, Math.min(1.0, interjVol));
                    if (currentVoice) utter.voice = currentVoice;
                    utter.onstart = () => {
                        if (speakingVibrationInterval) clearInterval(speakingVibrationInterval);
                        speakingVibrationInterval = setInterval(() => {
                            if (tg?.HapticFeedback) {
                                tg.HapticFeedback.impactOccurred('light');
                            }
                        }, 320);
                    };
                    utter.onend = () => {
                        stopSpeakingVibration();
                        setTimeout(speakNext, 80 + Math.random() * 120);
                    };
                    utter.onerror = () => {
                        stopSpeakingVibration();
                        setTimeout(speakNext, 100);
                    };
                    setTimeout(() => synth.speak(utter), utterQueue.length * 18);
                    utterQueue.push(utter);
                    return;
                }
             
                let jitter = Math.min(0.025, Math.abs(vocalTemperature) * 0.04);
                jitter *= (1.0 - sessionResonance * 0.6);
                let localRate = rate * (1.0 + (Math.random() - 0.5) * jitter);
                let localPitch = pitch * (1.0 + (Math.random() - 0.5) * jitter);
              
                let localVol = 0.88 + (Math.random() - 0.5) * 0.05;
                localVol = Math.max(0.01, Math.min(1.0, localVol));
                const utter = new SpeechSynthesisUtterance(s);
                utter.lang = currentLang;
                utter.rate = localRate;
                utter.pitch = localPitch;
                utter.volume = localVol;
                if (currentVoice) utter.voice = currentVoice;
                utter.onstart = () => {
                    if (speakingVibrationInterval) clearInterval(speakingVibrationInterval);
                    speakingVibrationInterval = setInterval(() => {
                        if (tg?.HapticFeedback) {
                            tg.HapticFeedback.impactOccurred('light');
                        }
                    }, 300);
                };
                utter.onend = () => {
                    stopSpeakingVibration();
                    setTimeout(speakNext, 60 + Math.random() * 110);
                };
                utter.onerror = () => {
                    stopSpeakingVibration();
                    setTimeout(speakNext, 100);
                };
                setTimeout(() => synth.speak(utter), utterQueue.length * 20);
                utterQueue.push(utter);
            }
            setTimeout(speakNext, 100);
        }
        
        
        
        window.addEventListener('load', () => {
            setTimeout(() => {
                vibrate('light');
                startListening();
            }, 1200);
        });

        // ====== camera ======
        const cameraVideo = document.getElementById('camera-video');
        let currentCamera = 'user'; // 'user' (front) or 'environment' (back)
        let stream = null;

        async function startCamera(facingMode = currentCamera) {
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode },
                    audio: false
                });
                cameraVideo.srcObject = stream;
                cameraVideo.style.display = 'block';
            } catch (e) {
                // alert,  UI
                cameraVideo.style.display = 'none';
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            cameraVideo.srcObject = null;
            cameraVideo.style.display = 'none';
        }

        function switchCamera() {
            currentCamera = currentCamera === 'user' ? 'environment' : 'user';
            startCamera(currentCamera);
        }

  
        const visionCanvas = document.createElement('canvas');
        visionCanvas.style.display = 'none';
        document.body.appendChild(visionCanvas);
        const visionCtx = visionCanvas.getContext('2d');

        // ===== OpenCV.js Vision Detection =====
        // OpenCV.js
        let opencvReady = false;
        let faceCascade = null;
        let cascadeLoaded = false;
        let pendingVisionFrames = [];


        function loadCascade() {
            if (faceCascade || !opencvReady) return;
            faceCascade = new cv.CascadeClassifier();
            // Файл cascade доступен по ссылке OpenCV, используем frontalface_default.xml
            const cascadeFile = 'haarcascade_frontalface_default.xml';
            const cascadeUrl = 'https://raw.githubusercontent.com/opencv/opencv/master/data/haarcascades/haarcascade_frontalface_default.xml';
            cv.FS_createPreloadedFile('/', cascadeFile, cascadeUrl, true, false, () => {
                faceCascade.load(cascadeFile);
                cascadeLoaded = true;
      
                while (pendingVisionFrames.length > 0) {
                    const args = pendingVisionFrames.shift();
                    detectFacesAndSend(...args);
                }
            }, () => {
                cascadeLoaded = false;
            });
        }

        // OpenCV.js onRuntimeInitialized
        window.cv = window.cv || {};
        window.Module = window.Module || {};
        window.Module['onRuntimeInitialized'] = () => {
            opencvReady = true;
            loadCascade();
        };

     
        async function detectFacesAndSend(frameCanvas, width, height) {
            if (!opencvReady || !cascadeLoaded) {
               
                pendingVisionFrames.push([frameCanvas, width, height]);
                return;
            }
            try {
               
                let src = cv.imread(frameCanvas);
                let gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                let faces = new cv.RectVector();
                let msize = new cv.Size(0, 0);
                faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, msize, msize);
                let count = faces.size();
                let desc = '';
                if (count === 0) {
                    desc = 'Лиц не обнаружено.';
                } else if (count === 1) {
                    desc = 'Обнаружено 1 лицо в кадре.';
                } else {
                    desc = `Обнаружено лиц: ${count}.`;
                }
         
                src.delete();
                gray.delete();
                faces.delete();
                msize.delete();
             
                latestCameraDescription = desc;
              
            } catch (e) {
             
            }
        }

  
        // --- TensorFlow.js integration for object detection ---
  
        let tfReady = false;
        let tfModel = null;
        let tfLoadingPromise = null;
        let tfScriptLoaded = false;
        let tfLoadStarted = false;
      
        const OBJECTS_OF_INTEREST = [
            { ru: "стол", en: ["dining table", "table", "desk"] },
            { ru: "ноутбук", en: ["laptop"] },
            { ru: "окно", en: ["window"] },
            { ru: "лампа", en: ["lamp"] },
            { ru: "растение", en: ["potted plant", "plant"] }
        ];

        function loadTensorFlowIfNeeded() {
            if (tfReady || tfLoadStarted) return tfLoadingPromise;
            tfLoadStarted = true;
            tfLoadingPromise = new Promise((resolve, reject) => {
     
                function loadScript(src, onload) {
                    const s = document.createElement('script');
                    s.src = src;
                    s.onload = onload;
                    s.async = true;
                    document.head.appendChild(s);
                }
                loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js', () => {
                    tfScriptLoaded = true;
                    loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js', async () => {
                     
                        let tries = 0;
                        function waitForTF() {
                            if (window.tf && window.cocoSsd) {
                                window.cocoSsd.load().then(model => {
                                    tfModel = model;
                                    tfReady = true;
                                    resolve();
                                });
                            } else if (tries < 50) {
                                tries++;
                                setTimeout(waitForTF, 200);
                            } else {
                                reject(new Error("TensorFlow.js load timeout"));
                            }
                        }
                        waitForTF();
                    });
                });
            });
            return tfLoadingPromise;
        }

        let cameraAnalysisInterval = null;
        // analyzeAndSendCameraFrame
        async function analyzeAndSendCameraFrame() {
            if (!cameraEnabled) return;

            try {
                
                if (
                    cameraVideo.style.display !== 'block' ||
                    cameraVideo.readyState < 2 ||
                    cameraVideo.videoWidth <= 0 || cameraVideo.videoHeight <= 0
                ) return;

                visionCanvas.width = cameraVideo.videoWidth;
                visionCanvas.height = cameraVideo.videoHeight;
                visionCtx.drawImage(cameraVideo, 0, 0, visionCanvas.width, visionCanvas.height);

                let faceDesc = '';
                let objectsDesc = '';
                let detectedObjectsRu = [];

                // --- OpenCV.js face detection ---
                try {
                    if (opencvReady && cascadeLoaded) {
                        let src = null, gray = null, faces = null, msize = null;
                        try {
                            src = cv.imread(visionCanvas);
                            if (!src || src.empty()) throw new Error("Canvas пустой или некорректный");
                            gray = new cv.Mat();
                            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                            faces = new cv.RectVector();
                            msize = new cv.Size(0, 0);
                            faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, msize, msize);
                            let count = faces.size();
                            faceDesc = count === 0 ? 'Обнаружено лиц: 0' : `Обнаружено лиц: ${count}`;
                        } finally {
                            if (src) src.delete();
                            if (gray) gray.delete();
                            if (faces) faces.delete();
                            if (msize) msize.delete();
                        }
                    } else {
                        faceDesc = 'Лиц не анализируем (OpenCV не готов).';
                    }
                } catch(e) {
                    console.warn("Face analysis skipped:", e);
                    faceDesc = '';
                }

                // --- TensorFlow.js object detection ---
                try {
                    await loadTensorFlowIfNeeded();
                    if (tfReady && tfModel) {
                        const predictions = await tfModel.detect(visionCanvas);
                        for (const obj of OBJECTS_OF_INTEREST) {
                            const found = predictions.find(p =>
                                obj.en.some(enName => (p.class || p.className || "").toLowerCase().includes(enName))
                                && p.score > 0.35
                            );
                            if (found) detectedObjectsRu.push(obj.ru);
                        }
                        if (detectedObjectsRu.length > 0) objectsDesc = 'видны: ' + detectedObjectsRu.join(', ');
                    }
                } catch(e) {
                    console.error("Ошибка анализа объектов:", e);
                }

                latestCameraDescription =
                    (faceDesc ? faceDesc : '') +
                    (objectsDesc ? (faceDesc ? '; ' : '') + objectsDesc + '.' : '');

                if (!latestCameraDescription) {
                    latestCameraDescription = 'Кадр без значимых объектов.';
                }

                const now = performance.now();
                let gemmaImage = null;

                if (now - lastGemmaImageTime > GEMMA_IMAGE_INTERVAL) {
                    gemmaImage = captureSmallImageBase64();
                    lastGemmaImageTime = now;
                }

                // Self-Awareness
                try {
                    if (latestCameraDescription && !latestCameraDescription.includes('Ошибка')) {
                        selfAwareness.analyzeFrame(latestCameraDescription);
                        orb.classList.add('reflecting');
                        setTimeout(() => orb.classList.remove('reflecting'), 1500);
                    }
                } catch(e) {
                    console.error("Ошибка selfAwareness:", e);
                }

                try {
                    const userId = tg?.initDataUnsafe?.user?.id || 0;
                    await fetch('https://patronal-mayme-unexpandable.ngrok-free.dev/api/camera_analysis', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
                        body: JSON.stringify({
                            user_id: userId,
                            description: latestCameraDescription,
                            image: gemmaImage
                        })
                    });
                } catch(e) {
                    console.error("Ошибка отправки описания камеры:", e);
                }
            } catch(e) {
                console.error("Ошибка в analyzeAndSendCameraFrame:", e);
            }
        }
        function startCameraAnalysisLoop() {
            if (cameraAnalysisInterval) clearInterval(cameraAnalysisInterval);
            cameraAnalysisInterval = setInterval(analyzeAndSendCameraFrame, 2000);
        }
        function stopCameraAnalysisLoop() {
            if (cameraAnalysisInterval) clearInterval(cameraAnalysisInterval);
            cameraAnalysisInterval = null;
        }

        // ===== cameraEnabled =====
        let cameraEnabled = false;
  
        const prevOnResult = recognition.onresult;
        recognition.onresult = async (event) => {
            const text = event.results[0][0].transcript;
           
            if (/\b(включи музыку|музыка включена|старт музыки)\b/i.test(text)) {
                if (!musicPlaying) {
                    if (musicCtx.state === 'suspended') await musicCtx.resume();
                    startMusic();
                }
                return;
            }
          
            if (/\b(включи камеру|покажи камеру|открой камеру|камера)\b/i.test(text)) {
                if (cameraVideo.style.display !== 'block') {
                    startCamera(currentCamera);
                    cameraEnabled = true;
                }
            }
            if (/\b(выключи камеру|закрой камеру|скрой камеру|убери камеру)\b/i.test(text)) {
                if (cameraVideo.style.display === 'block') {
                    stopCamera();
                    cameraEnabled = false;
                }
            }
            if (/\b(переключи камеру|сменить камеру|другая камера|переверни камеру)\b/i.test(text)) {
                switchCamera();
            }

         
            const ambientTriggerWords = ['старт', 'музыка', 'ambient', 'звуки'];
            if (ambientTriggerWords.some(word => text.toLowerCase().includes(word))) {
                triggerAmbient();
            }

           
            if (typeof prevOnResult === 'function') {
                await prevOnResult(event);
            }
        };

        const origStartCamera = startCamera;
        startCamera = async function(...args) {
            await origStartCamera.apply(this, args);
            cameraEnabled = true;
            startCameraAnalysisLoop();
        }
        const origStopCamera = stopCamera;
        stopCamera = function(...args) {
            origStopCamera.apply(this, args);
            cameraEnabled = false;
            stopCameraAnalysisLoop();
        }


        // Utility: stick chat to bottom if near bottom
        function stickChatToBottom(container, threshold = 24) {
            return (
                container.scrollHeight -
                container.scrollTop -
                container.clientHeight
            ) <= threshold;
        }

        // Utility: scroll chat to bottom
        function scrollChatToBottom() {
            const chatContainer = document.getElementById('chatMessages');
            if (!chatContainer) return;
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // ===== Chat Panel Management =====
        // === Chat typing animation with word-by-word effect, supporting glitch and markdown styling ===
        // Glitch helpers
        function randomGlitchChar(base) {
            // Unicode combining diacritics for glitch
            const glitchUp = "\u030d\u030e\u0304\u0305\u033f\u0311\u0306\u0310\u0352\u0357\u0351\u0307\u0308\u030a\u0342\u0343\u0344\u034a\u034b\u034c\u0303\u0302\u030c\u0350\u0300\u0301\u030b\u030f\u0312\u0313\u0314\u033d\u0309\u0363\u0364\u0365\u0366\u0367\u0368\u0369\u036a\u036b\u036c\u036d\u036e\u036f\u033e\u035b\u0346\u031a";
            const glitchDown = "\u0316\u0317\u0318\u0319\u031c\u031d\u031e\u031f\u0320\u0324\u0325\u0326\u0329\u032a\u032b\u032c\u032d\u032e\u032f\u0330\u0331\u0332\u0333\u0339\u033a\u033b\u033c\u0345\u0347\u0348\u0349\u034d\u034e\u0353\u0354\u0355\u0356\u0359\u035a\u0323";
            const glitchMid = "\u0315\u031b\u0340\u0341\u0358\u0321\u0322\u0327\u0328\u0334\u0335\u0336\u034f\u035c\u035d\u035e\u035f\u0360\u0362\u0338\u0337\u0361\u0489";
            let out = base;
            let up = Math.floor(Math.random() * 2) + 1;
            let down = Math.floor(Math.random() * 2);
            let mid = Math.floor(Math.random() * 2);
            for (let i = 0; i < up; ++i) out += glitchUp[Math.floor(Math.random() * glitchUp.length)];
            for (let i = 0; i < down; ++i) out += glitchDown[Math.floor(Math.random() * glitchDown.length)];
            for (let i = 0; i < mid; ++i) out += glitchMid[Math.floor(Math.random() * glitchMid.length)];
            return out;
        }

        // Glitch animation: for spans with .glitch-animate, update their textContent every 60ms
        function startGlitchAnimation(span, baseText) {
            if (span._glitchAnim) clearInterval(span._glitchAnim);
            span._glitchAnim = setInterval(() => {
                span.textContent = randomGlitchChar(baseText);
            }, 60 + Math.random() * 50);
        }
        function stopGlitchAnimation(span, baseText) {
            if (span._glitchAnim) {
                clearInterval(span._glitchAnim);
                span._glitchAnim = null;
            }
            span.textContent = baseText;
        }

        // === Code block detection for chat messages ===
        function detectCodeBlock(text) {
            if (!text) return false;
            const t = text.trimStart();
            // fenced code block only if at start
            if (t.startsWith('```')) return true;
            // code-like syntax only if at start of message
            if (/^(const|let|var|function|class|import|export|def|if|for|while|return)\b/.test(t)) return true;
            // HTML only if starts at beginning
            if (/^<[^>]+>/.test(t)) return true;
            return false;
        }

        function parseMarkdownSegments(text) {
            // Returns array of {type:..., text:...}
            // Supported: **bold**, *italic*, ~glitch~
            let regex = /(\*\*([^*]+)\*\*|\*([^*]+)\*|~([^~]+)~)/g;
            let segments = [];
            let lastIndex = 0;
            let m;
            while ((m = regex.exec(text)) !== null) {
                if (m.index > lastIndex) {
                    segments.push({ type: "plain", text: text.slice(lastIndex, m.index) });
                }
                if (m[2]) {
                    segments.push({ type: "bold", text: m[2] });
                } else if (m[3]) {
                    segments.push({ type: "italic", text: m[3] });
                } else if (m[4]) {
                    segments.push({ type: "glitch", text: m[4] });
                }
                lastIndex = regex.lastIndex;
            }
            if (lastIndex < text.length) {
                segments.push({ type: "plain", text: text.slice(lastIndex) });
            }
            return segments;
        }

        function typeWriterWordsEffect(element, text, charDelay = 1, wordDelay = 5) {
            return new Promise((resolve) => {
                if (detectCodeBlock(text)) {
                    const pre = document.createElement('pre');
                    pre.className = 'code-artifact';
                    const code = document.createElement('code');

                    let codeText = text.trimStart();
                    if (codeText.startsWith('```')) {
                        codeText = codeText.replace(/^```[\w-]*\n?/, '').replace(/```$/, '');
                    }

                    code.textContent = codeText;
                    pre.appendChild(code);
                    element.appendChild(pre);
                    resolve();
                    return;
                }

                text = text.replace(/^[.\s]+/, '');
                if (!text || !text.trim()) {
                    resolve();
                    return;
                }

                const isAI = element.closest('.chat-message')?.classList.contains('ai');
                let cursor = null;

                if (isAI) {
                    cursor = element.querySelector('.ai-cursor');
                    if (!cursor) {
                        cursor = document.createElement('span');
                        cursor.className = 'ai-cursor';
                        element.appendChild(cursor);
                    }
                }

                const segments = parseMarkdownSegments(text);

                // === Fast render buffers ===
                let segIdx = 0;
                let buffer = [];
                let flushing = false;
                const MAX_BATCH = 12;

                function flushBuffer() {
                    if (buffer.length === 0) return;
                    const frag = document.createDocumentFragment();
                    for (const n of buffer) frag.appendChild(n);
                    buffer.length = 0;
                    element.insertBefore(frag, cursor || null);
                    scrollChatToBottom();
                }

                function scheduleFlush() {
                    if (flushing) return;
                    flushing = true;
                    requestAnimationFrame(() => {
                        flushBuffer();
                        flushing = false;
                    });
                }

                function typeNextSegment() {
                    if (segIdx >= segments.length) {
                        flushBuffer();
                        if (cursor) cursor.remove();
                        resolve();
                        return;
                    }

                    const seg = segments[segIdx++];
                    let chars = Array.from(seg.text);
                    let i = 0;

                    function step() {
                        let count = 0;
                        while (i < chars.length && count < MAX_BATCH) {
                            const span = document.createElement('span');
                            span.className = 'chat-char';

                            if (seg.type === 'italic') span.classList.add('chat-italic');
                            if (seg.type === 'bold') span.classList.add('chat-bold');
                            if (seg.type === 'glitch') {
                                span.classList.add('chat-glitch');
                                span._baseText = chars[i];
                                startGlitchAnimation(span, span._baseText);
                            }

                            span.textContent = chars[i++];

                            // мягкий магнетизм + блюр при появлении
                            span.style.filter = 'blur(2px)';
                            span.style.transform = 'translateY(2px) scale(0.985)';
                            span.style.opacity = '0';

                            requestAnimationFrame(() => {
                                span.style.transition = 'filter 160ms ease, transform 160ms ease, opacity 120ms ease';
                                span.style.filter = 'blur(0px)';
                                span.style.transform = 'translateY(0px) scale(1)';
                                span.style.opacity = '1';
                            });

                            buffer.push(span);
                            count++;
                        }

                        scheduleFlush();

                        if (i < chars.length) {
                            requestAnimationFrame(step);
                        } else {
                            setTimeout(typeNextSegment, wordDelay);
                        }
                    }

                    step();
                }

                typeNextSegment();
            });
        }

        // typeChatMessage: uses typeWriterWordsEffect, applies real-time markdown styling and glitch
        function typeChatMessage(text, container) {
            if (!text || !text.trim()) return;
            const isAI = container.closest('.chat-message')?.classList.contains('ai');

            let cursor = null;

            // === USER MESSAGE: instant appear with soft animation ===
            if (!isAI) {
                container.innerHTML = text;
                container.classList.add('user-appear');
                requestAnimationFrame(() => {
                    container.classList.add('user-appear-active');
                });
                scrollChatToBottom();
                return;
            }

            // === AI MESSAGE: keep existing typing ===
            cursor = document.createElement('span');
            cursor.className = 'ai-cursor';
            container.appendChild(cursor);

            typeWriterWordsEffect(container, text).then(() => {
                // Remove cursor if present
                if (cursor && cursor.parentNode) cursor.remove();
                container.classList.remove('chat-cursor');
                // After full type, stop glitch animation and set final text for glitch spans
                container.querySelectorAll('.chat-glitch').forEach(span => {
                    stopGlitchAnimation(span, span._baseText || span.textContent);
                });
                scrollChatToBottom();
            });
        }

        // Add CSS for chat-char, chat-italic, chat-bold, chat-glitch, glitch-animate
        if (!document.getElementById('chat-char-style-glitch')) {
            const style = document.createElement('style');
            style.id = 'chat-char-style-glitch';
            style.textContent = `
                .chat-char {
                    display: inline;
                    opacity: 0;
                    filter: blur(3px);
                    transform: translateY(2px);
                    animation: char-appear 0.618s forwards;
                    white-space: pre-wrap;
                }
                .chat-italic {
                    opacity: 0.6 !important;
                    font-style: italic;
                    filter: blur(0.5px);
                    transition: opacity 0.2s, filter 0.2s;
                }
                .chat-bold {
                    font-weight: bold;
                    font-size: 1.03em;
                    letter-spacing: 0.001em;
                    filter: none;
                }
                .chat-glitch {
                    color: #e0e0ff;
                    text-shadow: 0 0 2px #fff, 0 0 3px #ff00c8, 0 0 8px #00ffe1;
                    font-style: oblique;
                    font-weight: 600;
                    position: relative;
                    filter: blur(0.5px) brightness(1.2);
                    transition: filter 0.168s;
                }
                .glitch-animate {
                    animation: glitch-flicker 0.314s infinite alternate;
                }
                .code-artifact {
                    background: rgba(0,0,0,0.3);
                    padding: 14px 16px;
                    margin: 8px 0;
                    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
                    font-size: 0.88em;
                    line-height: 1.45;
                    color: #e6e6e6;
                    box-shadow: 0 0 24px rgba(0,255,255,0.03);
                    overflow-x: auto;
                }
                .code-artifact code {
                    white-space: pre;
                }
                @keyframes char-appear {
                    to {
                        opacity: 1;
                        filter: blur(0);
                        transform: translateY(0);
                    }
                }
                @keyframes glitch-flicker {
                    from { filter: blur(0.5px) brightness(1.2); }
                    to   { filter: blur(2px) brightness(1.5); }
                }
                .user-appear {
                    opacity: 0;
                    transform: translateY(4px) scale(0.98);
                    filter: blur(2px);
                    transition:
                        opacity 1.31s ease-out,
                        transform 1.16s cubic-bezier(.2,.8,.2,1),
                        filter 0.16s ease-out;
                }
                .user-appear-active {
                    opacity: 1;
                    transform: translateY(0) scale(1);
                    filter: blur(0);
                }
            `;
            document.head.appendChild(style);
        }

        const mainWrapper = document.getElementById('mainWrapper');
        const chatPanel = document.getElementById('chatPanel');
        const closeChat = document.getElementById('closeChat');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendBtn = document.getElementById('sendBtn');

        let chatOpen = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchX = 0;
        let isDragging = false;
        let draggingRAF = null;
        let dragTranslateX = 0;

        // Add CSS transition for mainWrapper for smoothness
        if (mainWrapper) {
          mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
        }

        // Utility: get current translateX (px) of mainWrapper
        function getMainWrapperTranslateX() {
          if (!mainWrapper) return 0;
          const style = window.getComputedStyle(mainWrapper);
          let matrix = style.transform;
          if (matrix && matrix !== 'none') {
            const m = matrix.match(/matrix(3d)?\((.+)\)/);
            if (m) {
              const parts = m[2].split(',').map(x => x.trim());
              // 2d: matrix(a, b, c, d, tx, ty)
              // 3d: matrix3d(...)
              if (parts.length >= 6) {
                return parseFloat(parts[4]);
              }
            }
          }
          return 0;
        }

        // Set mainWrapper transform (only mainWrapper, never chatPanel)
        function setMainWrapperTransform(x, withTransition = false) {
          if (mainWrapper) {
            if (withTransition) {
              mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
            } else {
              mainWrapper.style.transition = 'none';
            }
            mainWrapper.style.transform = x === 0 ? '' : `translateX(${x}px)`;
          }
        }

        // Animate mainWrapper translateX from 'from' to 'to' px over 'duration' ms with ease
        function animateTranslateX(from, to, duration = 320) {
          if (!mainWrapper) return;
          const start = performance.now();
          function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
          }
          function step(now) {
            const elapsed = now - start;
            let t = Math.min(1, elapsed / duration);
            t = easeOutCubic(t);
            const value = from + (to - from) * t;
            mainWrapper.style.transition = 'none';
            mainWrapper.style.transform = value === 0 ? '' : `translateX(${value}px)`;
            if (t < 1) {
              requestAnimationFrame(step);
            } else {
              // Snap to final position and restore transition
              mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
              mainWrapper.style.transform = to === 0 ? '' : `translateX(${to}px)`;
            }
          }
          requestAnimationFrame(step);
        }

        // Improved swipe logic (no jump when snapping back, proper offset, only mainWrapper transform)
        document.body.addEventListener('touchstart', (e) => {
          const touch = e.changedTouches[0];
          const x = touch.clientX;
          const y = touch.clientY;
          // Prevent accidental drag from left edge if already open
          if (chatOpen && x < window.innerWidth * 0.2) {
            isDragging = false;
            return;
          }
          touchStartX = x;
          touchStartY = y;
          lastTouchX = x;
          isDragging = true;
          dragTranslateX = 0;
          if (mainWrapper) mainWrapper.style.willChange = 'transform';
        }, { passive: true });

        document.body.addEventListener('touchmove', (e) => {
          if (!isDragging) return;
          const touch = e.changedTouches[0];
          lastTouchX = touch.clientX;
          const touchY = touch.clientY;
          const deltaX = Math.abs(lastTouchX - touchStartX);
          const deltaY = Math.abs(touchY - touchStartY);
          if (deltaY > deltaX) return;
          const diff = lastTouchX - touchStartX;
          const maxOffset = -window.innerWidth * 0.8;
          // Opening (from orb): drag left, negative
          if (!chatOpen && diff < 0) {
            dragTranslateX = Math.max(diff, maxOffset);
          }
          // Closing (from open): drag right, positive
          else if (chatOpen && diff > 0) {
            dragTranslateX = Math.min(diff, 0);
            // start from maxOffset, so add diff to maxOffset (but clamp to 0)
            dragTranslateX = Math.min(maxOffset + diff, 0);
          }
          // If not enough movement, stay at 0
          else if (!chatOpen) {
            dragTranslateX = 0;
          }
          // Only mainWrapper transform, never chatPanel
          if (draggingRAF) cancelAnimationFrame(draggingRAF);
          draggingRAF = requestAnimationFrame(() => {
            setMainWrapperTransform(dragTranslateX, false);
          });
        }, { passive: true });

        document.body.addEventListener('touchend', (e) => {
          if (!isDragging) return;
          isDragging = false;
          if (mainWrapper) mainWrapper.style.willChange = '';
          if (draggingRAF) {
            cancelAnimationFrame(draggingRAF);
            draggingRAF = null;
          }
          const swipeDistance = lastTouchX - touchStartX;
          const maxOffset = -window.innerWidth * 0.8;
          // Thresholds for opening/closing
          if (swipeDistance > 60 && chatOpen) {
            closeChatPanel();
          } else if (swipeDistance < -60 && !chatOpen) {
            openChat();
          } else {
            // Animate snap back to original state (from current real offset, not just dragTranslateX)
            if (mainWrapper) {
              const currentX = getMainWrapperTranslateX();
              animateTranslateX(currentX, 0, 320);
            }
          }
        });

        function openChat() {
          chatOpen = true;
          isChatMode = true;
          if (mainWrapper) {
            mainWrapper.classList.add('chat-open');
            mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
            mainWrapper.style.transform = '';
          }
          if (typeof vibrate === 'function') vibrate('medium');
        }

        function closeChatPanel() {
          chatOpen = false;
          isChatMode = false;
          if (mainWrapper) {
            mainWrapper.classList.remove('chat-open');
            mainWrapper.style.transition = 'transform 0.32s cubic-bezier(.33,1.2,.5,1), box-shadow 0.22s';
            mainWrapper.style.transform = '';
          }
          if (typeof vibrate === 'function') vibrate('medium');
        }

        if (closeChat) {
          closeChat.addEventListener('click', closeChatPanel);
        }

        // Chat messages
        function addChatMessage(text, sender = 'user') {
          if (!chatMessages) return;
          if (!text || !text.trim()) return;
          // === SYNC TYPED USER TEXT TO ORB "You" ===
          if (sender === 'user' && typeof appendTranscript === 'function') {
              appendTranscript(text); // всегда обновляет последний You в орбе
          }
          const msgDiv = document.createElement('div');
          msgDiv.className = `chat-message ${sender}`;
          const senderDiv = document.createElement('div');
          senderDiv.className = 'sender';
          senderDiv.textContent = sender === 'user' ? 'You' : 'AI';
          const textDiv = document.createElement('div');
          textDiv.className = 'text';
          msgDiv.appendChild(senderDiv);
          msgDiv.appendChild(textDiv);
          chatMessages.appendChild(msgDiv);
          // removed direct scroll here for autoscroll patch
          // Add copy-on-click for the message (allow copying for both user and AI)
          msgDiv.addEventListener('click', () => {
              const copyText = sender === 'user' ? text : textDiv.textContent;
              navigator.clipboard.writeText(copyText).then(() => {
                  msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                  setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
              });
          });
          textDiv.innerHTML = '';
          // Используем typeChatMessage для анимации сообщений и пользователя, и AI
          typeChatMessage(text, textDiv);
        }

        // Добавить функцию для AI-сообщений с анимацией букв (fixed: prevent appending empty/blank messages)
        function addAIMessage(text) {
          if (!chatMessages) return;
          if (!text || !text.trim()) return; // Prevent empty AI messages
          const msgDiv = document.createElement('div');
          msgDiv.className = `chat-message ai`;
          const senderDiv = document.createElement('div');
          senderDiv.className = 'sender';
          senderDiv.textContent = 'AI';
          const textDiv = document.createElement('div');
          textDiv.className = 'text';
          msgDiv.appendChild(senderDiv);
          msgDiv.appendChild(textDiv);
          chatMessages.appendChild(msgDiv);
          msgDiv.addEventListener('click', () => {
              navigator.clipboard.writeText(textDiv.textContent).then(() => {
                  msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                  setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
              });
          });
          textDiv.innerHTML = '';
          typeChatMessage(text, textDiv);
        }

        // Send message
        if (sendBtn && chatInput) {
          sendBtn.addEventListener('click', () => {
            const text = chatInput.value.trim();
            // === SYNC TYPED USER TEXT TO ORB "You" (CHAT INPUT) ===
            if (typeof appendTranscript === 'function') {
                appendTranscript(text);
            }
            if (!text) return;
            // Новый вариант: используем typeChatMessage для пользователя
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message user`;
            const senderDiv = document.createElement('div');
            senderDiv.className = 'sender';
            senderDiv.textContent = 'You';
            const textDiv = document.createElement('div');
            textDiv.className = 'text';
            msgDiv.appendChild(senderDiv);
            msgDiv.appendChild(textDiv);
            chatMessages.appendChild(msgDiv);
            // removed direct scroll here for autoscroll patch
            msgDiv.addEventListener('click', () => {
                navigator.clipboard.writeText(text).then(() => {
                    msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
                });
            });
            typeChatMessage(text, textDiv);
            chatInput.value = '';
            if (typeof sendToBot === 'function') sendToBot(text);
          });
          chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendBtn.click();
          });
        }

        // recognition integration
        if (window.recognition) {
          const origRecognitionOnResult = recognition.onresult;
          recognition.onresult = function(event) {
            const text = event.results[0][0].transcript;
            // Новый вариант: typeChatMessage для пользователя
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message user`;
            const senderDiv = document.createElement('div');
            senderDiv.className = 'sender';
            senderDiv.textContent = 'You';
            const textDiv = document.createElement('div');
            textDiv.className = 'text';
            msgDiv.appendChild(senderDiv);
            msgDiv.appendChild(textDiv);
            chatMessages.appendChild(msgDiv);
            // removed direct scroll here for autoscroll patch
            msgDiv.addEventListener('click', () => {
                navigator.clipboard.writeText(text).then(() => {
                    msgDiv.style.backgroundColor = 'rgba(255,255,255,0.1)';
                    setTimeout(() => { msgDiv.style.backgroundColor = ''; }, 200);
                });
            });
            typeChatMessage(text, textDiv);
            if (origRecognitionOnResult) origRecognitionOnResult.call(this, event);
          };
        }


    </script>

    
</body>
</html>
