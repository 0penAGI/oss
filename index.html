<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
            transition: background-color 1.5s ease;
        }
        #webgl-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            opacity: 0.7;
            transition: opacity 1.5s ease;
        }
        .content {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 20px;
        }
        .soul-container {
            position: relative;
            margin-bottom: 30px;
        }
        .soul-orb {
            position: relative;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%,
                rgba(255, 255, 255, 0.9) 0%,
                rgba(200, 200, 200, 0.6) 20%,
                rgba(100, 100, 100, 0.4) 40%,
                rgba(40, 40, 40, 0.8) 70%,
                rgba(0, 0, 0, 1) 100%
            );
            box-shadow:
                0 0 60px rgba(255, 255, 255, 0.3),
                0 0 100px rgba(255, 255, 255, 0.1),
                inset -30px -30px 80px rgba(0, 0, 0, 0.9),
                inset 30px 30px 60px rgba(255, 255, 255, 0.05);
            animation: breathe 4s infinite ease-in-out;
            cursor: pointer;
            transition: all 0.3s ease, transform 0.5s ease;
        }
        .soul-orb::before {
            content: '';
            position: absolute;
            top: 18%;
            left: 25%;
            width: 35%;
            height: 35%;
            border-radius: 50%;
            background: radial-gradient(circle,
                rgba(255, 255, 255, 0.9) 0%,
                rgba(255, 255, 255, 0.4) 40%,
                transparent 70%
            );
            filter: blur(8px);
        }
        .soul-orb::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            background: radial-gradient(circle at 70% 70%,
                transparent 40%,
                rgba(0, 0, 0, 0.6) 80%
            );
        }
        .aura {
            position: absolute;
            inset: -20px;
            border-radius: 50%;
            background: radial-gradient(circle,
                transparent 60%,
                rgba(255, 255, 255, 0.1) 70%,
                transparent 100%
            );
            animation: auraGlow 3s infinite ease-in-out;
            opacity: 0.5;
            transition: all 1.5s ease;
        }
        .soul-orb.listening { 
            animation: pulse 1.2s infinite ease-in-out; 
            box-shadow: 0 0 80px rgba(255,255,255,0.5), 
                        0 0 120px rgba(255,255,255,0.3), 
                        inset -30px -30px 80px rgba(0,0,0,0.9), 
                        inset 30px 30px 60px rgba(255,255,255,0.05); 
        }
        .soul-orb.listening .aura { animation: auraExpand 1.2s infinite ease-in-out; }
        .soul-orb.speaking { 
            animation: vibrate 0.15s infinite linear; 
            box-shadow: 0 0 100px rgba(255,255,255,0.7), 
                        0 0 150px rgba(255,255,255,0.4), 
                        inset -30px -30px 80px rgba(0,0,0,0.9), 
                        inset 30px 30px 60px rgba(255,255,255,0.05); 
        }
        .soul-orb.thinking { animation: rotate 2s infinite linear; }
        
        @keyframes breathe { 0%,100%{transform:scale(1)} 50%{transform:scale(1.05)} }
        @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.12)} }
        @keyframes vibrate { 
            0%{transform:translate(0,0) rotate(0)} 
            25%{transform:translate(-3px,3px) rotate(-1deg)} 
            50%{transform:translate(3px,-3px) rotate(1deg)} 
            75%{transform:translate(-3px,-3px) rotate(-0.5deg)} 
            100%{transform:translate(0,0) rotate(0)} 
        }
        @keyframes rotate { from{transform:rotate(0)} to{transform:rotate(360deg)} }
        @keyframes auraGlow { 0%,100%{opacity:0.3} 50%{opacity:0.6} }
        @keyframes auraExpand { 0%,100%{transform:scale(1);opacity:0.5} 50%{transform:scale(1.3);opacity:0.8} }
        
        #status {
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.9;
            margin-bottom: 15px;
            text-shadow: 0 0 15px rgba(255,255,255,0.5);
            animation: statusFade 2s infinite ease-in-out;
            color: rgba(255, 255, 255, 0.8);
            transition: color 1.5s ease;
        }
        
        @keyframes statusFade { 0%,100%{opacity:0.7} 50%{opacity:1} }
        
        #transcript {
            font-size: 15px;
            max-width: 90%;
            text-align: center;
            opacity: 0.9;
            line-height: 1.6;
            padding: 15px;
            max-height: 180px;
            overflow-y: auto;
            color: rgba(255, 255, 255, 0.9);
            background: transparent;
            backdrop-filter: none;
            box-shadow: none;
            border: none;
            transition: color 1.5s ease;
        }
        
        #transcript::-webkit-scrollbar { width: 3px; }
        #transcript::-webkit-scrollbar-track { background: transparent; }
        #transcript::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        
        .emotion-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .emotion-fill {
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg, #ff0066, #00ccff);
            border-radius: 2px;
            transition: width 1.5s ease, background 1.5s ease;
        }
        
        .emotion-label {
            position: absolute;
            bottom: 20px;
            font-size: 11px;
            opacity: 0.6;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.6);
            transition: color 1.5s ease;
        }
        
        .tap-hint {
            position: absolute;
            bottom: 50px;
            font-size: 12px;
            opacity: 0.4;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.6);
        }
    </style>
</head>
<body>
    <canvas id="webgl-canvas"></canvas>

    <div class="content">
        <div class="soul-container">
            <div class="aura"></div>
            <div id="orb" class="soul-orb"></div>
        </div>
       
        <div id="status">resonating</div>
        <div id="transcript"></div>
    </div>
    
    <div class="emotion-bar">
        <div id="emotion-fill" class="emotion-fill"></div>
    </div>
    <div id="emotion-label" class="emotion-label">Neutral</div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js';

        // –°–∏—Å—Ç–µ–º–∞ —ç–º–æ—Ü–∏–π
        class EmotionSystem {
            constructor() {
                this.currentEmotion = {
                    valence: 0.5,    // –í–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å (–æ—Ç –Ω–µ–≥–∞—Ç–∏–≤–∞ –∫ –ø–æ–∑–∏—Ç–∏–≤—É) 0-1
                    arousal: 0.5,    // –í–æ–∑–±—É–∂–¥–µ–Ω–∏–µ (–æ—Ç —Å–ø–æ–∫–æ–π—Å—Ç–≤–∏—è –∫ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏) 0-1
                    dominance: 0.5   // –î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ (–æ—Ç –ø–æ–¥—á–∏–Ω–µ–Ω–∏—è –∫ –∫–æ–Ω—Ç—Ä–æ–ª—é) 0-1
                };
                
                this.emotionColors = {
                    // [r, g, b] –¥–ª—è —Ñ–æ–Ω–∞
                    joy: [0.3, 0.8, 0.6],
                    calm: [0.2, 0.4, 0.8],
                    sad: [0.4, 0.3, 0.6],
                    angry: [0.8, 0.2, 0.2],
                    excited: [0.9, 0.4, 0.1],
                    neutral: [0.1, 0.1, 0.2]
                };
                
                this.emotionLabels = {
                    joy: "Joyful üåü",
                    calm: "Calm ‚òÅÔ∏è",
                    sad: "Melancholic üíß",
                    angry: "Passionate üî•",
                    excited: "Excited ‚ö°",
                    neutral: "Neutral"
                };
            }
            
            updateFromText(text) {
                // –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —ç–º–æ—Ü–∏–π
                const lowerText = text.toLowerCase();
                let valence = 0.5;
                let arousal = 0.5;
                let dominance = 0.5;
                
                // –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
                const positiveWords = ['–æ—Ç–ª–∏—á–Ω–æ', '—Ö–æ—Ä–æ—à–æ', '—Ä–∞–¥', '—Å—á–∞—Å—Ç–ª–∏–≤', '–ª—é–±–ª—é', '—Å–ø–∞—Å–∏–±–æ', '–∫—Ä—É—Ç–æ', '—à–∏–∫–∞—Ä–Ω–æ', '—Å—É–ø–µ—Ä'];
                const negativeWords = ['–ø–ª–æ—Ö–æ', '–≥—Ä—É—Å—Ç–Ω–æ', '–∑–ª–æ–π', '–Ω–µ–Ω–∞–≤–∏–∂—É', '—É–∂–∞—Å–Ω–æ', '—Å–∫—É—á–Ω–æ', '—É—Å—Ç–∞–ª', '–±–æ–ª—å–Ω–æ'];
                const excitedWords = ['–≤–∞—É', '–æ–≥–æ', '–±—ã—Å—Ç—Ä–æ', '—Å—Ä–æ—á–Ω–æ', '–≤–∞–∂–Ω–æ', '–Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ', '–ø–æ—Ç—Ä—è—Å–∞—é—â–µ'];
                const calmWords = ['—Å–ø–æ–∫–æ–π–Ω–æ', '—Ç–∏—Ö–æ', '–º–µ–¥–ª–µ–Ω–Ω–æ', '—Ä–∞—Å—Å–ª–∞–±—å—Å—è', '–æ—Ç–¥—ã—Ö', '–º–∏—Ä–Ω–æ'];
                
                let positiveCount = 0;
                let negativeCount = 0;
                let excitedCount = 0;
                let calmCount = 0;
                
                positiveWords.forEach(word => {
                    if (lowerText.includes(word)) positiveCount++;
                });
                negativeWords.forEach(word => {
                    if (lowerText.includes(word)) negativeCount++;
                });
                excitedWords.forEach(word => {
                    if (lowerText.includes(word)) excitedCount++;
                });
                calmWords.forEach(word => {
                    if (lowerText.includes(word)) calmCount++;
                });
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å
                if (positiveCount > negativeCount) {
                    valence = 0.5 + (positiveCount * 0.1);
                } else if (negativeCount > positiveCount) {
                    valence = 0.5 - (negativeCount * 0.1);
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –≤–æ–∑–±—É–∂–¥–µ–Ω–∏–µ
                if (excitedCount > calmCount) {
                    arousal = 0.5 + (excitedCount * 0.15);
                } else if (calmCount > excitedCount) {
                    arousal = 0.5 - (calmCount * 0.15);
                }
                
                // –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —ç–º–æ—Ü–∏–π
                this.currentEmotion.valence = this.lerp(this.currentEmotion.valence, valence, 0.3);
                this.currentEmotion.arousal = this.lerp(this.currentEmotion.arousal, arousal, 0.3);
                
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
                this.currentEmotion.valence = Math.max(0, Math.min(1, this.currentEmotion.valence));
                this.currentEmotion.arousal = Math.max(0, Math.min(1, this.currentEmotion.arousal));
            }
            
            lerp(start, end, amount) {
                return start + (end - start) * amount;
            }
            
            getCurrentEmotion() {
                const v = this.currentEmotion.valence;
                const a = this.currentEmotion.arousal;
                
                if (v > 0.7 && a > 0.7) return 'excited';
                if (v > 0.6 && a < 0.4) return 'calm';
                if (v > 0.6) return 'joy';
                if (v < 0.4 && a > 0.6) return 'angry';
                if (v < 0.4) return 'sad';
                return 'neutral';
            }
            
            getBackgroundColor() {
                const emotion = this.getCurrentEmotion();
                const color = this.emotionColors[emotion];
                return `rgb(${Math.floor(color[0] * 255)}, ${Math.floor(color[1] * 255)}, ${Math.floor(color[2] * 255)})`;
            }
            
            getParticleColor(emotion) {
                const colors = {
                    joy: { c1: [1.0, 0.9, 0.2], c2: [0.2, 1.0, 0.6], c3: [0.8, 0.3, 1.0] },
                    calm: { c1: [0.2, 0.5, 1.0], c2: [0.4, 0.8, 1.0], c3: [0.6, 0.3, 0.9] },
                    sad: { c1: [0.4, 0.3, 0.8], c2: [0.6, 0.2, 0.9], c3: [0.3, 0.5, 0.9] },
                    angry: { c1: [1.0, 0.2, 0.2], c2: [1.0, 0.5, 0.1], c3: [0.9, 0.1, 0.5] },
                    excited: { c1: [1.0, 0.8, 0.0], c2: [1.0, 0.3, 0.6], c3: [0.2, 0.9, 1.0] },
                    neutral: { c1: [0.7, 0.7, 0.9], c2: [0.4, 0.6, 1.0], c3: [0.9, 0.5, 0.7] }
                };
                return colors[emotion] || colors.neutral;
            }
            
            getVoiceParams() {
                const emotion = this.getCurrentEmotion();
                const params = {
                    rate: 1.0,
                    pitch: 1.0,
                    volume: 1.0
                };
                
                switch(emotion) {
                    case 'excited':
                        params.rate = 1.3;
                        params.pitch = 1.2;
                        params.volume = 1.1;
                        break;
                    case 'calm':
                        params.rate = 0.85;
                        params.pitch = 0.9;
                        params.volume = 0.95;
                        break;
                    case 'joy':
                        params.rate = 1.1;
                        params.pitch = 1.1;
                        params.volume = 1.05;
                        break;
                    case 'sad':
                        params.rate = 0.9;
                        params.pitch = 0.85;
                        params.volume = 0.9;
                        break;
                    case 'angry':
                        params.rate = 1.15;
                        params.pitch = 0.95;
                        params.volume = 1.15;
                        break;
                }
                
                return params;
            }
            
            updateUI() {
                const emotion = this.getCurrentEmotion();
                const label = this.emotionLabels[emotion];
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∫—É —ç–º–æ—Ü–∏–∏
                document.getElementById('emotion-label').textContent = label;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–æ—Å—É —ç–º–æ—Ü–∏–π (—à–∏—Ä–∏–Ω–∞ = –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç—å, —Ü–≤–µ—Ç = –≤–æ–∑–±—É–∂–¥–µ–Ω–∏–µ)
                const fill = document.getElementById('emotion-fill');
                const width = this.currentEmotion.valence * 100;
                const hue = this.currentEmotion.arousal * 120 + 240; // –û—Ç —Ñ–∏–æ–ª–µ—Ç–æ–≤–æ–≥–æ –∫ –∫—Ä–∞—Å–Ω–æ–º—É
                fill.style.width = `${width}%`;
                fill.style.background = `linear-gradient(90deg, 
                    hsl(${hue}, 100%, 60%), 
                    hsl(${(hue + 60) % 360}, 100%, 60%))`;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç —Å—Ç–∞—Ç—É—Å–∞
                document.getElementById('status').style.color = 
                    `hsl(${hue}, 100%, 85%)`;
                    
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ç–∞
                document.getElementById('transcript').style.color = 
                    `hsl(${hue}, 80%, 90%)`;
                
                return emotion;
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —ç–º–æ—Ü–∏–π
        const emotionSystem = new EmotionSystem();

        const canvas = document.getElementById('webgl-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 5;

        // –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —à–µ–π–¥–µ—Ä –¥–ª—è —á–∞—Å—Ç–∏—Ü —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —ç–º–æ—Ü–∏–π
        const vertexShader = `
            attribute float size;
            attribute vec3 customColor;
            varying vec3 vColor;
            void main() {
                vColor = customColor;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            uniform float time;
            uniform vec3 emotionColor1;
            uniform vec3 emotionColor2;
            uniform vec3 emotionColor3;
            uniform float emotionIntensity;
            varying vec3 vColor;

            vec3 XDust(vec3 p, vec3 c1, vec3 c2, vec3 c3) {
                vec3 dir = normalize(p - vec3(0.5, 0.5, 0.0));
                float d = length(dir);
                float anim = time * (0.3 + emotionIntensity * 0.4);
                
                if (d > 0.8 && d < 1.2) {
                    float t = fract(sin(d * 3.141592653589793) * anim + c1.x);
                    return mix(c1, c2, t) * (0.8 + emotionIntensity * 0.4);
                } else {
                    float t = fract(cos(d * 3.141592653589793) * anim + c2.y);
                    return mix(c2, c3, t) * (0.6 + emotionIntensity * 0.6);
                }
            }

            void main() {
                vec3 p = gl_PointCoord.xyx / vec3(2.0);
                vec3 color = XDust(p, emotionColor1, emotionColor2, emotionColor3);
                float dist = length(gl_PointCoord - vec2(0.5));
                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                gl_FragColor = vec4(color * vColor * (0.8 + emotionIntensity * 0.4), 
                                  alpha * (0.7 + emotionIntensity * 0.3));
            }
        `;

        const particleCount = 15000;
        const positions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;

            sizes[i] = Math.random() * 3 + 1;

            colors[i * 3] = 1;
            colors[i * 3 + 1] = 1;
            colors[i * 3 + 2] = 1;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0 },
                emotionColor1: { value: new THREE.Vector3(0.7, 0.7, 0.9) },
                emotionColor2: { value: new THREE.Vector3(0.4, 0.6, 1.0) },
                emotionColor3: { value: new THREE.Vector3(0.9, 0.5, 0.7) },
                emotionIntensity: { value: 0.5 }
            },
            vertexShader,
            fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —á–∞—Å—Ç–∏—Ü –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç–º–æ—Ü–∏–π
        function updateParticleEmotion(emotion) {
            const emotionData = emotionSystem.getParticleColor(emotion);
            const intensity = emotionSystem.currentEmotion.arousal;
            
            material.uniforms.emotionColor1.value.set(
                emotionData.c1[0],
                emotionData.c1[1],
                emotionData.c1[2]
            );
            material.uniforms.emotionColor2.value.set(
                emotionData.c2[0],
                emotionData.c2[1],
                emotionData.c2[2]
            );
            material.uniforms.emotionColor3.value.set(
                emotionData.c3[0],
                emotionData.c3[1],
                emotionData.c3[2]
            );
            material.uniforms.emotionIntensity.value = intensity;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è —á–∞—Å—Ç–∏—Ü –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–æ–∑–±—É–∂–¥–µ–Ω–∏—è
            particleRotationSpeed = 0.0002 + (intensity * 0.0003);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–æ–Ω
            document.body.style.backgroundColor = emotionSystem.getBackgroundColor();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∞—É—Ä—É —à–∞—Ä–∞
            const aura = document.querySelector('.aura');
            const hue = intensity * 120 + 240;
            aura.style.background = `radial-gradient(circle,
                transparent 60%,
                hsla(${hue}, 100%, 70%, 0.3) 70%,
                transparent 100%)`;
        }

        let particleRotationSpeed = 0.0002;

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.time.value += 0.01;
            particles.rotation.y += particleRotationSpeed;
            
            // –ü–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –º–∞—Å—à—Ç–∞–±–∞ —á–∞—Å—Ç–∏—Ü –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞–ª–µ–Ω—Ç–Ω–æ—Å—Ç–∏
            const scale = 0.8 + (emotionSystem.currentEmotion.valence * 0.4);
            particles.scale.setScalar(scale);
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // –ì–æ–ª–æ—Å–æ–≤–æ–π —á–∞—Ç
        const tg = window.Telegram?.WebApp || null;
        if (tg) {
            tg.expand();
            tg.enableClosingConfirmation();
        }
        
        const orb = document.getElementById('orb');
        const status = document.getElementById('status');
        const transcriptDiv = document.getElementById('transcript');
       
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.lang = 'ru-RU';
        recognition.interimResults = false;
        recognition.continuous = false;
       
        const synth = window.speechSynthesis;
        let isSpeaking = false;
        let isThinking = false;
        
        function vibrate(pattern) {
            if (tg?.HapticFeedback) {
                if (pattern === 'light') tg.HapticFeedback.impactOccurred('light');
                else if (pattern === 'medium') tg.HapticFeedback.impactOccurred('medium');
                else if (pattern === 'heavy') tg.HapticFeedback.impactOccurred('heavy');
            } else if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }
        
        function startListening() {
            if (isSpeaking || isThinking) return;
            try {
                recognition.start();
                orb.classList.add('listening');
                orb.classList.remove('thinking');
                status.innerText = "listening";
                vibrate('light');
            } catch {}
        }
        
        recognition.onresult = async (event) => {
            const text = event.results[0][0].transcript;
            transcriptDiv.innerHTML = `<span style="color: rgba(255,255,255,0.7)">You:</span> ${text}`;
            vibrate('medium');
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —ç–º–æ—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
            emotionSystem.updateFromText(text);
            const emotion = emotionSystem.updateUI();
            updateParticleEmotion(emotion);
            
            await sendToBot(text);
        };
        
        recognition.onerror = () => {
            setTimeout(startListening, 1500);
        };
        
        recognition.onend = () => {
            orb.classList.remove('listening');
            if (!isSpeaking && !isThinking) {
                setTimeout(startListening, 1000);
            }
        };
        
        async function sendToBot(text) {
            isThinking = true;
            orb.classList.remove('listening');
            orb.classList.add('thinking');
            status.innerText = "thinking";
           
            try {
                const userId = tg?.initDataUnsafe?.user?.id || 0;
                const response = await fetch(
                    'https://patronal-mayme-unexpandable.ngrok-free.dev/api/voice_chat',
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'ngrok-skip-browser-warning': 'true'
                        },
                        body: JSON.stringify({ 
                            user_id: userId, 
                            text,
                            emotion: emotionSystem.getCurrentEmotion() // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é —ç–º–æ—Ü–∏—é
                        })
                    }
                );
                const data = await response.json();
                const reply = data.reply;
               
                transcriptDiv.innerHTML += `<br><br><span style="color: rgba(255,255,255,0.7)">AI:</span> ${reply}`;
                transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
               
                isThinking = false;
                isSpeaking = true;
                vibrate('heavy');
                speak(reply);
            } catch {
                status.innerText = "lost connection";
                orb.classList.remove('thinking');
                isThinking = false;
                isSpeaking = false;
                vibrate([100, 50, 100]);
                setTimeout(startListening, 2000);
            }
        }
        
        function speak(text) {
            orb.classList.remove('thinking');
            orb.classList.add('speaking');
            status.innerText = "speaking";
           
            const cleanText = text.replace(/<[^>]*>/g, '').replace(/[*_#]/g, '');
           
            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.lang = 'ru-RU';
            
            // –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≥–æ–ª–æ—Å–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç–º–æ—Ü–∏–π
            const voiceParams = emotionSystem.getVoiceParams();
            utterance.rate = voiceParams.rate;
            utterance.pitch = voiceParams.pitch;
            utterance.volume = voiceParams.volume;
           
            // –û–±–Ω–æ–≤–ª—è–µ–º —ç–º–æ—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ—Ç–≤–µ—Ç–∞ AI
            emotionSystem.updateFromText(text);
            const emotion = emotionSystem.updateUI();
            updateParticleEmotion(emotion);
           
            utterance.onstart = () => {
                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –ø—Ä–∏ –≥–æ–≤–æ—Ä–µ–Ω–∏–∏
                material.uniforms.emotionIntensity.value = 
                    Math.min(1.0, emotionSystem.currentEmotion.arousal + 0.2);
            };
           
            utterance.onend = () => {
                orb.classList.remove('speaking');
                isSpeaking = false;
                status.innerText = "listening";
                vibrate('light');
                startListening();
            };
           
            synth.speak(utterance);
        }
        
        orb.addEventListener('click', () => {
            vibrate('medium');
            if (!isSpeaking && !isThinking) {
                startListening();
            }
        });
        
        window.addEventListener('load', () => {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º UI —ç–º–æ—Ü–∏–π
            emotionSystem.updateUI();
            updateParticleEmotion('neutral');
            
            setTimeout(() => {
                vibrate('light');
                startListening();
            }, 1200);
        });

        // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –ø–ª–∞–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —ç–º–æ—Ü–∏–π (–¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏)
        setInterval(() => {
            if (!isSpeaking && !isThinking) {
                // –°–ª—É—á–∞–π–Ω—ã–µ —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–∏ —ç–º–æ—Ü–∏–π
                const change = (Math.random() - 0.5) * 0.05;
                emotionSystem.currentEmotion.valence = Math.max(0, Math.min(1, 
                    emotionSystem.currentEmotion.valence + change));
                
                const emotion = emotionSystem.updateUI();
                updateParticleEmotion(emotion);
            }
        }, 5000);
    </script>
</body>
</html>
