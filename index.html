<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<style>
html, body {
    margin: 0;
    padding: 0;
    background: #ffffff;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}

#gl {
    position: absolute;
    inset: 0;
}

#ui {
    position: absolute;
    bottom: 40px;
    width: 100%;
    text-align: center;
    pointer-events: none;
}

#status {
    font-size: 13px;
    opacity: 0.6;
}

#transcript {
    font-size: 12px;
    opacity: 0.45;
    margin-top: 6px;
    white-space: pre-wrap;
}
</style>
</head>

<body>

<canvas id="gl"></canvas>

<div id="ui">
    <div id="status">initializing…</div>
    <div id="transcript"></div>
</div>

<script>
// ================= TELEGRAM =================
const tg = window.Telegram.WebApp;
tg.expand();

// ================= WEBGL SETUP =================
const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0,0,canvas.width,canvas.height);

// ================= SHADERS =================
const vertSrc = `
attribute vec2 p;
void main() {
    gl_Position = vec4(p,0.0,1.0);
}
`;

const fragSrc = `
precision highp float;

uniform float u_time;
uniform float u_energy;
uniform vec2 u_res;

float noise(vec2 p){
    return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
}

void main(){
    vec2 uv = (gl_FragCoord.xy - 0.5*u_res) / min(u_res.x,u_res.y);
    float r = length(uv);

    float pulse = sin(u_time*1.6 + r*8.0) * 0.5 + 0.5;
    float core = smoothstep(0.55, 0.1, r);
    float shell = smoothstep(0.8, 0.4, r);

    float n = noise(uv*10.0 + u_time*0.2);
    float energy = u_energy * 1.6;

    float glow = core + shell * pulse * energy;
    glow += n * 0.15 * energy;

    vec3 col = vec3(0.0);
    col += glow;

    gl_FragColor = vec4(col, glow);
}
`;

function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vertSrc));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fragSrc));
gl.linkProgram(prog);
gl.useProgram(prog);

// ================= GEOMETRY =================
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

const loc = gl.getAttribLocation(prog,"p");
gl.enableVertexAttribArray(loc);
gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

// ================= UNIFORMS =================
const uTime = gl.getUniformLocation(prog,"u_time");
const uEnergy = gl.getUniformLocation(prog,"u_energy");
const uRes = gl.getUniformLocation(prog,"u_res");

// ================= AUDIO =================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioCtx();
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 256;
const freq = new Uint8Array(analyser.frequencyBinCount);

let energy = 0;

// ================= LOOP =================
function loop(t){
    analyser.getByteFrequencyData(freq);
    const avg = freq.reduce((a,b)=>a+b,0)/freq.length/255;
    energy += (avg-energy)*0.06;

    gl.uniform1f(uTime, t*0.001);
    gl.uniform1f(uEnergy, energy);
    gl.uniform2f(uRes, canvas.width, canvas.height);

    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ================= SPEECH =================
const statusEl = document.getElementById("status");
const transcriptEl = document.getElementById("transcript");

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
const rec = new SpeechRecognition();
rec.lang = "ru-RU";
rec.continuous = false;

let speaking = false;

function listen(){
    if (speaking) return;
    try {
        rec.start();
        statusEl.innerText = "listening…";
    } catch {}
}

rec.onresult = async e => {
    const text = e.results[0][0].transcript;
    transcriptEl.innerText = "You: " + text;
    send(text);
};

rec.onend = ()=>{ if(!speaking) setTimeout(listen,800); };

// ================= BACKEND =================
async function send(text){
    speaking = true;
    statusEl.innerText = "generating…";

    const uid = tg.initDataUnsafe?.user?.id || 0;

    const r = await fetch(
        "https://patronal-mayme-unexpandable.ngrok-free.dev/api/voice_chat",
        {
            method:"POST",
            headers:{
                "Content-Type":"application/json",
                "ngrok-skip-browser-warning":"true"
            },
            body:JSON.stringify({user_id:uid,text})
        }
    );

    const d = await r.json();
    transcriptEl.innerText += "\n\nBot: " + d.reply;
    speak(d.reply);
}

// ================= TTS =================
function speak(text){
    statusEl.innerText = "speaking…";
    const u = new SpeechSynthesisUtterance(text);
    u.lang="ru-RU";
    u.onend = ()=>{
        speaking=false;
        statusEl.innerText="listening…";
        listen();
    };
    speechSynthesis.speak(u);
}

// ================= START =================
window.addEventListener("load",()=>{
    setTimeout(listen,1000);
});
</script>
</body>
</html>
